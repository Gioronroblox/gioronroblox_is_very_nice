game.Players.LocalPlayer.Character["SeeMonkey"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["Pink Hair"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["Kate Hair"].Handle.Mesh:Destroy() --LavanderHair
game.Players.LocalPlayer.Character["LavanderHair"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["Robloxclassicred"].Handle.Mesh:Destroy()
--game.Players.LocalPlayer.Character["Surfboard"].Handle.Handle:Destroy()
game.Players.LocalPlayer.Character["VANS_Umbrella"].Handle.Mesh:Destroy()

local c = game.Players.LocalPlayer.Character
for i, v in pairs({"Right Arm", "Left Arm"}) do
    local arm = c[v]
    arm.Parent = nil
    arm.Transparency = 1
    arm.Parent = c
end

local c = game.Players.LocalPlayer.Character
for i, v in pairs({"Right Leg", "Left Leg"}) do
    local Leg = c[v]
    Leg.Parent = nil
    Leg.Transparency = 1
    Leg.Parent = c
end

local v3_net, v3_808 = Vector3.new(0, 25.1, 0), Vector3.new(8, 0, 8)
		local function getNetlessVelocity(realPartVelocity)
			local mag = realPartVelocity.Magnitude
			if mag > 1 then
				local unit = realPartVelocity.Unit
				if (unit.Y > 0.25) or (unit.Y < -0.75) then
					return unit * (25.1 / unit.Y)
				end
			end 
			return v3_net + realPartVelocity * v3_808
		end
		local simradius = "shp" --simulation radius (net bypass) method
--simulation radius (net bypass) method
--"shp" - sethiddenproperty
--"ssr" - setsimulationradius
--false - disable
local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
local newanimate = true --disables the animate script and enables after reanimation
local discharscripts = true --disables all localScripts parented to your character before reanimation
local R15toR6 = true --tries to convert your character to r6 if its r15
local hatcollide = true --makes hats cancollide (only method 0)
local humState16 = true --enables collisions for limbs before the humanoid dies (using hum:ChangeState)
local addtools = false --puts all tools from backpack to character and lets you hold them after reanimation
local hedafterneck = false --disable aligns for head and enable after neck is removed
local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
local method = 0 --reanimation method
--methods:
--0 - breakJoints (takes [loadtime] seconds to laod)
--1 - limbs
--2 - limbs + anti respawn
--3 - limbs + breakJoints after [loadtime] seconds
--4 - remove humanoid + breakJoints
--5 - remove humanoid + limbs
local alignmode = 3 --AlignPosition mode
--modes:
--1 - AlignPosition rigidity enabled true
--2 - 2 AlignPositions rigidity enabled both true and false
--3 - AlignPosition rigidity enabled false

healthHide = healthHide and ((method == 0) or (method == 2) or (method == 000)) and gp(c, "Head", "BasePart")

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = v3(0, 0, 0)
local inf = math.huge

local c = lp.Character

if not (c and c.Parent) then
	return
end

c.Destroying:Connect(function()
	c = nil
end)

local function gp(parent, name, className)
	if typeof(parent) == "Instance" then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end

local function align(Part0, Part1)
	Part0.CustomPhysicalProperties = PhysicalProperties.new(0.0001, 0.0001, 0.0001, 0.0001, 0.0001)

	local att0 = Instance.new("Attachment", Part0)
	att0.Orientation = v3_0
	att0.Position = v3_0
	att0.Name = "att0_" .. Part0.Name
	local att1 = Instance.new("Attachment", Part1)
	att1.Orientation = v3_0
	att1.Position = v3_0
	att1.Name = "att1_" .. Part1.Name

	if (alignmode == 1) or (alignmode == 2) then
		local ape = Instance.new("AlignPosition", att0)
		ape.ApplyAtCenterOfMass = false
		ape.MaxForce = inf
		ape.MaxVelocity = inf
		ape.ReactionForceEnabled = false
		ape.Responsiveness = 200
		ape.Attachment1 = att1
		ape.Attachment0 = att0
		ape.Name = "AlignPositionRtrue"
		ape.RigidityEnabled = true
	end

	if (alignmode == 2) or (alignmode == 3) then
		local apd = Instance.new("AlignPosition", att0)
		apd.ApplyAtCenterOfMass = false
		apd.MaxForce = inf
		apd.MaxVelocity = inf
		apd.ReactionForceEnabled = false
		apd.Responsiveness = 200
		apd.Attachment1 = att1
		apd.Attachment0 = att0
		apd.Name = "AlignPositionRfalse"
		apd.RigidityEnabled = false
	end

	local ao = Instance.new("AlignOrientation", att0)
	ao.MaxAngularVelocity = inf
	ao.MaxTorque = inf
	ao.PrimaryAxisOnly = false
	ao.ReactionTorqueEnabled = false
	ao.Responsiveness = 200
	ao.Attachment1 = att1
	ao.Attachment0 = att0
	ao.RigidityEnabled = false

	if type(getNetlessVelocity) == "function" then
	    local realVelocity = v3_0
        local steppedcon = stepped:Connect(function()
            Part0.Velocity = realVelocity
        end)
        local heartbeatcon = heartbeat:Connect(function()
            realVelocity = Part0.Velocity
            Part0.Velocity = getNetlessVelocity(realVelocity)
        end)
        Part0.Destroying:Connect(function()
            Part0 = nil
            steppedcon:Disconnect()
            heartbeatcon:Disconnect()
        end)
    end
end

local function respawnrequest()
	local ccfr = ws.CurrentCamera.CFrame
	local c = lp.Character
	lp.Character = nil
	lp.Character = c
	local con = nil
	con = ws.CurrentCamera.Changed:Connect(function(prop)
	    if (prop ~= "Parent") and (prop ~= "CFrame") then
	        return
	    end
	    ws.CurrentCamera.CFrame = ccfr
	    con:Disconnect()
    end)
end

local destroyhum = (method == 4) or (method == 5)
local breakjoints = (method == 0) or (method == 4)
local antirespawn = (method == 0) or (method == 2) or (method == 3)

hatcollide = hatcollide and (method == 0)

addtools = addtools and gp(lp, "Backpack", "Backpack")

local fenv = getfenv()
local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.set_simulation_rad or fenv.setsimulationrad

if shp and (simradius == "shp") then
	spawn(function()
		while c and heartbeat:Wait() do
			shp(lp, "SimulationRadius", inf)
		end
	end)
elseif ssr and (simradius == "ssr") then
	spawn(function()
		while c and heartbeat:Wait() do
			ssr(inf)
		end
	end)
end

antiragdoll = antiragdoll and function(v)
	if v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
		v.Parent = nil
	end
end

if antiragdoll then
	for i, v in pairs(c:GetDescendants()) do
		antiragdoll(v)
	end
	c.DescendantAdded:Connect(antiragdoll)
end

if antirespawn then
	respawnrequest()
end

if method == 0 then
	wait(loadtime)
	if not c then
		return
	end
end

if discharscripts then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("LocalScript") then
			v.Disabled = true
		end
	end
elseif newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate and (not animate.Disabled) then
		animate.Disabled = true
	else
		newanimate = false
	end
end

if addtools then
	for i, v in pairs(addtools:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = c
		end
	end
end

pcall(function()
	settings().Physics.AllowSleep = false
	settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
end)

local OLDscripts = {}

for i, v in pairs(c:GetDescendants()) do
	if v.ClassName == "Script" then
		table.insert(OLDscripts, v)
	end
end

local scriptNames = {}

for i, v in pairs(c:GetDescendants()) do
	if v:IsA("BasePart") then
		local newName = tostring(i)
		local exists = true
		while exists do
			exists = false
			for i, v in pairs(OLDscripts) do
				if v.Name == newName then
					exists = true
				end
			end
			if exists then
				newName = newName .. "_"    
			end
		end
		table.insert(scriptNames, newName)
		Instance.new("Script", v).Name = newName
	end
end

c.Archivable = true
local hum = c:FindFirstChildOfClass("Humanoid")
if hum then
	for i, v in pairs(hum:GetPlayingAnimationTracks()) do
		v:Stop()
	end
end
local cl = c:Clone()
if hum and humState16 then
    hum:ChangeState(Enum.HumanoidStateType.Physics)
    if destroyhum then
        wait(1.6)
    end
end
if hum and hum.Parent and destroyhum then
    hum:Destroy()
end

if not c then
    return
end

local head = gp(c, "Head", "BasePart")
local torso = gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")
if hatcollide and c:FindFirstChildOfClass("Accessory") then
    local anything = c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script")
    if not (torso and root and anything) then
        return
    end
    torso:Destroy()
    root:Destroy()
    if shp then
        for i,v in pairs(c:GetChildren()) do
            if v:IsA("Accessory") then
                shp(v, "BackendAccoutrementState", 0)
            end 
        end
    end
    anything:Destroy()
    if head then
       head:Destroy()
    end
end

for i, v in pairs(cl:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
		v.Anchored = false
	end
end

local model = Instance.new("Model", c)
model.Name = model.ClassName

model.Destroying:Connect(function()
	model = nil
end)

for i, v in pairs(c:GetChildren()) do
	if v ~= model then
		if addtools and v:IsA("Tool") then
			for i1, v1 in pairs(v:GetDescendants()) do
				if v1 and v1.Parent and v1:IsA("BasePart") then
					local bv = Instance.new("BodyVelocity", v1)
					bv.Velocity = v3_0
					bv.MaxForce = v3(1000, 1000, 1000)
					bv.P = 1250
					bv.Name = "bv_" .. v.Name
				end
			end
		end
		v.Parent = model
	end
end

if breakjoints then
	model:BreakJoints()
else
	if head and torso then
		for i, v in pairs(model:GetDescendants()) do
			if v:IsA("Weld") or v:IsA("Snap") or v:IsA("Glue") or v:IsA("Motor") or v:IsA("Motor6D") then
				local save = false
				if (v.Part0 == torso) and (v.Part1 == head) then
					save = true
				end
				if (v.Part0 == head) and (v.Part1 == torso) then
					save = true
				end
				if save then
					if hedafterneck then
						hedafterneck = v
					end
				else
					v:Destroy()
				end
			end
		end
	end
	if method == 3 then
		spawn(function()
			wait(loadtime)
			if model then
				model:BreakJoints()
			end
		end)
	end
end

cl.Parent = c
for i, v in pairs(cl:GetChildren()) do
	v.Parent = c
end
cl:Destroy()

local modelDes = {}
for i, v in pairs(model:GetDescendants()) do
	if v:IsA("BasePart") then
		i = tostring(i)
		v.Destroying:Connect(function()
			modelDes[i] = nil
		end)
		modelDes[i] = v
	end
end
local modelcolcon = nil
local function modelcolf()
	if model then
		for i, v in pairs(modelDes) do
			v.CanCollide = false
		end
	else
		modelcolcon:Disconnect()
	end
end
modelcolcon = stepped:Connect(modelcolf)
modelcolf()

for i, scr in pairs(model:GetDescendants()) do
	if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
		local Part0 = scr.Parent
		if Part0:IsA("BasePart") then
			for i1, scr1 in pairs(c:GetDescendants()) do
				if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
					local Part1 = scr1.Parent
					if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
						align(Part0, Part1)
						break
					end
				end
			end
		end
	end
end

if (typeof(hedafterneck) == "Instance") and head then
	local aligns = {}
	local con = nil
	con = hedafterneck.Changed:Connect(function(prop)
	    if (prop == "Parent") and not hedafterneck.Parent then
	        con:Disconnect()
    		for i, v in pairs(aligns) do
    			v.Enabled = true
    		end
		end
	end)
	for i, v in pairs(head:GetDescendants()) do
		if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
			i = tostring(i)
			aligns[i] = v
			v.Destroying:Connect(function()
			    aligns[i] = nil
			end)
			v.Enabled = false
		end
	end
end

for i, v in pairs(c:GetDescendants()) do
	if v and v.Parent then
		if v.ClassName == "Script" then
			if table.find(scriptNames, v.Name) then
				v:Destroy()
			end
		elseif not v:IsDescendantOf(model) then
			if v:IsA("Decal") then
				v.Transparency = 1
			elseif v:IsA("ForceField") then
				v.Visible = false
			elseif v:IsA("Sound") then
				v.Playing = false
			elseif v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") then
				v.Enabled = false
			end
		end
	end
end

if newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate then
		animate.Disabled = false
	end
end

if addtools then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = addtools
		end
	end
end

local hum0 = model:FindFirstChildOfClass("Humanoid")
if hum0 then
    hum0.Destroying:Connect(function()
        hum0 = nil
    end)
end

local hum1 = c:FindFirstChildOfClass("Humanoid")
if hum1 then
    hum1.Destroying:Connect(function()
        hum1 = nil
    end)
end

if hum1 then
	ws.CurrentCamera.CameraSubject = hum1
	local camSubCon = nil
	local function camSubFunc()
		camSubCon:Disconnect()
		if c and hum1 then
			ws.CurrentCamera.CameraSubject = hum1
		end
	end
	camSubCon = renderstepped:Connect(camSubFunc)
	if hum0 then
		hum0.Changed:Connect(function(prop)
			if hum1 and (prop == "Jump") then
				hum1.Jump = hum0.Jump
			end
		end)
	else
		respawnrequest()
	end
end

local rb = Instance.new("BindableEvent", c)
rb.Event:Connect(function()
	rb:Destroy()
	sg:SetCore("ResetButtonCallback", true)
	if destroyhum then
		c:BreakJoints()
		return
	end
	if hum0 and (hum0.Health > 0) then
		model:BreakJoints()
		hum0.Health = 0
	end
	if antirespawn then
	    respawnrequest()
	end
end)
sg:SetCore("ResetButtonCallback", rb)

spawn(function()
	while c do
		if hum0 and hum1 then
			hum1.Jump = hum0.Jump
		end
		wait()
	end
	sg:SetCore("ResetButtonCallback", true)
end)

R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
if R15toR6 then
    local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
	if part then
	    local cfr = part.CFrame
		local R6parts = { 
			head = {
				Name = "Head",
				Size = v3(2, 1, 1),
				R15 = {
					Head = 0
				}
			},
			torso = {
				Name = "Torso",
				Size = v3(2, 2, 1),
				R15 = {
					UpperTorso = 0.2,
					LowerTorso = -100
				}
			},
			root = {
				Name = "HumanoidRootPart",
				Size = v3(2, 2, 1),
				R15 = {
					HumanoidRootPart = 0
				}
			},
			leftArm = {
				Name = "Left Arm",
				Size = v3(1, 2, 1),
				R15 = {
					LeftHand = -0.73,
					LeftLowerArm = -0.2,
					LeftUpperArm = 0.4
				}
			},
			rightArm = {
				Name = "Right Arm",
				Size = v3(1, 2, 1),
				R15 = {
					RightHand = -0.73,
					RightLowerArm = -0.2,
					RightUpperArm = 0.4
				}
			},
			leftLeg = {
				Name = "Left Leg",
				Size = v3(1, 2, 1),
				R15 = {
					LeftFoot = -0.73,
					LeftLowerLeg = -0.15,
					LeftUpperLeg = 0.6
				}
			},
			rightLeg = {
				Name = "Right Leg",
				Size = v3(1, 2, 1),
				R15 = {
					RightFoot = -0.73,
					RightLowerLeg = -0.15,
					RightUpperLeg = 0.6
				}
			}
		}
		for i, v in pairs(c:GetChildren()) do
			if v:IsA("BasePart") then
				for i1, v1 in pairs(v:GetChildren()) do
					if v1:IsA("Motor6D") then
						v1.Part0 = nil
					end
				end
			end
		end
		part.Archivable = true
		for i, v in pairs(R6parts) do
			local part = part:Clone()
			part:ClearAllChildren()
			part.Name = v.Name
			part.Size = v.Size
			part.CFrame = cfr
			part.Anchored = false
			part.Transparency = 1
			part.CanCollide = false
			for i1, v1 in pairs(v.R15) do
				local R15part = gp(c, i1, "BasePart")
				local att = gp(R15part, "att1_" .. i1, "Attachment")
				if R15part then
					local weld = Instance.new("Weld", R15part)
					weld.Name = "Weld_" .. i1
					weld.Part0 = part
					weld.Part1 = R15part
					weld.C0 = cf(0, v1, 0)
					weld.C1 = cf(0, 0, 0)
					R15part.Massless = true
					R15part.Name = "R15_" .. i1
					R15part.Parent = part
					if att then
						att.Parent = part
						att.Position = v3(0, v1, 0)
					end
				end
			end
			part.Parent = c
			R6parts[i] = part
		end
		local R6joints = {
			neck = {
				Parent = Scarf,
				Name = "Neck",
				Part0 = Scarf, --R6parts.torso
				Part1 = Scarf, --R6parts.head
				C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rootJoint = {
				Parent = R6parts.root,
				Name = "RootJoint" ,
				Part0 = R6parts.root,
				Part1 = R6parts.torso,
				C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rightShoulder = {
				Parent = R6parts.torso,
				Name = "Right Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightArm,
				C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftShoulder = {
				Parent = R6parts.torso,
				Name = "Left Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.leftArm,
				C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			},
			rightHip = {
				Parent = R6parts.torso,
				Name = "Right Hip",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightLeg,
				C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftHip = {
				Parent = R6parts.torso,
				Name = "Left Hip" ,
				Part0 = R6parts.torso,
				Part1 = R6parts.leftLeg,
				C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			}
		}
		for i, v in pairs(R6joints) do
			local joint = Instance.new("Motor6D")
			for prop, val in pairs(v) do
				joint[prop] = val
			end
			R6joints[i] = joint
		end
		hum1.RigType = Enum.HumanoidRigType.R6
		hum1.HipHeight = 0
	end
end



--find rig joints

local function fakemotor()
    return {C0=cf(), C1=cf()}
end

local torso = gp(c, "Torso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")

local neck = gp(torso, "Neck", "Motor6D")
neck = neck or fakemotor()

local rootJoint = gp(root, "RootJoint", "Motor6D")
rootJoint = rootJoint or fakemotor()

local leftShoulder = gp(torso, "Left Shoulder", "Motor6D")
leftShoulder = leftShoulder or fakemotor()

local rightShoulder = gp(torso, "Right Shoulder", "Motor6D")
rightShoulder = rightShoulder or fakemotor()

local leftHip = gp(torso, "Left Hip", "Motor6D")
leftHip = leftHip or fakemotor()

local rightHip = gp(torso, "Right Hip", "Motor6D")
rightHip = rightHip or fakemotor()

--120 fps

local fps = 0
local event = Instance.new("BindableEvent", c)
event.Name = "120 fps"
local floor = math.floor
fps = 1 / fps
local tf = 0
local con = nil
con = game:GetService("RunService").RenderStepped:Connect(function(s)
	if not c then
		con:Disconnect()
		return
	end
    --tf += s
	if tf >= fps then
		for i=1, floor(tf / fps) do
			event:Fire(c)
		end
		tf = 0
	end
end)
local event = event.Event

local hedrot = v3(0, 5, 0)

local uis = game:GetService("UserInputService")
local function isPressed(key)
    return (not uis:GetFocusedTextBox()) and uis:IsKeyDown(Enum.KeyCode[key])
end

local biggesthandle = nil
for i, v in pairs(c:GetChildren()) do
    if v:IsA("Accessory") and v.Name == "VANS_Umbrella" then
        local handle = gp(v, "Handle", "BasePart")
        if biggesthandle then
            if biggesthandle.Size.Magnitude < handle.Size.Magnitude then
                biggesthandle = Handle
            end
       else
            biggesthandle = gp(v, "Handle", "BasePart")
        end
    end
end

if not biggesthandle then
    return
end

local handle1 = gp(gp(model, biggesthandle.Parent.Name, "Accessory"), "Handle", "BasePart")
if not handle1 then
    return
end

handle1.Destroying:Connect(function()
    handle1 = nil
end)
biggesthandle.Destroying:Connect(function()
    biggesthandle = nil
end)

biggesthandle:BreakJoints()
biggesthandle.Anchored = true

for i, v in pairs(handle1:GetDescendants()) do
    if v:IsA("AlignOrientation") then
        v.Enabled = false
   end
end

local mouse = lp:GetMouse()
local fling = false
mouse.Button1Down:Connect(function()
    fling = true
end)
mouse.Button1Up:Connect(function()
    fling = false
end)
local function doForSignal(signal, vel)
    spawn(function()
        while signal:Wait() and c and handle1 and biggesthandle do
            if fling and mouse.Target then
                biggesthandle.Position = mouse.Hit.Position
            end
            handle1.RotVelocity = vel
        end
    end)
end
doForSignal(stepped, v3(10000, 10000, 10000))
doForSignal(renderstepped, v3(10000, 10000, 10000))
doForSignal(heartbeat, v3(200000000000000, 200000000000000, 200000000000000)) --https://web.roblox.com/catalog/63690008/Pal-Hair

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = Vector3.zero
local inf = math.huge

local cplayer = lp.Character

local v3 = Vector3.new

local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
        for i, v in pairs(parent:GetChildren()) do
            if (v.Name == name) and v:IsA(className) then
                return v
            end
        end
    end
    return nil
end

local hat2 = gp(cplayer, "SeeMonkey", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Torso"]
att2.Position = Vector3.new(0, -0.09, 0)
att2.Rotation = Vector3.new(90, 0, 0)

local hat2 = gp(cplayer, "Pink Hair", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Left Arm"]
att2.Position = Vector3.new(-0.09, -0.09, 0)
att2.Rotation = Vector3.new(90, 0, 0)

local hat2 = gp(cplayer, "Kate Hair", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Arm"]
att2.Position = Vector3.new(0.09, -0.09, 0)
att2.Rotation = Vector3.new(90, 0, 0) --LavanderHair

local hat2 = gp(cplayer, "LavanderHair", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Leg"]
att2.Position = Vector3.new(-0.1, 0.25, 0) --Robloxclassicred
att2.Rotation = Vector3.new(90, 0, 0)

local hat2 = gp(cplayer, "Robloxclassicred", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Left Leg"]
att2.Position = Vector3.new(0.1, 0.25, 0) 
att2.Rotation = Vector3.new(90, 0, 0)

_G.loop = true
local player = game.Players.LocalPlayer
local char = player.Character
local Align = function(Part0, Part1,Mesh)
    local Aligns = {
        AlignOrientation = Instance.new("AlignOrientation", Part0),
        AlignPosition = Instance.new("AlignPosition", Part0)
    }
    
    local Attachments = {
        Attach0 = Instance.new("Attachment", Part0),
        Attach1 = Instance.new("Attachment", Part1)
    }
    local m = Part0:FindFirstChildOfClass('SpecialMesh')--This will get the first "SpecialMesh" it finds if it does not find any, then it will return nil
    if Mesh and m then --If Mesh is set to true and it finds a mesh it will destroy it
        m:Destroy()
    end
    Part0:BreakJoints()
    Aligns.AlignOrientation.Attachment0 = Attachments.Attach0
    Aligns.AlignOrientation.Attachment1 = Attachments.Attach1
    Aligns.AlignOrientation.Responsiveness = math.huge
    Aligns.AlignOrientation.RigidityEnabled = true
    
    Aligns.AlignPosition.Attachment0 = Attachments.Attach0
    Aligns.AlignPosition.Attachment1 = Attachments.Attach1
    Aligns.AlignPosition.Responsiveness = math.huge
    Aligns.AlignPosition.RigidityEnabled = true
        Aligns.AlignPosition.MaxForce = 999999999
        spawn(function()
            while _G.loop do 
                local mag = (Part0.Position - (Part1.CFrame*Attachments.Attach0.CFrame:Inverse()).p).magnitude--magnitude can get the distance between two cframe or position
                if mag >= 5 then 
                Part0.CFrame = Part1.CFrame*Attachments.Attach0.CFrame:Inverse()
                end
                Part0.Velocity = Vector3.new(0,35,0)
                game['Run Service'].Heartbeat:wait()
                end
        end)
 return {Attachments.Attach0, Attachments, Aligns}
        
end 
local hat = Align(char['VANS_Umbrella'].Handle,char['HumanoidRootPart'],false)
local cf = char['HumanoidRootPart'].CFrame*CFrame.new(0,-10,-0)*CFrame.Angles(math.rad(0),math.rad(0),0)
hat[1].CFrame = cf:Inverse() * char['HumanoidRootPart'].CFrame
spawn(function()
    char.AncestryChanged:wait()--if you respawn, it will stop the  loop to avoid lag of using it over and over
    _G.loop = false 
end)
for i,v in pairs (char:GetChildren()) do
	if v:IsA("Accessory") then
		v.Handle.Massless = true
		v.Handle.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
	end
end

local script = game:GetObjects("rbxassetid://13128823145")[1]
script.Parent = game:GetService("Players").LocalPlayer

--require(3747589551)()
-- nebula's ezconvert
--[[
PUT YOUR SCRIPTS BELOW HERE VVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVV	
]]
wait(1/60)
Player = game:service'Players'.localPlayer
Character = Player.Character
local LeftArm = Character["Left Arm"]
local RightArm = Character["Right Arm"]
local LeftLeg = Character["Left Leg"]
Humanoid = Character.Humanoid
Mouse = Player:GetMouse()
local RightLeg = Character["Right Leg"]
local Head = Character.Head
local Torso = Character.Torso
local RootPart = Character.HumanoidRootPart
local RootJoint = RootPart.RootJoint
Neck = Torso["Neck"]
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local HOLD = false
local SINE = 0
Animation_Speed = 5.5
local killing = false
local CHANGE = 2 / Animation_Speed
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
vt = Vector3.new

Debris = game:GetService("Debris")
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 0.75, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.75, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.75, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 0
local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = false
local COMBO = 1
local rungo = false
local HitVictims = {}
local Rooted = false
local KEYHOLD = false
local useweapon = false
local OTHERWORLD = false
local cooldownn = false
--weapon use

local gloveuse = true
local knifeuse = false
local dienow = false
local Tapped = false
local Time = 0.3
Frame_Speed = 1 / 60
local Effects = IT("Folder", Character)
Effects.Name = "Effects"
local msuic = Instance.new("Sound",RootPart)
local runsou = Instance.new("Sound",RootPart)
local hhh = false
local what = true

if Character:FindFirstChild("Animate") then
	Character:FindFirstChild("Animate"):remove()
end

if Humanoid:FindFirstChild("Animator") then
	Humanoid:FindFirstChild("Animator"):remove()
end


	if game:GetService("SoundService"):FindFirstChild("friskeffect") then
          game:GetService("SoundService"):FindFirstChild("friskeffect"):remove()
	end
	
		if game:GetService("SoundService"):FindFirstChild("friskweapons") then
          game:GetService("SoundService"):FindFirstChild("friskweapons"):remove()
	end
	
	
	if game:GetService("SoundService"):FindFirstChild("ClientModules") then
          game:GetService("SoundService"):FindFirstChild("ClientModules"):remove()
	end
	
		if game:GetService("SoundService"):FindFirstChild("remotesfornoob") then
          game:GetService("SoundService"):FindFirstChild("remotesfornoob"):remove()
	end
	
	local remotes = script:FindFirstChild("remotesfornoob")
	local clientmodu = script:FindFirstChild("ClientModules")

	if game:GetService("SoundService"):FindFirstChild("ClientModules") == nil then
        clientmodu.Parent = game:GetService("SoundService")
	end
	
		if game:GetService("SoundService"):FindFirstChild("remotesfornoob") == nil then
        remotes.Parent = game:GetService("SoundService")
	end
	

local kepper = Instance.new("Folder", game:GetService("SoundService"))
kepper.Name = "friskeffect"

local weponss = Instance.new("Folder", game:GetService("SoundService"))
weponss.Name = "friskweapons"

local starr = script:FindFirstChild("HelloDatBurpSavePoint")

	if game:GetService("SoundService"):FindFirstChild("friskeffect"):FindFirstChild("HelloDatBurpSavePoint") == nil then
          starr.Parent = game:GetService("SoundService"):FindFirstChild("friskeffect")
	end


local LHE = script:FindFirstChild("LightHitEffect2")

	if game:GetService("SoundService"):FindFirstChild("friskeffect"):FindFirstChild("LightHitEffect2") == nil then
          LHE.Parent = game:GetService("SoundService"):FindFirstChild("friskeffect")
	end

local wwe = script:FindFirstChild("Wind")

	if game:GetService("SoundService"):FindFirstChild("friskeffect"):FindFirstChild("Wind") == nil then
          wwe.Parent = game:GetService("SoundService"):FindFirstChild("friskeffect")
end

	local HHE = script:FindFirstChild("HeavyHitEffect")

	if game:GetService("SoundService"):FindFirstChild("friskeffect"):FindFirstChild("HeavyHitEffect") == nil then
          HHE.Parent = game:GetService("SoundService"):FindFirstChild("friskeffect")
	end


	local soll = script:FindFirstChild("Soul")

	if game:GetService("SoundService"):FindFirstChild("friskeffect"):FindFirstChild("Soul") == nil then
          soll.Parent = game:GetService("SoundService"):FindFirstChild("friskeffect")
	end
		
	
local MM = {RN = math.random, CS = math.cos, AS = math.acos, RD = math.rad, SN = math.sin}
local CC = {NW = CFrame.new, AA = CFrame.Angles}
local CLR = {B = BrickColor.new, T = Color3.new, RGB = Color3.fromRGB}
local VV = Vector3.new

local screengui = Instance.new("ScreenGui", Player:findFirstChildOfClass("PlayerGui"))
local viewport = Instance.new("ViewportFrame", screengui)
viewport.BackgroundTransparency = 0
viewport.ImageTransparency = 0


local BloodSounds = {
	3781479909,
	150315649,
	3737268126,
	3739335394
}

--//=================================\\
--|| SAZERENOS' ARTIFICIAL HEARTBEAT
--\\=================================//

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"

script:WaitForChild("ArtificialHB")

frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
ArtificialHB:Fire()

game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			if ArtificialHB ~= nil then
			ArtificialHB:Fire()
			end
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				if ArtificialHB ~= nil then
				ArtificialHB:Fire()
				end
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)
 

function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
    return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end
 
function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end



function QuaternionFromCFrame(cf)
    local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
    local trace = m00 + m11 + m22
    if trace > 0 then
        local s = math.sqrt(1 + trace)
        local recip = 0.5 / s
        return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
    else
        local i = 0
        if m11 > m00 then
            i = 1
        end
        if m22 > (i == 0 and m00 or m11) then
            i = 2
        end
        if i == 0 then
            local s = math.sqrt(m00 - m11 - m22 + 1)
            local recip = 0.5 / s
            return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
        elseif i == 1 then
            local s = math.sqrt(m11 - m22 - m00 + 1)
            local recip = 0.5 / s
            return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
        elseif i == 2 then
            local s = math.sqrt(m22 - m00 - m11 + 1)
            local recip = 0.5 / s return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
        end
    end
end
 
function QuaternionToCFrame(px, py, pz, x, y, z, w)
    local xs, ys, zs = x + x, y + y, z + z
    local wx, wy, wz = w * xs, w * ys, w * zs
    local xx = x * xs
    local xy = x * ys
    local xz = x * zs
    local yy = y * ys
    local yz = y * zs
    local zz = z * zs
    return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end

function SHAKECAM(POSITION,RANGE,INTENSITY,TIME)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				local TORSO = CHILD:FindFirstChild("Torso") or CHILD:FindFirstChild("UpperTorso")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						local CAMSHAKER = script.CamShake:Clone()
						CAMSHAKER.Shake.Value = INTENSITY
						CAMSHAKER.Timer.Value = TIME
						CAMSHAKER.Parent = CHILD
						CAMSHAKER.Disabled = false
					end
				end
			end
		end
	end
end
 
function QuaternionSlerp(a, b, t)
    local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
    local startInterp, finishInterp;
    if cosTheta >= 0.0001 then
        if (1 - cosTheta) > 0.0001 then
            local theta = ACOS(cosTheta)
            local invSinTheta = 1 / SIN(theta)
            startInterp = SIN((1 - t) * theta) * invSinTheta
            finishInterp = SIN(t * theta) * invSinTheta
        else
            startInterp = 1 - t
            finishInterp = t
        end
    else
        if (1 + cosTheta) > 0.0001 then
            local theta = ACOS(-cosTheta)
            local invSinTheta = 1 / SIN(theta)
            startInterp = SIN((t - 1) * theta) * invSinTheta
            finishInterp = SIN(t * theta) * invSinTheta
        else
            startInterp = t - 1
            finishInterp = t
        end
    end
    return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
 
function Clerp(a, b, t)
    local qa = {QuaternionFromCFrame(a)}
    local qb = {QuaternionFromCFrame(b)}
    local ax, ay, az = a.x, a.y, a.z
    local bx, by, bz = b.x, b.y, b.z
    local _t = 1 - t
    return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
 

New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end

local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
    local NEWSOUND = nil
    coroutine.resume(coroutine.create(function()
        NEWSOUND = S:Clone()
        NEWSOUND.Parent = PARENT
        NEWSOUND.Volume = VOLUME
        NEWSOUND.Pitch = PITCH
        NEWSOUND.SoundId = "http://www.roblox.com/asset/?id="..ID
        NEWSOUND:play()
        if DOESLOOP == true then
            NEWSOUND.Looped = true
        else
            repeat wait(1) until NEWSOUND.Playing == false
            NEWSOUND:remove()
        end
    end))
    return NEWSOUND
end

function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end

function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
    local NEWPART = IT("Part")
    NEWPART.formFactor = FORMFACTOR
    NEWPART.Reflectance = REFLECTANCE
    NEWPART.Transparency = TRANSPARENCY
    NEWPART.CanCollide = false
    NEWPART.Locked = true
    NEWPART.Anchored = true
    if ANCHOR == false then
        NEWPART.Anchored = false
    end
    NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
    NEWPART.Name = NAME
    NEWPART.Size = SIZE
    NEWPART.Position = Torso.Position
    NEWPART.Material = MATERIAL
    NEWPART:BreakJoints()
    NEWPART.Parent = PARENT
    return NEWPART
end

function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
    local NEWMESH = IT(MESH)
    if MESH == "SpecialMesh" then
        NEWMESH.MeshType = MESHTYPE
        if MESHID ~= "nil" and MESHID ~= "" then
            NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
        end
        if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
            NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
        end
    end
    NEWMESH.Offset = OFFSET or VT(0, 0, 0)
    NEWMESH.Scale = SCALE
    NEWMESH.Parent = PARENT
    return NEWMESH
end
 
function Kill(Humanoid)
	spawn(function()
	if Humanoid:FindFirstChild("Killed") == nil then
		local Mark = IT("Folder",Humanoid)
		Mark.Name = "Killed"
        local TORSO = Humanoid.Parent:FindFirstChild("Torso") or Humanoid.Parent:FindFirstChild("UpperTorso") or Humanoid.Parent:FindFirstChild("HumanoidRootPart")
    	for i,v in pairs(Humanoid:GetChildren()) do
    	    if v.ClassName == "Script" or v.ClassName == "LocalScript" then
            	v:destroy()
        	end
        	for i,p in pairs(v:GetChildren()) do
            	if p.ClassName == "Weld" or p.ClassName == "Motor6D" or p.ClassName == "BodyVelocity" then
                	p:destroy()
            	end
        	end
    	end
    	for i,v in next, Humanoid:children() do
        	if v:IsA"LocalScript" or v:IsA"Script" or v:IsA"ModuleScript" then
            	v.Disabled = true
            	wait()
            	v:destroy()
        	end
    	end
spawn(function()
						TORSO.Archivable = false TORSO.Anchored = false
						local FLIGHTFORCE = Instance.new("BodyPosition", TORSO)
						FLIGHTFORCE.D = 215
						FLIGHTFORCE.P = 200
						FLIGHTFORCE.maxForce = VV(40000, 40000, 40000)
						FLIGHTFORCE.position = RootPart.CFrame * Vector3.new(0,0.5,-4)
Humanoid.Health = Humanoid.Health + -0
spawn(function()
		TORSO.CFrame = TORSO.CFrame * CC.AA(MM.RD(MM.RN(-30/1.25,30/1.25)),MM.RD(MM.RN(-30/1.25,30/1.25)),MM.RD(MM.RN(-30/1.25,30/1.25)))
		TORSO.RotVelocity = VV(MM.RD(-10*1.75,10*1.75),MM.RD(-10*1.75,10*1.75),MM.RD(-10*1.75,10*1.75))
		end)
		wait(1)
		FLIGHTFORCE:Destroy()
	end)
spawn(function()
local exp = Instance.new("Sound", TORSO)
exp.PlaybackSpeed = 0.5
exp.Volume = 100
exp.SoundId = "rbxassetid://3201554385"
exp:Play()
wait(3)
exp:Destroy()
end)
		spawn(function()
					for Index, Player in next, game:GetService("Players"):GetPlayers() do
		local LH2 = LHE:Clone()
			local LHss = LH2:FindFirstChild("scriptt")
local LHno = LH2:FindFirstChild("ll")
	local hitti = LH2:FindFirstChild("BallEffect")
	LH2:SetPrimaryPartCFrame(TORSO.CFrame * CFrame.Angles(MRANDOM(-30,130), MRANDOM(-30,130), MRANDOM(-30,130)))
		LH2.Parent = Player:WaitForChild("PlayerGui")
	LHss.Disabled = false
LHno.Disabled = false
		game:GetService("Debris"):AddItem(LHss)
	end
		end)
		spawn(function()
			wait(0.02)
		
				Mark:destroy()
				end)
end
end)

end

function Killpunch(Humanoid)
	spawn(function()
	if Humanoid:FindFirstChild("Killed") == nil then
		local Mark = IT("Folder",Humanoid)
		Mark.Name = "Killed"
        local TORSO = Humanoid.Parent:FindFirstChild("Torso") or Humanoid.Parent:FindFirstChild("UpperTorso") or Humanoid.Parent:FindFirstChild("HumanoidRootPart")
    	for i,v in pairs(Humanoid:GetChildren()) do
    	    if v.ClassName == "Script" or v.ClassName == "LocalScript" then
            	v:destroy()
        	end
        	for i,p in pairs(v:GetChildren()) do
            	if p.ClassName == "Weld" or p.ClassName == "Motor6D" or p.ClassName == "BodyVelocity" then
                	p:destroy()
            	end
        	end
    	end
    	for i,v in next, Humanoid:children() do
        	if v:IsA"LocalScript" or v:IsA"Script" or v:IsA"ModuleScript" then
            	v.Disabled = true
            	wait()
            	v:destroy()
        	end
    	end
spawn(function()
						TORSO.Archivable = false TORSO.Anchored = false
						local FLIGHTFORCE = Instance.new("BodyPosition", TORSO)
						FLIGHTFORCE.D = 215
						FLIGHTFORCE.P = 200
						FLIGHTFORCE.maxForce = VV(40000, 40000, 40000)
						FLIGHTFORCE.position = RootPart.CFrame * Vector3.new(0,0.5,-4)
Humanoid.Health = Humanoid.Health + -0
spawn(function()
		TORSO.CFrame = TORSO.CFrame * CC.AA(MM.RD(MM.RN(-30/1.25,30/1.25)),MM.RD(MM.RN(-30/1.25,30/1.25)),MM.RD(MM.RN(-30/1.25,30/1.25)))
		TORSO.RotVelocity = VV(MM.RD(-10*1.75,10*1.75),MM.RD(-10*1.75,10*1.75),MM.RD(-10*1.75,10*1.75))
		end)
		wait(1)
		FLIGHTFORCE:Destroy()
	end)
spawn(function()
local exp = Instance.new("Sound", TORSO)
exp.PlaybackSpeed = 1
exp.Volume = 100
exp.SoundId = "rbxassetid://3201554385"
exp:Play()
wait(3)
exp:Destroy()
end)
		spawn(function()
					for Index, Player in next, game:GetService("Players"):GetPlayers() do
		local LH2 = LHE:Clone()
			local LHss = LH2:FindFirstChild("scriptt")
local LHno = LH2:FindFirstChild("ll")
	local hitti = LH2:FindFirstChild("BallEffect")
	LH2:SetPrimaryPartCFrame(TORSO.CFrame * CFrame.Angles(MRANDOM(-30,130), MRANDOM(-30,130), MRANDOM(-30,130)))
		LH2.Parent = Player:WaitForChild("PlayerGui")
	LHss.Disabled = false
LHno.Disabled = false
		game:GetService("Debris"):AddItem(LHss)
	end
		end)
		spawn(function()
			wait(0.02)
		
				Mark:destroy()
				end)
end
end)

end


function Killcrit(Humanoid)
	spawn(function()
	if Humanoid:FindFirstChild("Killed") == nil then
		local Mark = IT("Folder",Humanoid)
		Mark.Name = "Killed"
        local TORSO = Humanoid.Parent:FindFirstChild("Torso") or Humanoid.Parent:FindFirstChild("UpperTorso") or Humanoid.Parent:FindFirstChild("HumanoidRootPart")
    	for i,v in pairs(Humanoid:GetChildren()) do
    	    if v.ClassName == "Script" or v.ClassName == "LocalScript" then
            	v:destroy()
        	end
        	for i,p in pairs(v:GetChildren()) do
            	if p.ClassName == "Weld" or p.ClassName == "Motor6D" or p.ClassName == "BodyVelocity" then
                	p:destroy()
            	end
        	end
    	end
    	for i,v in next, Humanoid:children() do
        	if v:IsA"LocalScript" or v:IsA"Script" or v:IsA"ModuleScript" then
            	v.Disabled = true
            	wait()
            	v:destroy()
        	end
    	end
spawn(function()
						TORSO.Archivable = false TORSO.Anchored = false
						local FLIGHTFORCE = Instance.new("BodyPosition", TORSO)
						FLIGHTFORCE.D = 215
						FLIGHTFORCE.P = 200
						FLIGHTFORCE.maxForce = VV(40000, 40000, 40000)
						FLIGHTFORCE.position = RootPart.CFrame * Vector3.new(0,0.5,-4)
Humanoid.Health = Humanoid.Health + -0
spawn(function()
		TORSO.CFrame = TORSO.CFrame * CC.AA(MM.RD(MM.RN(-30/1.25,30/1.25)),MM.RD(MM.RN(-30/1.25,30/1.25)),MM.RD(MM.RN(-30/1.25,30/1.25)))
		TORSO.RotVelocity = VV(MM.RD(-10*1.75,10*1.75),MM.RD(-10*1.75,10*1.75),MM.RD(-10*1.75,10*1.75))
		end)
		wait(1)
		FLIGHTFORCE:Destroy()
	end)
	
spawn(function()
local exp = Instance.new("Sound", TORSO)
local dis = Instance.new("DistortionSoundEffect", exp)
dis.Name = "bypassdis"
spawn(function()
	while true do Swait()
if exp:FindFirstChild("bypassdis") == nil then
	local dis = Instance.new("DistortionSoundEffect", exp)
dis.Name = "bypassdis"
dis.Enabled = true
end
end
end)
local EchoSoundEffect1 = Instance.new("EchoSoundEffect")
EchoSoundEffect1.Parent = exp
EchoSoundEffect1.Priority = 111
EchoSoundEffect1.Delay = 0.0099999997764826
EchoSoundEffect1.DryLevel = 10
EchoSoundEffect1.Feedback = 0.10000000149012
EchoSoundEffect1.WetLevel = 10
dis.Enabled = true
exp.PlaybackSpeed = 0.5
exp.Volume = 100
exp.SoundId = "rbxassetid://3201554385"
exp:Play()
wait(3)
exp:Destroy()
		end)
		
		spawn(function()
					for Index, Player in next, game:GetService("Players"):GetPlayers() do
		local LH2 = HHE:Clone()
			local LHss = LH2:FindFirstChild("scriptt")
local LHno = LH2:FindFirstChild("ll")
	local hitti = LH2:FindFirstChild("BallEffect")
	LH2:SetPrimaryPartCFrame(TORSO.CFrame * CFrame.Angles(MRANDOM(-30,130), MRANDOM(-30,130), MRANDOM(-30,130)))
		LH2.Parent = Player:WaitForChild("PlayerGui")
	LHss.Disabled = false
LHno.Disabled = false
		game:GetService("Debris"):AddItem(LHss)
	end
		end)
		spawn(function()
			wait(0.02)
		
				Mark:destroy()
				end)
end
end)

end

 
function Killlast(Humanoid)
	spawn(function()
	if Humanoid:FindFirstChild("Killed") == nil then
		local Mark = IT("Folder",Humanoid)
		Mark.Name = "Killed"
        local TORSO = Humanoid.Parent:FindFirstChild("Torso") or Humanoid.Parent:FindFirstChild("UpperTorso") 
    	for i,v in pairs(Humanoid:GetChildren()) do
    	    if v.ClassName == "Script" or v.ClassName == "LocalScript" then
            	v:destroy()
        	end
        	for i,p in pairs(v:GetChildren()) do
            	if p.ClassName == "Weld" or p.ClassName == "Motor6D" or p.ClassName == "BodyVelocity" then
                	p:destroy()
            	end
        	end
    	end
    	for i,v in next, Humanoid:children() do
        	if v:IsA"LocalScript" or v:IsA"Script" or v:IsA"ModuleScript" then
            	v.Disabled = true
            	wait()
            	v:destroy()
        	end
    	end

spawn(function()
local exp = Instance.new("Sound", TORSO)
local dis = Instance.new("DistortionSoundEffect", exp)
dis.Name = "bypassdis"
spawn(function()
	while true do Swait()
if exp:FindFirstChild("bypassdis") == nil then
	local dis = Instance.new("DistortionSoundEffect", exp)
dis.Name = "bypassdis"
dis.Enabled = true
end
end
end)
local EchoSoundEffect1 = Instance.new("EchoSoundEffect")
EchoSoundEffect1.Parent = exp
EchoSoundEffect1.Priority = 111
EchoSoundEffect1.Delay = 0.0099999997764826
EchoSoundEffect1.DryLevel = 10
EchoSoundEffect1.Feedback = 0.10000000149012
EchoSoundEffect1.WetLevel = 10
dis.Enabled = true
exp.PlaybackSpeed = 0.5
exp.Volume = 100
exp.SoundId = "rbxassetid://3201554385"
exp:Play()
wait(3)
exp:Destroy()
		end)
		spawn(function()


		local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1000000000, 1000000000, 1000000000)
		bv.velocity = CF(Torso.Position, TORSO.Position).lookVector * 200
		bv.Parent = TORSO
		Debris:AddItem(bv, 0.05)


	
		end)
		spawn(function()
					for Index, Player in next, game:GetService("Players"):GetPlayers() do
		local LH2 = HHE:Clone()
			local LHss = LH2:FindFirstChild("scriptt")
local LHno = LH2:FindFirstChild("ll")
	local hitti = LH2:FindFirstChild("BallEffect")
	LH2:SetPrimaryPartCFrame(TORSO.CFrame * CFrame.Angles(MRANDOM(-30,130), MRANDOM(-30,130), MRANDOM(-30,130)))
		LH2.Parent = Player:WaitForChild("PlayerGui")
	LHss.Disabled = false
LHno.Disabled = false
		game:GetService("Debris"):AddItem(LHss)
	end
		end)
				spawn(function()
			wait(0.21)
		
				Humanoid.Parent:BreakJoints()
				end)
		spawn(function()
			wait(0.02)
		
				Mark:destroy()
				end)
end
end)
end

function Killbam(Humanoid)
	spawn(function()
	if Humanoid:FindFirstChild("Killed") == nil then
		local Mark = IT("Folder",Humanoid)
		Mark.Name = "Killed"
        local TORSO = Humanoid.Parent:FindFirstChild("Torso") or Humanoid.Parent:FindFirstChild("UpperTorso") 
    	for i,v in pairs(Humanoid:GetChildren()) do
    	    if v.ClassName == "Script" or v.ClassName == "LocalScript" then
            	v:destroy()
        	end
        	for i,p in pairs(v:GetChildren()) do
            	if p.ClassName == "Weld" or p.ClassName == "Motor6D" or p.ClassName == "BodyVelocity" then
                	p:destroy()
            	end
        	end
    	end
    	for i,v in next, Humanoid:children() do
        	if v:IsA"LocalScript" or v:IsA"Script" or v:IsA"ModuleScript" then
            	v.Disabled = true
            	wait()
            	v:destroy()
        	end
    	end

spawn(function()
local exp = Instance.new("Sound", TORSO)

exp.PlaybackSpeed = 0.5
exp.Volume = 100
exp.SoundId = "rbxassetid://3201554385"
exp:Play()
wait(3)
exp:Destroy()
		end)
		spawn(function()


		local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1000000000, 1000000000, 1000000000)
		bv.velocity = CF(Torso.Position, TORSO.Position).lookVector * 100
		bv.Parent = TORSO
		Debris:AddItem(bv, 0.05)


	
		end)
		spawn(function()
					for Index, Player in next, game:GetService("Players"):GetPlayers() do
		local LH2 = HHE:Clone()
			local LHss = LH2:FindFirstChild("scriptt")
local LHno = LH2:FindFirstChild("ll")
	local hitti = LH2:FindFirstChild("BallEffect")
	LH2:SetPrimaryPartCFrame(TORSO.CFrame * CFrame.Angles(MRANDOM(-30,130), MRANDOM(-30,130), MRANDOM(-30,130)))
		LH2.Parent = Player:WaitForChild("PlayerGui")
	LHss.Disabled = false
LHno.Disabled = false
		game:GetService("Debris"):AddItem(LHss)
	end
			end)
			
					spawn(function()
		local LH2 = wwe:Clone()
			local LHss = LH2:FindFirstChild("scriptt")
	LH2:SetPrimaryPartCFrame(RootPart.CFrame)
		LH2.Parent = workspace
	LHss.Disabled = false
		game:GetService("Debris"):AddItem(LHss)
			end)
			
				spawn(function()
			wait(0.21)
		
				Humanoid.Health = Humanoid.Health + -0
			end)
			
		spawn(function()
			wait(0.02)
		
				Mark:destroy()
				end)
end
end)
end

		
function AoE(POSITION,RANGE)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				for _, c in pairs(CHILD:GetChildren()) do
					if c:IsA("BasePart") then
						if (c.Position - POSITION).Magnitude <= RANGE+c.Size.Magnitude then
							Kill(HUM)
						end
					end
				end
			end
		end
	end
end

function AoEpunch(POSITION,RANGE)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				for _, c in pairs(CHILD:GetChildren()) do
					if c:IsA("BasePart") then
						if (c.Position - POSITION).Magnitude <= RANGE+c.Size.Magnitude then
							Killpunch(HUM)
						end
					end
				end
			end
		end
	end
end


function AoEcrit(POSITION,RANGE)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				for _, c in pairs(CHILD:GetChildren()) do
					if c:IsA("BasePart") then
						if (c.Position - POSITION).Magnitude <= RANGE+c.Size.Magnitude then
							Killcrit(HUM)
						end
					end
				end
			end
		end
	end
end


function AoElast(POSITION,RANGE)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				for _, c in pairs(CHILD:GetChildren()) do
					if c:IsA("BasePart") then
						if (c.Position - POSITION).Magnitude <= RANGE+c.Size.Magnitude then
							Killlast(HUM)
						end
					end
				end
			end
		end
	end
end

function AoEbam(POSITION,RANGE)
	local CHILDREN = workspace:GetDescendants()
	for index, CHILD in pairs(CHILDREN) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Humanoid")
			if HUM then
				for _, c in pairs(CHILD:GetChildren()) do
					if c:IsA("BasePart") then
						if (c.Position - POSITION).Magnitude <= RANGE+c.Size.Magnitude then
							Killbam(HUM)
						end
					end
				end
			end
		end
	end
end

--appearance
local leftg = script.LeftGlove
leftg.Parent = nil
local rightg = script.RightGlove
rightg.Parent = nil
local gloveleft = leftg:Clone()
local gloveright = rightg:Clone()
gloveleft.Parent = Character
gloveright.Parent = Character
local GL = gloveleft.Base
local GR = gloveright.Base

for v2, v3 in pairs(gloveleft:GetChildren()) do
	if v3.ClassName == "Part" and v3.ClassName == "MeshPart" then
		v3.Anchored = false
		end
end

for v2, v3 in pairs(gloveright:GetChildren()) do
	if v3.ClassName == "Part" and v3.ClassName == "MeshPart" then
		v3.Anchored = false
	end
end

local Weldshead = Instance.new("Weld")
Weldshead.Parent = GR
Weldshead.Part0 = GR
Weldshead.Part1 = RightArm
Weldshead.C0 = CFrame.new(0,0,0)*CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))


local Weldshead = Instance.new("Weld")
Weldshead.Parent = GL
Weldshead.Part0 = GL
Weldshead.Part1 = LeftArm
Weldshead.C0 = CFrame.new(0,0,0)*CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

function barrage()
	local stopnow = false
	spawn(function()
	ATTACK = true
	Rooted = true
		    for i=0, 0.5, 0.1 / Animation_Speed do
        Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 1, -0.1) * ANGLES(RAD(10), RAD(-5), RAD(-80)), 0.4 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 -0.30) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.4 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.2-0.30, -0.1, 0.3) * ANGLES(RAD(110), RAD(10), RAD(60)) * RIGHTSHOULDERC0, 0.4 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.2+0.30, 0, 0) * ANGLES(RAD(60), RAD(10), RAD(-50)) * LEFTSHOULDERC0, 0.25 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1-0.10, -1+0.40, -0.2) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-10), RAD(-10), RAD(-10)), 0.4/ Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -1+0.40, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-15), RAD(20), RAD(0)), 0.4 / Animation_Speed)
	    end
	
		for i=0, 0.1, 0.1 / Animation_Speed do
		Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(7), RAD(90)), 1.8 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, -0.30) * ANGLES(RAD(-9), RAD(-7), RAD(-60)), 1.8 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 -0.30, 0.4, 0) * ANGLES(RAD(155), RAD(0), RAD(80)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 +0.30, 0.1, 0) * ANGLES(RAD(60), RAD(0), RAD(-80)) * LEFTSHOULDERC0, 2 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1.7-0.10, -1 +0.40, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(-60), RAD(-5)), 1.8 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -1 +0.40, -0.5) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-15), RAD(25), RAD(0)), 1.8 / Animation_Speed)
	end
AoEcrit(RootPart.CFrame * Vector3.new(0,0.5,-4),3.5)
		for i=0, 0.1, 0.1 / Animation_Speed do
		Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(7), RAD(90)), 1.8 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, -0.30) * ANGLES(RAD(-9), RAD(-7), RAD(-60)), 1.8 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 -0.30, 0.4, 0) * ANGLES(RAD(155), RAD(0), RAD(80)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 +0.30, 0.1, 0) * ANGLES(RAD(60), RAD(0), RAD(-80)) * LEFTSHOULDERC0, 2 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1.7-0.10, -1 +0.40, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(-60), RAD(-5)), 1.8 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -1 +0.40, -0.5) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-15), RAD(25), RAD(0)), 1.8 / Animation_Speed)
	end
		for i=0, 0.1, 0.1 / Animation_Speed do
		Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(7), RAD(90)), 1.8 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, -0.30) * ANGLES(RAD(-9), RAD(-7), RAD(-60)), 1.8 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 -0.30, 0.4, 0) * ANGLES(RAD(155), RAD(0), RAD(80)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 +0.30, 0.1, 0) * ANGLES(RAD(60), RAD(0), RAD(-80)) * LEFTSHOULDERC0, 2 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1.7-0.10, -1 +0.40, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(-60), RAD(-5)), 1.8 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -1 +0.40, -0.5) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-15), RAD(25), RAD(0)), 1.8 / Animation_Speed)
	end
	spawn(function()
	    for i=0, 1, 0.1 / Animation_Speed do
        wait(0.02)
        AoE(RootPart.CFrame * Vector3.new(0,0.5,-4),3.75)
end
stopnow = true
	end)
	
	repeat
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.3) * ANGLES(RAD(23), RAD(0), RAD(MRANDOM(-20,20))), 2 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 -0.30) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(MRANDOM(1.3,2)-0.30, MRANDOM(0.5,2), MRANDOM(-2,0)) * ANGLES(RAD(MRANDOM(110,130)), RAD(0), RAD(MRANDOM(-15,0))) * RIGHTSHOULDERC0, 5 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(MRANDOM(-2,-1.3)+0.30, MRANDOM(0.5,2), MRANDOM(-2,0)) * ANGLES(RAD(110), RAD(0), RAD(MRANDOM(0,15))) * LEFTSHOULDERC0, 5 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1-0.10, -1+0.40, -0.4) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-20)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -0.4+0.40, -1) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-10)), 1 / Animation_Speed)
	until stopnow == true
			    for i=0, 0.3, 0.1 / Animation_Speed do
        Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 1, -0.1) * ANGLES(RAD(10), RAD(-5), RAD(-80)), 0.8 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 -0.30) * ANGLES(RAD(0), RAD(0), RAD(60)), 0.8 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.2-0.30, -0.1, 0.3) * ANGLES(RAD(110), RAD(10), RAD(60)) * RIGHTSHOULDERC0, 0.8 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.2+0.30, 0, 0) * ANGLES(RAD(60), RAD(10), RAD(-50)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1-0.10, -1+0.40, -0.2) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-10), RAD(-10), RAD(-10)), 0.8 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -1+0.40, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-15), RAD(20), RAD(0)), 0.8 / Animation_Speed)
	    end
			for i=0, 0.1, 0.1 / Animation_Speed do
		Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(7), RAD(90)), 1.8 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, -0.30) * ANGLES(RAD(-9), RAD(-7), RAD(-60)), 1.8 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 -0.30, 0.4, 0) * ANGLES(RAD(155), RAD(0), RAD(80)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 +0.30, 0.1, 0) * ANGLES(RAD(60), RAD(0), RAD(-80)) * LEFTSHOULDERC0, 2 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1.7-0.10, -1 +0.40, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(-60), RAD(-5)), 1.8 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -1 +0.40, -0.5) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-15), RAD(25), RAD(0)), 1.8 / Animation_Speed)
	end
AoElast(RootPart.CFrame * Vector3.new(0,0.5,-4),3.5)
		for i=0, 0.1, 0.1 / Animation_Speed do
		Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(7), RAD(90)), 1.8 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, -0.30) * ANGLES(RAD(-9), RAD(-7), RAD(-60)), 1.8 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 -0.30, 0.4, 0) * ANGLES(RAD(155), RAD(0), RAD(80)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 +0.30, 0.1, 0) * ANGLES(RAD(60), RAD(0), RAD(-80)) * LEFTSHOULDERC0, 2 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1.7-0.10, -1 +0.40, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(-60), RAD(-5)), 1.8 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -1 +0.40, -0.5) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-15), RAD(25), RAD(0)), 1.8 / Animation_Speed)
	end
	
			for i=0, 1, 0.1 / Animation_Speed do
		Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(7), RAD(90)), 1.8 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, -0.30) * ANGLES(RAD(-9), RAD(-7), RAD(-60)), 1.8 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5 -0.30, 0.4, 0) * ANGLES(RAD(155), RAD(0), RAD(80)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5 +0.30, 0.1, 0) * ANGLES(RAD(60), RAD(0), RAD(-80)) * LEFTSHOULDERC0, 2 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1.7-0.10, -1 +0.40, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(-60), RAD(-5)), 1.8 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -1 +0.40, -0.5) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-15), RAD(25), RAD(0)), 1.8 / Animation_Speed)
	end

		ATTACK = false
		Rooted = false
		end)
	end
	
	function gloveattack()
	spawn(function()
		wait(4)
		if cooldownn == true then
			COMBO = 1
			end
	end)
		if COMBO == 1 then
			COMBO = 2
			ATTACK = true 
			Rooted = true
			spawn(function()
										local FLIGHTFORCE = Instance.new("BodyPosition", RootPart)
						FLIGHTFORCE.D = 1250
						FLIGHTFORCE.Name = "Client"
						FLIGHTFORCE.P = 10000
						FLIGHTFORCE.maxForce = VV(100000, 100000, 100000)
						FLIGHTFORCE.position = RootPart.CFrame * Vector3.new(0,0.5,-3)
						wait(0.5)
						FLIGHTFORCE:Destroy()
			end)
						for i=0, 0.3, 0.1 / Animation_Speed do
		Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5) * ANGLES(RAD(3), RAD(-2), RAD(65)), 1.5 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0-0.30) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1.5 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5-0.30, 0.5, -0.5) * ANGLES(RAD(90), RAD(0), RAD(70)) * RIGHTSHOULDERC0, 3 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5+0.30, 0.5, 0.8) * ANGLES(RAD(80), RAD(0), RAD(-40)) * LEFTSHOULDERC0, 1.5 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1-0.10, -0.5+0.40, -1) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(-10), RAD(-30)), 1.5 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -1+0.40, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(-20), RAD(40)), 1.5 / Animation_Speed)
	end
	CreateSound(158037267,RootPart,3,0.6)
	AoEpunch(RootPart.CFrame * Vector3.new(0,0.5,-4),3.75)
	ATTACK = false
	Rooted = false
		end
	end
	
	function gloveattack2()

		spawn(function()
										local FLIGHTFORCE = Instance.new("BodyPosition", RootPart)
						FLIGHTFORCE.D = 1250
						FLIGHTFORCE.Name = "Client"
						FLIGHTFORCE.P = 10000
						FLIGHTFORCE.maxForce = VV(1000000, 1000000, 1000000)
						FLIGHTFORCE.position = RootPart.CFrame * Vector3.new(0,0.5,-3)
						wait(0.5)
						FLIGHTFORCE:Destroy()
			end)
								if COMBO == 2 then
			COMBO = 3
			ATTACK = true 
			Rooted = true
						for i=0, 0.1, 0.1 / Animation_Speed do
		Swait()
               RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5) * ANGLES(RAD(15), RAD(5), RAD(25)), 1.5 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0-0.30) * ANGLES(RAD(-2), RAD(0), RAD(-20)), 1 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.3-0.30, 0.3, -1) * ANGLES(RAD(90), RAD(0), RAD(-80)) * RIGHTSHOULDERC0, 1.5 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1+0.30, 0, 0.3) * ANGLES(RAD(120), RAD(10), RAD(-70)) * LEFTSHOULDERC0, 1.5 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1-0.10, -1+0.40, -0.2) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-40)), 1.5 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -0.5+0.40, -0.55) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 1.5 / Animation_Speed)
	end
							for i=0, 0.1, 0.1 / Animation_Speed do
		Swait()
                RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5) * ANGLES(RAD(-4), RAD(-4), RAD(-60)), 1.5 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0-0.30) * ANGLES(RAD(0), RAD(0), RAD(0)), 1.5 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.8-0.30, 0.2, 0.7) * ANGLES(RAD(30), RAD(80), RAD(70)) * RIGHTSHOULDERC0, 1.5 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5+0.30, 0.5, -0.8) * ANGLES(RAD(-30), RAD(-60), RAD(-120)) * LEFTSHOULDERC0, 1.5 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1-0.10, -0.6+0.40, -1) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(-10), RAD(-5)), 1.5 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -1+0.40, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(10), RAD(35)), 1.5 / Animation_Speed)
end
CreateSound(158037267,RootPart,3,0.6)
AoEpunch(RootPart.CFrame * Vector3.new(0,0.5,-4),3.75)
								for i=0, 0.3, 0.1 / Animation_Speed do
		Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5) * ANGLES(RAD(0), RAD(-6), RAD(-80)), 1.5 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0-0.30) * ANGLES(RAD(5), RAD(10), RAD(0)), 1 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5-0.30, 0.3, 0) * ANGLES(RAD(90), RAD(5), RAD(-40))* ANGLES(RAD(0), RAD(100), RAD(0)) * RIGHTSHOULDERC0, 1.5 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.3+0.30, -0.3, -0.6) * ANGLES(RAD(70), RAD(0), RAD(50)) * ANGLES(RAD(0), RAD(-85), RAD(0)) * LEFTSHOULDERC0, 1.5 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1.2-0.10, -0.6+0.40, -0.2) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-10), RAD(-30), RAD(-2)), 1.5 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -0.7+0.40, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-10), RAD(10), RAD(0)), 1.5 / Animation_Speed)

	end
	
	ATTACK = false
	Rooted = false
		end
	end
	
		function gloveattack3()
			local stopnow = false

		if COMBO == 3 then
			COMBO = 4
			ATTACK = true 
		Rooted = true
				    for i=0, 0, 0.1 / Animation_Speed do
        Swait()
			    RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 -0.02* SIN(SINE/6)) * ANGLES(RAD(0), RAD(0), RAD(0)), 5 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, -0.30) * ANGLES(RAD(0+1* SIN(SINE/6)), RAD(0), RAD(0)), 5 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5-0.30, 0.48 +0.02* SIN(SINE/6), 0) * ANGLES(RAD(1-3* SIN(SINE/6)), RAD(0-1* SIN(SINE/6)), RAD(0+1.5* COS(SINE/6))) * RIGHTSHOULDERC0, 5 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5+0.30, 0.48 +0.02* SIN(SINE/6), 0) * ANGLES(RAD(1-3* SIN(SINE/6)), RAD(0+1* SIN(SINE/6)), RAD(0-1.5* COS(SINE/6))) * LEFTSHOULDERC0, 5 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1.01-0.10, -1 +0.40 +0.02* SIN(SINE/6), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(-5), RAD(0)), 5 / Animation_Speed)
			        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.01+0.10, -1 +0.40 +0.02* SIN(SINE/6), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(5), RAD(0)), 5 / Animation_Speed)
			 end
		    for i=0, 0.4, 0.1 / Animation_Speed do
        Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.35) * ANGLES(RAD(0), RAD(0), RAD(-65)) * ANGLES(RAD(0), RAD(-2), RAD(0)), 0.5 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0-0.30) * ANGLES(RAD(0), RAD(0), RAD(70)), 1 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5-0.30, 0.5, 0) * ANGLES(RAD(130), RAD(0), RAD(70)) * ANGLES(RAD(0), RAD(0), RAD(30)) * ANGLES(RAD(40), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(-30), RAD(0)) * ANGLES(RAD(-30), RAD(0), RAD(0)) * CF(0.1, 0.2, -0.3) * RIGHTSHOULDERC0, 1 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5+0.30, 0.5, 0) * ANGLES(RAD(80), RAD(0), RAD(-50)) * ANGLES(RAD(0), RAD(-16), RAD(0)) * CF(0, 0.7, 0.45)  * CF(0.2, 0, 0) * LEFTSHOULDERC0, 1 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1-0.10, -0.7+0.40, 0.2) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(-50), RAD(-5)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-0.6+0.10, -0.7+0.40, -1.1) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(45)) * ANGLES(RAD(-20), RAD(0), RAD(0)), 1 / Animation_Speed)


	    end
	
	spawn(function()
	    for i=0, 0.2, 0.1 / Animation_Speed do
        wait(0.05)
        AoEpunch(RootPart.CFrame * Vector3.new(0,0.5,-4),3.75)
CreateSound(158037267,RootPart,3,0.6)
end
stopnow = true
	end)
	
	repeat
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.3) * ANGLES(RAD(23), RAD(0), RAD(MRANDOM(-20,20))), 2 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 -0.30) * ANGLES(RAD(-15), RAD(0), RAD(0)), 1 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(MRANDOM(1.3,2)-0.30, MRANDOM(0.5,2), MRANDOM(-2,0)) * ANGLES(RAD(MRANDOM(110,130)), RAD(0), RAD(MRANDOM(-15,0))) * RIGHTSHOULDERC0, 5 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(MRANDOM(-2,-1.3)+0.30, MRANDOM(0.5,2), MRANDOM(-2,0)) * ANGLES(RAD(110), RAD(0), RAD(MRANDOM(0,15))) * LEFTSHOULDERC0, 5 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1-0.10, -1+0.40, -0.4) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-20)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -0.4+0.40, -1) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-10)), 1 / Animation_Speed)
	until stopnow == true
	AoE(RootPart.CFrame * Vector3.new(0,0.5,-4),3.75)
	ATTACK = false
	Rooted = false
		end
	end

	function gloveattack4()

		spawn(function()
										local FLIGHTFORCE = Instance.new("BodyPosition", RootPart)
						FLIGHTFORCE.D = 1250
						FLIGHTFORCE.Name = "Client"
						FLIGHTFORCE.P = 10000
						FLIGHTFORCE.maxForce = VV(1000000, 1000000, 1000000)
						FLIGHTFORCE.position = RootPart.CFrame * Vector3.new(0,0.5,-3)
						wait(0.5)
						FLIGHTFORCE:Destroy()
			end)
								if COMBO == 4 then
			COMBO = 5
			ATTACK = true 
			Rooted = true
						for i=0, 0.07, 0.1 / Animation_Speed do
		Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5) * ANGLES(RAD(0), RAD(0), RAD(65)) * ANGLES(RAD(-10), RAD(0), RAD(0)),  4 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0-0.30) * ANGLES(RAD(0), RAD(0), RAD(-25)),  4 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5-0.30, 0.3, -0.6) * ANGLES(RAD(80), RAD(0), RAD(-20)) * RIGHTSHOULDERC0, 4 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.38+0.30, 0.1, 0.5) * ANGLES(RAD(100), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 4 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1.25-0.10, -0.7+0.40, -0.9) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(-15), RAD(-35)), 4 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -0.6+0.40, -0.4) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(5), RAD(35)), 4 / Animation_Speed)

	end
							for i=0, 0.1, 0.1 / Animation_Speed do
		Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5) * ANGLES(RAD(0), RAD(0), RAD(-35)) * ANGLES(RAD(-15), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(-10), RAD(0)), 2 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0-0.30) * ANGLES(RAD(0), RAD(0), RAD(0)), 2 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(2-0.30, 0.1, 0) * ANGLES(RAD(80), RAD(0), RAD(-40)) *  CF(0, -0.5, -0.3) * ANGLES(RAD(0), RAD(-5), RAD(0)) * RIGHTSHOULDERC0,2 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5+0.30, 0.8, -1.5) * ANGLES(RAD(90), RAD(0), RAD(30)) * ANGLES(RAD(0), RAD(-15), RAD(0)) * LEFTSHOULDERC0, 2 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1-0.10, -1+0.40, -0.7) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-45)), 2 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -1.3+0.40, -0.85) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(56)), 2 / Animation_Speed)

end
CreateSound(158037267,RootPart,3,0.6)
AoEpunch(RootPart.CFrame * Vector3.new(0,0.5,-4),3.75)
								for i=0, 0.4, 0.1 / Animation_Speed do
		Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.1) * ANGLES(RAD(0), RAD(0), RAD(-55)) * ANGLES(RAD(-10), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(-3), RAD(0)), 2 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0-0.30) * ANGLES(RAD(5), RAD(0), RAD(50)), 2 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.3-0.30, -0.4, 0) * ANGLES(RAD(95), RAD(0), RAD(-26)) * ANGLES(RAD(0), RAD(-25), RAD(0)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1+0.30, 0.5, -0.5) * ANGLES(RAD(95), RAD(0), RAD(80)) * ANGLES(RAD(0), RAD(-30), RAD(0)) * LEFTSHOULDERC0, 2 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1.1-0.10, -1+0.40, -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-20), RAD(-20), RAD(-40)), 2 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.2+0.10, -1+0.40, -0.8) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(5), RAD(14)), 2 / Animation_Speed)

	end
	
	ATTACK = false
	Rooted = false
		end
end

	function gloveattack5()

		spawn(function()
										local FLIGHTFORCE = Instance.new("BodyPosition", RootPart)
						FLIGHTFORCE.D = 1250
						FLIGHTFORCE.Name = "Client"
						FLIGHTFORCE.P = 10000
						FLIGHTFORCE.maxForce = VV(1000000, 1000000, 1000000)
						FLIGHTFORCE.position = RootPart.CFrame * Vector3.new(0,0.5,-3)
						wait(0.5)
						FLIGHTFORCE:Destroy()
			end)
								if COMBO == 5 then
			COMBO = 1
			ATTACK = true 
			Rooted = true
						for i=0, 0.07, 0.1 / Animation_Speed do
		Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.2) * ANGLES(RAD(0), RAD(0), RAD(-85)) * ANGLES(RAD(10), RAD(0), RAD(0)), 4 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0-0.30) * ANGLES(RAD(-3), RAD(5), RAD(30)), 4 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.4-0.30, -0.2, 0.15) * ANGLES(RAD(100), RAD(0), RAD(-10)) * ANGLES(RAD(0), RAD(-10), RAD(0)) * RIGHTSHOULDERC0, 4 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.8+0.30, -0.05, 0.3) * ANGLES(RAD(80), RAD(0), RAD(-46)) * ANGLES(RAD(0), RAD(-10), RAD(0)) * CF(-0.35, 0, 0) * LEFTSHOULDERC0, 4 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1.4-0.10, -1.1+0.40, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(10), RAD(-20), RAD(-20)), 4 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.1+0.10, -1+0.40, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(10), RAD(30)), 4 / Animation_Speed)
	
	end
							for i=0, 0.1, 0.1 / Animation_Speed do
		Swait()
 		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5) * ANGLES(RAD(0), RAD(0), RAD(45)) * ANGLES(RAD(10), RAD(0), RAD(0)), 2 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0-0.30) * ANGLES(RAD(2), RAD(-6), RAD(-40)), 2  / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(2-0.30, 0.8, -1) * ANGLES(RAD(90), RAD(0), RAD(10)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5+0.30, 0, 0) * ANGLES(RAD(75), RAD(0), RAD(-40)) * CF(0, 0.7, 0) * LEFTSHOULDERC0, 2  / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1.2-0.10, -0.8+0.40, -0.7) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(-10), RAD(-30)), 2  / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -1+0.40, -0.5) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(3), RAD(35)), 2  / Animation_Speed)
	
end
CreateSound(158037267,RootPart,3,0.6)
AoEbam(RootPart.CFrame * Vector3.new(0,0.5,-4),3.75)
								for i=0, 0.55, 0.1 / Animation_Speed do
		Swait()
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.3) * ANGLES(RAD(0), RAD(-6), RAD(75)) * ANGLES(RAD(20), RAD(0), RAD(0)), 2 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0-0.30) * ANGLES(RAD(-5), RAD(0), RAD(-40)), 2 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1-0.30, 0, -0.6) * ANGLES(RAD(85), RAD(0), RAD(-60)) * ANGLES(RAD(0), RAD(20), RAD(0)) * RIGHTSHOULDERC0, 2 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1+0.30, 0.3, 0.4) * ANGLES(RAD(70), RAD(0), RAD(-30)) * ANGLES(RAD(0), RAD(-10), RAD(0)) * LEFTSHOULDERC0, 2 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(0.7-0.10, -0.7+0.40, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-30), RAD(0), RAD(-30)), 2 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -0.6+0.40, -0.6) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(10)), 2 / Animation_Speed)

	end
	
	ATTACK = false
	Rooted = false
		end
	end
	
	
		function starpoint()
			if game.Workspace:FindFirstChild("HelloDatBurpSavePoint") then
				game.Workspace:FindFirstChild("HelloDatBurpSavePoint"):remove()
			end
		local str = starr:Clone()
			str:SetPrimaryPartCFrame(RootPart.CFrame * CFrame.new(0,1.2,-4))
		str.Parent = workspace
	end
	
function MouseDown(Mouse)
	spawn(function()
if ATTACK == false and gloveuse == true then
	gloveattack()
end
end)
spawn(function()
if ATTACK == false and gloveuse == true then
	gloveattack2()
end
end)

spawn(function()
if ATTACK == false and gloveuse == true then
	gloveattack3()
end
	end)
	
	spawn(function()
if ATTACK == false and gloveuse == true then
	gloveattack4()
end
	end)
	
		spawn(function()
if ATTACK == false and gloveuse == true then
	gloveattack5()
end
	end)
	
end

function MouseUp(Mouse)
HOLD = false
end


function frontdash()
	spawn(function()
		rungo = true
		wait(5)
		rungo = false
	end)
	spawn(function()
		ATTACK =true
		for i=0, 0.3, 0.1 / Animation_Speed do
			Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(40), RAD(0), RAD(0)), 0.8 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, -0.30) * ANGLES(RAD(-40), RAD(0), RAD(0)), 0.8 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5-0.30, 0.5, 0) * ANGLES(RAD(90), RAD(-10), RAD(-50)) * RIGHTSHOULDERC0, 0.8 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5+0.30, 0.5, 0) * ANGLES(RAD(-50), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1-0.10, -0.4+0.40, -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-20)), 0.8 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -0.8+0.40, -0.2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.8 / Animation_Speed)
end
ATTACK = false
	end)
	CreateSound(158149887,Head,2,1.2,false)
	                  				local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1000000000, 1000000000, 1000000000)
		bv.velocity = RootPart.CFrame.lookVector * 100 + Vector3.new(0,30,0)
		bv.Parent = RootPart
		Debris:AddItem(bv, 0.05)
end

function backdash()
		spawn(function()
		rungo = true
		wait(5)
		rungo = false
	end)
		spawn(function()
		ATTACK =true
		for i=0, 0.3, 0.1 / Animation_Speed do
			Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-40), RAD(0), RAD(0)), 0.8 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, -0.30) * ANGLES(RAD(50), RAD(0), RAD(0)), 0.8 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5-0.30, 0.5, 0) * ANGLES(RAD(40), RAD(-10), RAD(20)) * RIGHTSHOULDERC0, 0.8 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5+0.30, 0.5, 0) * ANGLES(RAD(50), RAD(20), RAD(-20)) * LEFTSHOULDERC0, 0.8 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1-0.10, -0.4+0.40, -0.5) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(-20)), 0.8 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -0.8+0.40, -0.2) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(10)), 0.8 / Animation_Speed)
end
ATTACK = false
	end)
	CreateSound(158149887,Head,2,1.2,false)
	                  				local bv = Instance.new("BodyVelocity")
		bv.maxForce = Vector3.new(1000000000, 1000000000, 1000000000)
		bv.velocity = RootPart.CFrame.lookVector * -100 + Vector3.new(0,50,0)
		bv.Parent = RootPart
		Debris:AddItem(bv, 0.05)
end

function aa()
	if dienow == false then
		dienow =true
	spawn(function()
		
									local Soul = soll:Clone()
								Soul:SetPrimaryPartCFrame(RootPart.CFrame)
								Soul.Parent = workspace
								local hertscript = Soul:FindFirstChild("Script")
								hertscript.Disabled = false
											for i,v in pairs(Player.Character:GetChildren()) do
	if v:findFirstChildOfClass("Decal") then
		v:findFirstChildOfClass("Decal").Transparency = 1
	end
	if v.ClassName == "Part" or v.ClassName == "MeshPart" and v.Name ~= "HumanoidRootPart" then
		v.Transparency = 1
	end
	if v.Name == "HumanoidRootPart" then
		v.Transparency = 1
	end
	if v.ClassName == "Accessory" then
		if v:findFirstChild("Handle") then
			if v:findFirstChild("Handle").ClassName == "Part" then
				v:findFirstChild("Handle").Transparency = 1
			end
			end
			end
			end
								end)
								end
end

function KeyDown(Key)
	KEYHOLD = true
		if Key == "GOOFY AHHH KEY WHAT NO WORK" then
	if OTHERWORLD == false then
		OTHERWORLD = true
		Player.Character.Parent = viewport
	else
		OTHERWORLD = false
		Player.Character.Parent = workspace
	end

	end
	
			if Key == "x" then
	if cooldownn == false then
		cooldownn = true
		COMBO = 1
	else
		cooldownn = false
		COMBO = 1
		end
	

	end
	
				if Key == "c" then
COMBO = 5
		end
	
	if Key == "g" and ATTACK == false and gloveuse== true  then
		barrage()
	end
	

	
		if Key == "q" and ATTACK == false then
		starpoint()
	end
	
	   if Key == "w" and ATTACK == false then 
           if Tapped == false then
                   Tapped = true
                   wait(Time)
                   Tapped = false
                else
frontdash()
          end
     end

	   if Key == "r" and ATTACK == false then 
           if Tapped == false then
                   Tapped = true
                   wait(Time)
                   Tapped = false
                else
backdash()
          end
     end



	if Key == "l" then
		if gloveuse == false then
			gloveuse = true
											local st = Instance.new("BoolValue",game:GetService("SoundService"))
st.Name = "gloveval"

		else
				gloveuse = false
										if Character:FindFirstChild("LeftGlove") then
			Character:FindFirstChild("LeftGlove"):remove()
			end
			
			if Character:FindFirstChild("RightGlove") then
			Character:FindFirstChild("RightGlove"):remove()
			end
		end

	end
	

if Key == "p" then
		spawn(function()
					for Index, Player in next, game:GetService("Players"):GetPlayers() do
		local rm = script.fixeffect:Clone()
	rm.Parent = Player:WaitForChild("PlayerGui")
	rm.Disabled = false
		game:GetService("Debris"):AddItem(rm)
	end
		end)
end
	if Key == "m" then
		if what == false then
			what = true
			msuic:Play()
		else
			what = false
		end
	end

	
end


function KeyUp(Key)
	KEYHOLD = false
end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end)

--//=================================\\
--||	      End of Keys
--\\=================================//



spawn(function()
	while true do wait()
		if game:GetService("SoundService"):FindFirstChild("gloveval") then
			game:GetService("SoundService"):FindFirstChild("gloveval"):remove()
						local gloveleft = leftg:Clone()
local gloveright = rightg:Clone()
gloveleft.Parent = Character
gloveright.Parent = Character
local GL = gloveleft.Base
local GR = gloveright.Base

for v2, v3 in pairs(gloveleft:GetChildren()) do
	if v3.ClassName == "Part" and v3.ClassName == "MeshPart" then
		v3.Anchored = false
		end
end

for v2, v3 in pairs(gloveright:GetChildren()) do
	if v3.ClassName == "Part" and v3.ClassName == "MeshPart" then
		v3.Anchored = false
	end
end

local Weldshead = Instance.new("Weld")
Weldshead.Parent = GR
Weldshead.Part0 = GR
Weldshead.Part1 = RightArm
Weldshead.C0 = CFrame.new(0,0,0)*CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))


local Weldshead = Instance.new("Weld")
Weldshead.Parent = GL
Weldshead.Part0 = GL
Weldshead.Part1 = LeftArm
Weldshead.C0 = CFrame.new(0,0,0)*CFrame.Angles(math.rad(0), math.rad(0), math.rad(0))

		end
	end
end)



	spawn(function()
		while wait(1) do
			Humanoid.HipHeight = -0.55
				Head.Size = Vector3.new(1.6, 0.25, 0.25)
	Torso.Size = Vector3.new(1.6, 1.6, 0.25)
	LeftArm.Size = Vector3.new(0, 0, 1)
	RightArm.Size = Vector3.new(0.25, 0, 0.25)
	LeftLeg.Size = Vector3.new(0.25, 1.6, 0.25)
	RightLeg.Size = Vector3.new(0.25, 1.6, 0.25)
				if Character:FindFirstChild("Brooding Black") then
		Character:FindFirstChild("Brooding Black"):FindFirstChild("Handle"):FindFirstChild("HairAttachment").Position = Vector3.new(0, 0.30, -0.085)
		Character:FindFirstChild("Brooding Black"):FindFirstChild("Handle"):FindFirstChild("Mesh").Scale = Vector3.new(0.84, 0.8, 0.84)
	end
		if Character:FindFirstChild("HolidayReefCrown") then
		Character:FindFirstChild("HolidayReefCrown"):FindFirstChild("Handle"):FindFirstChild("HatAttachment").Position = Vector3.new(0, 0.175, 0)
		Character:FindFirstChild("HolidayReefCrown"):FindFirstChild("Handle"):FindFirstChild("Mesh").Scale = Vector3.new(0.6, 0.6, 0.6)
	end
			if Character:FindFirstChild("KittyEars") then
		Character:FindFirstChild("KittyEars"):FindFirstChild("Handle"):FindFirstChild("HatAttachment").Position = Vector3.new(-0.025, -0.03, 0)
		Character:FindFirstChild("KittyEars"):FindFirstChild("Handle"):FindFirstChild("Mesh").Scale = Vector3.new(0.8, 0.8, 0.8)
	end
	if Character:FindFirstChild("PunkRat") then
		Character:FindFirstChild("PunkRat"):FindFirstChild("Handle"):FindFirstChild("HatAttachment").Position = Vector3.new(0, 0.15, 0)
		Character:FindFirstChild("PunkRat"):FindFirstChild("Handle"):FindFirstChild("Mesh").Scale = Vector3.new(0.8, 0.8, 0.8)
	end
		if Character:FindFirstChild("ButterflyLapelPin") then
		Character:FindFirstChild("ButterflyLapelPin"):FindFirstChild("Handle"):FindFirstChild("BodyFrontAttachment").Position = Vector3.new(0.5, -0.4, -0.05)
		Character:FindFirstChild("ButterflyLapelPin"):FindFirstChild("Handle"):FindFirstChild("Mesh").Scale = Vector3.new(0.3, 0.3, 0.3)
	end
		end
	end)
spawn(function()
	
while wait() do
if  not game:service'Players'.localPlayer.Character or not game:service'Players'.localPlayer.Character.Parent or game:service'Players'.localPlayer.Character == nil or game:service'Players'.localPlayer.Character.Parent == nil or game:service'Players'.localPlayer.Character.Parent ~= workspace or game:service'Players'.localPlayer.Character:FindFirstChildOfClass("Humanoid") == nil or game:service'Players'.localPlayer.Character:FindFirstChild("Head") == nil or game:service'Players'.localPlayer.Character:FindFirstChild("HumanoidRootPart") == nil or game:service'Players'.localPlayer.Character:FindFirstChild("Torso") == nil or game:service'Players'.localPlayer.Character:FindFirstChild("Right Arm") == nil or game:service'Players'.localPlayer.Character:FindFirstChild("Left Arm") == nil or game:service'Players'.localPlayer.Character:FindFirstChild("Right Leg") == nil or game:service'Players'.localPlayer.Character:FindFirstChild("Left Leg") == nil or game:service'Players'.localPlayer.Character.Torso:FindFirstChild("Neck") == nil or game:service'Players'.localPlayer.Character.Torso:FindFirstChild("Left Shoulder") == nil or game:service'Players'.localPlayer.Character.Torso:FindFirstChild("Right Shoulder") == nil or game:service'Players'.localPlayer.Character.Torso:FindFirstChild("Right Hip") == nil or game:service'Players'.localPlayer.Character.Torso:FindFirstChild("Left Hip") == nil or game:service'Players'.localPlayer.Character.HumanoidRootPart:FindFirstChild("RootJoint") == nil then
	aa()
end
	
end
end)

while true do
	Swait()
	
		if workspace:FindFirstChild("NotOk") == nil  and  OTHERWORLD == false then
		Shield = Instance.new ("MeshPart", workspace)
		Shield.Name = "NotOk"
		Shield.CanCollide = false
		Shield.Transparency = 1
		Shield.Material = "ForceField"
		Shield.BrickColor = BrickColor.new("Fat shield that i still use")
		Shield.Size = Vector3.new(6,6.3,6)
		Shield.CFrame = Torso.CFrame
		local Wed = Instance.new("Weld", Shield)
		Wed.Part0 = Shield
		Wed.Part1 = Torso
	end
    for _,v in next, Humanoid:GetPlayingAnimationTracks() do
        v:Stop();
    end
    SINE = SINE + CHANGE
	local sidevec = math.clamp((RootPart.Velocity*RootPart.CFrame.rightVector).X+(RootPart.Velocity*RootPart.CFrame.rightVector).Z,-Humanoid.WalkSpeed,Humanoid.WalkSpeed)
	local forwardvec =  math.clamp((RootPart.Velocity*RootPart.CFrame.lookVector).X+(RootPart.Velocity*RootPart.CFrame.lookVector).Z,-Humanoid.WalkSpeed,Humanoid.WalkSpeed)
	
	local sidevelocity = sidevec/Humanoid.WalkSpeed     local forwardvelocity = forwardvec/Humanoid.WalkSpeed
    local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
    local TORSOVERTICALVELOCITY = RootPart.Velocity.y
    local HITFLOOR = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)

    local WALKSPEEDVALUE = 6 / (Humanoid.WalkSpeed / 60)
    if ANIM == "Walk" and TORSOVELOCITY > 1 then
    elseif (ANIM ~= "Walk") or (TORSOVELOCITY < 1) then
        end
    if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
        ANIM = "Jump"
        if ATTACK == false then
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-3), RAD(0), RAD(0)), 1 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, -0.30) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5-0.30, 0.5, 0) * ANGLES(RAD(-19), RAD(0), RAD(10)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5+0.30, 0.5, 0) * ANGLES(RAD(-19), RAD(0), RAD(-10)) * LEFTSHOULDERC0, 1 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1-0.10, -0.3+0.40, -0.4) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(20)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -0.3+0.40, -0.4) * ANGLES(RAD(0), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(30)), 1 / Animation_Speed)

        end
    elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
        ANIM = "Fall"
        if ATTACK == false then
        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, -0.30) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5-0.30, 0.5, 0) * ANGLES(RAD(-19), RAD(0), RAD(20)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5+0.30, 0.5, 0) * ANGLES(RAD(-19), RAD(0), RAD(-20)) * LEFTSHOULDERC0, 1 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1-0.10, -0.9+0.40, -0.1) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(6)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -0.3+0.40, -0.4) * ANGLES(RAD(0), RAD(-70), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(30)), 1 / Animation_Speed)
        end
    elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
        ANIM = "Idle"
        if ATTACK == false then
	    RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 -0.02* SIN(SINE/6)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, -0.30) * ANGLES(RAD(0+1* SIN(SINE/6)), RAD(0), RAD(0)), 1 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5-0.30, 0.48 +0.02* SIN(SINE/6), 0) * ANGLES(RAD(1-3* SIN(SINE/6)), RAD(0-1* SIN(SINE/6)), RAD(0+1.5* COS(SINE/6))) * RIGHTSHOULDERC0, 1 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5+0.30, 0.48 +0.02* SIN(SINE/6), 0) * ANGLES(RAD(1-3* SIN(SINE/6)), RAD(0+1* SIN(SINE/6)), RAD(0-1.5* COS(SINE/6))) * LEFTSHOULDERC0, 1 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1.01-0.10, -1 +0.40 +0.02* SIN(SINE/6), -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(-5), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.01+0.10, -1 +0.40 +0.02* SIN(SINE/6), -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(5), RAD(0)), 1 / Animation_Speed)
--1
--RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5) * ANGLES(RAD(3), RAD(-2), RAD(65)), 1 / Animation_Speed)
--        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0-0.30) * ANGLES(RAD(0), RAD(0), RAD(-60)), 1 / Animation_Speed)
--        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5-0.30, 0.5, -0.5) * ANGLES(RAD(90), RAD(0), RAD(70)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
--        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5+0.30, 0.5, 0.8) * ANGLES(RAD(80), RAD(0), RAD(-40)) * LEFTSHOULDERC0, 1 / Animation_Speed)
--        RightHip.C0 = Clerp(RightHip.C0, CF(1-0.10, -0.5+0.40, -1) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(-10), RAD(-30)), 1 / Animation_Speed)
--        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -1+0.40, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(-20), RAD(40)), 1 / Animation_Speed)

-- template
--        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
--        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0-0.30) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
--        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5-0.30, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
--        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5+0.30, 0.5, 0) * ANGLES(RAD(0), RAD(0), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
--        RightHip.C0 = Clerp(RightHip.C0, CF(1-0.10, -1+0.40, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
--        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -1+0.40, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
			
--        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.2) * ANGLES(RAD(0), RAD(0), RAD(-85)) * ANGLES(RAD(10), RAD(0), RAD(0)), 1 / Animation_Speed)
--        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0-0.30) * ANGLES(RAD(-3), RAD(5), RAD(30)), 1 / Animation_Speed)
--        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.4-0.30, -0.2, 0.15) * ANGLES(RAD(100), RAD(0), RAD(-10)) * ANGLES(RAD(0), RAD(-10), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
--        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-0.8+0.30, -0.05, 0.3) * ANGLES(RAD(80), RAD(0), RAD(-46)) * ANGLES(RAD(0), RAD(-10), RAD(0)) * CF(-0.35, 0, 0) * LEFTSHOULDERC0, 1 / Animation_Speed)
--        RightHip.C0 = Clerp(RightHip.C0, CF(1.4-0.10, -1.1+0.40, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(10), RAD(-20), RAD(-20)), 1 / Animation_Speed)
--        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1.1+0.10, -1+0.40, -0.3) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(10), RAD(30)), 1 / Animation_Speed)
			
--        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.5) * ANGLES(RAD(0), RAD(0), RAD(45)) * ANGLES(RAD(10), RAD(0), RAD(0)), 1 / Animation_Speed)
--        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0-0.30) * ANGLES(RAD(2), RAD(-6), RAD(-40)), 1 / Animation_Speed)
--        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.9-0.30, 0.2, -1) * ANGLES(RAD(90), RAD(0), RAD(10)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
--        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5+0.30, 0, 0) * ANGLES(RAD(75), RAD(0), RAD(-40)) * CF(0, 0.7, 0) * LEFTSHOULDERC0, 1 / Animation_Speed)
--        RightHip.C0 = Clerp(RightHip.C0, CF(1.2-0.10, -0.8+0.40, -0.7) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(-10), RAD(-30)), 1 / Animation_Speed)
--        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -1+0.40, -0.5) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(3), RAD(35)), 1 / Animation_Speed)
			
--        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, -0.3) * ANGLES(RAD(0), RAD(-6), RAD(75)) * ANGLES(RAD(20), RAD(0), RAD(0)), 1 / Animation_Speed)
--        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0-0.30) * ANGLES(RAD(-5), RAD(0), RAD(-40)), 1 / Animation_Speed)
--        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1-0.30, 0, -0.6) * ANGLES(RAD(85), RAD(0), RAD(-60)) * ANGLES(RAD(0), RAD(20), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
--        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1+0.30, 0.3, 0.4) * ANGLES(RAD(70), RAD(0), RAD(-30)) * ANGLES(RAD(0), RAD(-10), RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
--        RightHip.C0 = Clerp(RightHip.C0, CF(0.7-0.10, -0.7+0.40, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-30), RAD(0), RAD(-30)), 1 / Animation_Speed)
--        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -0.6+0.40, -0.6) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-10), RAD(0), RAD(10)), 1 / Animation_Speed)
			
end
    elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
        ANIM = "Walk"
        if ATTACK == false then
	if rungo == true then
		 RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 -0.05* SIN(SINE/2)) * ANGLES(RAD(forwardvelocity*25), RAD(-sidevelocity*13) - RootPart.RotVelocity.Y / 90, RAD(0 - 3 * SIN(SINE/2))), 2.5 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, -0.30) * ANGLES(RAD(-20), RAD(-sidevelocity*5) - RootPart.RotVelocity.Y / 90, RAD(-sidevelocity*13) - RootPart.RotVelocity.Y / 90), 2.5 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5-0.30, 0.5, 0+ forwardvelocity/9 * math.cos(50-SINE / 2)) * ANGLES(RAD(10 -50 * SIN(SINE/2)), RAD(20), RAD(10)) * RIGHTSHOULDERC0, 2.5 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5+0.30, 0.5, 0- forwardvelocity/9 * math.cos(50-SINE / 2)) * ANGLES(RAD(10 +50 * SIN(SINE/2)), RAD(-20), RAD(-10)) * LEFTSHOULDERC0, 2.5 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1-0.10, -1 +0.40, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0 +50 * SIN(SINE/2))), 2.5 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -1 +0.40, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0 +50 * SIN(SINE/2))), 2.5 / Animation_Speed)
		else

        RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 -0.05* SIN(SINE/4)) * ANGLES(RAD(forwardvelocity*13), RAD(-sidevelocity*13) - RootPart.RotVelocity.Y / 90, RAD(0 - 3 * SIN(SINE/4))), 2.5 / Animation_Speed)
        Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, -0.30) * ANGLES(RAD(-5), RAD(-sidevelocity*5) - RootPart.RotVelocity.Y / 90, RAD(-sidevelocity*13) - RootPart.RotVelocity.Y / 90), 2.5 / Animation_Speed)
        RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5-0.30, 0.5, 0+ forwardvelocity/9 * math.cos(50-SINE / 4)) * ANGLES(RAD(10 -30 * SIN(SINE/4)), RAD(0), RAD(5)) * RIGHTSHOULDERC0, 2.5 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5+0.30, 0.5, 0- forwardvelocity/9 * math.cos(50-SINE / 4)) * ANGLES(RAD(10 +30 * SIN(SINE/4)), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 2.5 / Animation_Speed)
        RightHip.C0 = Clerp(RightHip.C0, CF(1-0.10, -1 +0.40, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0 +30 * SIN(SINE/4))), 2.5 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1+0.10, -1 +0.40, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0 +30 * SIN(SINE/4))), 2.5 / Animation_Speed)
end
        end

    end
 
    if Rooted == false then
        Disable_Jump = false
if rungo == true then
        Humanoid.WalkSpeed = 40
	else
	 Humanoid.WalkSpeed = 20
	end
Humanoid.JumpPower = 60
    elseif Rooted == true then
        Disable_Jump = true
Humanoid.WalkSpeed = 1
Humanoid.Health = 500
    end
    msuic.SoundId = "rbxassetid://"
    msuic.Looped = true
    msuic.Pitch = .89
    msuic.Volume = 1
	msuic.Playing = what
		end
	



--//====================================================\\--
--||			  		 END OF SCRIPT
--\\====================================================//--                     
