local script = game:GetObjects("rbxassetid://13709247313")[1]
plr = game.Players.LocalPlayer
Player = plr
char = plr.Character

game.Players.LocalPlayer.Character.Head.Anchored = true
-- Credits:
-- MyWorld - Reanimate
-- Epic - Better Tool Fling
-- Melon - Aligning, Highlight, Added more power to the fling
 
 local Charar = game.Players.LocalPlayer.Character
Charar["RectangleHead"].Name = "dummyhead"

game.TestService.IsSleepAllowed = false

local hatnameclone = {}
for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do
	if v:IsA("Accessory") then
		if hatnameclone[v.Name] then
			if hatnameclone[v.Name] == "s" then
				hatnameclone[v.Name] = {}
			end
			table.insert(hatnameclone[v.Name],v)
		else
			hatnameclone[v.Name] = "s"
		end
	end
end
for _,v in pairs(hatnameclone) do
	if type(v) == "table" then
		local num = 1
		for _,w in pairs(v) do
			w.Name = w.Name..num
			num = num + 1
		end
	end
end
hatnameclone = nil

local v3_net, v3_808 = Vector3.new(5000, 25.1, 0), Vector3.new(8, 0, 8)
    local function getNetlessVelocity(realPartVelocity)
        local mag = realPartVelocity.Magnitude
        if mag > 1 then
            local unit = realPartVelocity.Unit
            if (unit.Y > 0.25) or (unit.Y < -0.75) then
                return unit * (25.1 / unit.Y)
            end
        end
        return v3_net + realPartVelocity * v3_808
    end
local simradius = "shp" --simulation radius (net bypass) method
--simulation radius (net bypass) method
--"shp" - sethiddenproperty
--"ssr" - setsimulationradius
--false - disable
local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
local newanimate = true --disables the animate script and enables after reanimation
local discharscripts = true --disables all localScripts parented to your character before reanimation
local R15toR6 = true --tries to convert your character to r6 if its r15
local hatcollide = true --makes hats cancollide (only method 0)
local humState16 = true --enables collisions for limbs before the humanoid dies (using hum:ChangeState)
local addtools = false --puts all tools from backpack to character and lets you hold them after reanimation
local hedafterneck = false --disable aligns for head and enable after neck is removed
local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
local method = 0 --reanimation method
--methods:
--0 - breakJoints (takes [loadtime] seconds to laod)
--1 - limbs
--2 - limbs + anti respawn
--3 - limbs + breakJoints after [loadtime] seconds
--4 - remove humanoid + breakJoints
--5 - remove humanoid + limbs
local alignmode = 3 --AlignPosition mode
--modes:
--1 - AlignPosition rigidity enabled true
--2 - 2 AlignPositions rigidity enabled both true and false
--3 - AlignPosition rigidity enabled false

healthHide = healthHide and ((method == 0) or (method == 2) or (method == 000)) and gp(c, "Head", "BasePart")

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = v3(0, 0, 0)
local inf = math.huge

local c = lp.Character

if not (c and c.Parent) then
	return
end

c.Destroying:Connect(function()
	c = nil
end)

local function gp(parent, name, className)
	if typeof(parent) == "Instance" then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end

local function align(Part0, Part1)
	Part0.CustomPhysicalProperties = PhysicalProperties.new(0.0001, 0.0001, 0.0001, 0.0001, 0.0001)

	local att0 = Instance.new("Attachment", Part0)
	att0.Orientation = v3_0
	att0.Position = v3_0
	att0.Name = "att0_" .. Part0.Name
	local att1 = Instance.new("Attachment", Part1)
	att1.Orientation = v3_0
	att1.Position = v3_0
	att1.Name = "att1_" .. Part1.Name

	if (alignmode == 1) or (alignmode == 2) then
		local ape = Instance.new("AlignPosition", att0)
		ape.ApplyAtCenterOfMass = false
		ape.MaxForce = inf
		ape.MaxVelocity = inf
		ape.ReactionForceEnabled = false
		ape.Responsiveness = 200
		ape.Attachment1 = att1
		ape.Attachment0 = att0
		ape.Name = "AlignPositionRtrue"
		ape.RigidityEnabled = true
	end

	if (alignmode == 2) or (alignmode == 3) then
		local apd = Instance.new("AlignPosition", att0)
		apd.ApplyAtCenterOfMass = false
		apd.MaxForce = inf
		apd.MaxVelocity = inf
		apd.ReactionForceEnabled = false
		apd.Responsiveness = 200
		apd.Attachment1 = att1
		apd.Attachment0 = att0
		apd.Name = "AlignPositionRfalse"
		apd.RigidityEnabled = false
	end

	local ao = Instance.new("AlignOrientation", att0)
	ao.MaxAngularVelocity = inf
	ao.MaxTorque = inf
	ao.PrimaryAxisOnly = false
	ao.ReactionTorqueEnabled = false
	ao.Responsiveness = 200
	ao.Attachment1 = att1
	ao.Attachment0 = att0
	ao.RigidityEnabled = false

	if type(getNetlessVelocity) == "function" then
	    local realVelocity = v3_0
        local steppedcon = stepped:Connect(function()
            Part0.Velocity = realVelocity
        end)
        local heartbeatcon = heartbeat:Connect(function()
            realVelocity = Part0.Velocity
            Part0.Velocity = getNetlessVelocity(realVelocity)
        end)
        Part0.Destroying:Connect(function()
            Part0 = nil
            steppedcon:Disconnect()
            heartbeatcon:Disconnect()
        end)
    end
end

local function respawnrequest()
	local ccfr = ws.CurrentCamera.CFrame
	local c = lp.Character
	lp.Character = nil
	lp.Character = c
	local con = nil
	con = ws.CurrentCamera.Changed:Connect(function(prop)
	    if (prop ~= "Parent") and (prop ~= "CFrame") then
	        return
	    end
	    ws.CurrentCamera.CFrame = ccfr
	    con:Disconnect()
    end)
end

local destroyhum = (method == 4) or (method == 5)
local breakjoints = (method == 0) or (method == 4)
local antirespawn = (method == 0) or (method == 2) or (method == 3)

hatcollide = hatcollide and (method == 0)

addtools = addtools and gp(lp, "Backpack", "Backpack")

local fenv = getfenv()
local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.set_simulation_rad or fenv.setsimulationrad

if shp and (simradius == "shp") then
	spawn(function()
		while c and heartbeat:Wait() do
			shp(lp, "SimulationRadius", inf)
		end
	end)
elseif ssr and (simradius == "ssr") then
	spawn(function()
		while c and heartbeat:Wait() do
			ssr(inf)
		end
	end)
end

antiragdoll = antiragdoll and function(v)
	if v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
		v.Parent = nil
	end
end

if antiragdoll then
	for i, v in pairs(c:GetDescendants()) do
		antiragdoll(v)
	end
	c.DescendantAdded:Connect(antiragdoll)
end

if antirespawn then
	respawnrequest()
end

if method == 0 then
	wait(loadtime)
	if not c then
		return
	end
end

if discharscripts then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("LocalScript") then
			v.Disabled = true
		end
	end
elseif newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate and (not animate.Disabled) then
		animate.Disabled = true
	else
		newanimate = false
	end
end

if addtools then
	for i, v in pairs(addtools:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = c
		end
	end
end

pcall(function()
	settings().Physics.AllowSleep = false
	settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
end)

local OLDscripts = {}

for i, v in pairs(c:GetDescendants()) do
	if v.ClassName == "Script" then
		table.insert(OLDscripts, v)
	end
end

local scriptNames = {}

for i, v in pairs(c:GetDescendants()) do
	if v:IsA("BasePart") then
		local newName = tostring(i)
		local exists = true
		while exists do
			exists = false
			for i, v in pairs(OLDscripts) do
				if v.Name == newName then
					exists = true
				end
			end
			if exists then
				newName = newName .. "_"    
			end
		end
		table.insert(scriptNames, newName)
		Instance.new("Script", v).Name = newName
	end
end

c.Archivable = true
local hum = c:FindFirstChildOfClass("Humanoid")
if hum then
	for i, v in pairs(hum:GetPlayingAnimationTracks()) do
		v:Stop()
	end
end
local cl = c:Clone()
if hum and humState16 then
    hum:ChangeState(Enum.HumanoidStateType.Physics)
    if destroyhum then
        wait(1.6)
    end
end
if hum and hum.Parent and destroyhum then
    hum:Destroy()
end

if not c then
    return
end

local head = gp(c, "Head", "BasePart")
local torso = gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")
if hatcollide and c:FindFirstChildOfClass("Tool") then
    local anything = c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script")
    if not (torso and root and anything) then
        return
    end
    --torso:Destroy()
    --root:Destroy()
    if shp then
        for i,v in pairs(c:GetChildren()) do
            if v:IsA("Tools") then
                shp(v, "BackendAccoutrementState", 0)
            end 
        end
    end
    --anything:Destroy()
    if head then
        
    end
end

for i, v in pairs(cl:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
		v.Anchored = false
	end
end

local model = Instance.new("Model", c)
model.Name = model.ClassName

model.Destroying:Connect(function()
	model = nil
end)

for i, v in pairs(c:GetChildren()) do
	if v ~= model then
		if addtools and v:IsA("Tool") then
			for i1, v1 in pairs(v:GetDescendants()) do
				if v1 and v1.Parent and v1:IsA("BasePart") then
					local bv = Instance.new("BodyVelocity", v1)
					bv.Velocity = v3_0
					bv.MaxForce = v3(1000, 1000, 1000)
					bv.P = 1250
					bv.Name = "bv_" .. v.Name
				end
			end
		end
		v.Parent = model
	end
end

if breakjoints then
	model:BreakJoints()
else
	if head and torso then
		for i, v in pairs(model:GetDescendants()) do
			if v:IsA("Weld") or v:IsA("Snap") or v:IsA("Glue") or v:IsA("Motor") or v:IsA("Motor6D") then
				local save = false
				if (v.Part0 == torso) and (v.Part1 == head) then
					save = true
				end
				if (v.Part0 == head) and (v.Part1 == torso) then
					save = true
				end
				if save then
					if hedafterneck then
						hedafterneck = v
					end
				else
					v:Destroy()
				end
			end
		end
	end
	if method == 3 then
		spawn(function()
			wait(loadtime)
			if model then
				model:BreakJoints()
			end
		end)
	end
end

cl.Parent = c
for i, v in pairs(cl:GetChildren()) do
	v.Parent = c
end
cl:Destroy()

local modelDes = {}
for i, v in pairs(model:GetDescendants()) do
	if v:IsA("BasePart") then
		i = tostring(i)
		v.Destroying:Connect(function()
			modelDes[i] = nil
		end)
		modelDes[i] = v
	end
end
local modelcolcon = nil
local function modelcolf()
	if model then
		for i, v in pairs(modelDes) do
			v.CanCollide = false
		end
	else
		modelcolcon:Disconnect()
	end
end
modelcolcon = stepped:Connect(modelcolf)
modelcolf()

for i, scr in pairs(model:GetDescendants()) do
	if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
		local Part0 = scr.Parent
		if Part0:IsA("BasePart") then
			for i1, scr1 in pairs(c:GetDescendants()) do
				if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
					local Part1 = scr1.Parent
					if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
						align(Part0, Part1)
						break
					end
				end
			end
		end
	end
end

if (typeof(hedafterneck) == "Instance") and head then
	local aligns = {}
	local con = nil
	con = hedafterneck.Changed:Connect(function(prop)
	    if (prop == "Parent") and not hedafterneck.Parent then
	        con:Disconnect()
    		for i, v in pairs(aligns) do
    			v.Enabled = true
    		end
		end
	end)
	for i, v in pairs(head:GetDescendants()) do
		if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
			i = tostring(i)
			aligns[i] = v
			v.Destroying:Connect(function()
			    aligns[i] = nil
			end)
			v.Enabled = false
		end
	end
end

for i, v in pairs(c:GetDescendants()) do
	if v and v.Parent then
		if v.ClassName == "Script" then
			if table.find(scriptNames, v.Name) then
				v:Destroy()
			end
		elseif not v:IsDescendantOf(model) then
			if v:IsA("Decal") then
				v.Transparency = 1
			elseif v:IsA("ForceField") then
				v.Visible = false
			elseif v:IsA("Sound") then
				v.Playing = false
			elseif v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") then
				v.Enabled = false
			end
		end
	end
end

if newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate then
		animate.Disabled = false
	end
end

if addtools then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = addtools
		end
	end
end

local hum0 = model:FindFirstChildOfClass("Humanoid")
if hum0 then
    hum0.Destroying:Connect(function()
        hum0 = nil
    end)
end

local hum1 = c:FindFirstChildOfClass("Humanoid")
if hum1 then
    hum1.Destroying:Connect(function()
        hum1 = nil
    end)
end

if hum1 then
	ws.CurrentCamera.CameraSubject = hum1
	local camSubCon = nil
	local function camSubFunc()
		camSubCon:Disconnect()
		if c and hum1 then
			ws.CurrentCamera.CameraSubject = hum1
		end
	end
	camSubCon = renderstepped:Connect(camSubFunc)
	if hum0 then
		hum0.Changed:Connect(function(prop)
			if hum1 and (prop == "Jump") then
				hum1.Jump = hum0.Jump
			end
		end)
	else
		respawnrequest()
	end
end

local rb = Instance.new("BindableEvent", c)
rb.Event:Connect(function()
	rb:Destroy()
	sg:SetCore("ResetButtonCallback", true)
	if destroyhum then
		c:BreakJoints()
		return
	end
	if hum0 and (hum0.Health > 0) then
		model:BreakJoints()
		hum0.Health = 0
	end
	if antirespawn then
	    respawnrequest()
	end
end)
sg:SetCore("ResetButtonCallback", rb)

spawn(function()
	while c do
		if hum0 and hum1 then
			hum1.Jump = hum0.Jump
		end
		wait()
	end
	sg:SetCore("ResetButtonCallback", true)
end)

R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
if R15toR6 then
    local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
	if part then
	    local cfr = part.CFrame
		local R6parts = { 
			head = {
				Name = "Head",
				Size = v3(2, 1, 1),
				R15 = {
					Head = 0
				}
			},
			torso = {
				Name = "Torso",
				Size = v3(2, 2, 1),
				R15 = {
					UpperTorso = 0.2,
					LowerTorso = -0.7
				}
			},
			root = {
				Name = "HumanoidRootPart",
				Size = v3(2, 2, 1),
				R15 = {
					HumanoidRootPart = 0
				}
			},
			leftArm = {
				Name = "Left Arm",
				Size = v3(1, 2, 1),
				R15 = {
					LeftHand = -0.7,
					LeftLowerArm = -0.2,
					LeftUpperArm = 0.4
				}
			},
			rightArm = {
				Name = "Right Arm",
				Size = v3(1, 2, 1),
				R15 = {
					RightHand = -0.7,
					RightLowerArm = -0.2,
					RightUpperArm = 0.4
				}
			},
			leftLeg = {
				Name = "Left Leg",
				Size = v3(1, 2, 1),
				R15 = {
					LeftFoot = -0.7,
					LeftLowerLeg = -0.15,
					LeftUpperLeg = 0.6
				}
			},
			rightLeg = {
				Name = "Right Leg",
				Size = v3(1, 2, 1),
				R15 = {
					RightFoot = -0.7,
					RightLowerLeg = -0.15,
					RightUpperLeg = 0.6
				}
			}
		}
		for i, v in pairs(c:GetChildren()) do
			if v:IsA("BasePart") then
				for i1, v1 in pairs(v:GetChildren()) do
					if v1:IsA("Motor6D") then
						v1.Part0 = nil
					end
				end
			end
		end
		part.Archivable = true
		for i, v in pairs(R6parts) do
			local part = part:Clone()
			part:ClearAllChildren()
			part.Name = v.Name
			part.Size = v.Size
			part.CFrame = cfr
			part.Anchored = false
			part.Transparency = 1
			part.CanCollide = false
			for i1, v1 in pairs(v.R15) do
				local R15part = gp(c, i1, "BasePart")
				local att = gp(R15part, "att1_" .. i1, "Attachment")
				if R15part then
					local weld = Instance.new("Weld", R15part)
					weld.Name = "Weld_" .. i1
					weld.Part0 = part
					weld.Part1 = R15part
					weld.C0 = cf(0, v1, 0)
					weld.C1 = cf(0, 0, 0)
					R15part.Massless = true
					R15part.Name = "R15_" .. i1
					R15part.Parent = part
					if att then
						att.Parent = part
						att.Position = v3(0, v1, 0)
					end
				end
			end
			part.Parent = c
			R6parts[i] = part
		end
		local R6joints = {
			neck = {
				Parent = R6parts.torso,
				Name = "Neck",
				Part0 = R6parts.torso,
				Part1 = R6parts.head,
				C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rootJoint = {
				Parent = R6parts.root,
				Name = "RootJoint" ,
				Part0 = R6parts.root,
				Part1 = R6parts.torso,
				C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rightShoulder = {
				Parent = R6parts.torso,
				Name = "Right Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightArm,
				C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftShoulder = {
				Parent = R6parts.torso,
				Name = "Left Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.leftArm,
				C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			},
			rightHip = {
				Parent = R6parts.torso,
				Name = "Right Hip",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightLeg,
				C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftHip = {
				Parent = R6parts.torso,
				Name = "Left Hip" ,
				Part0 = R6parts.torso,
				Part1 = R6parts.leftLeg,
				C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			}
		}
		for i, v in pairs(R6joints) do
			local joint = Instance.new("Motor6D")
			for prop, val in pairs(v) do
				joint[prop] = val
			end
			R6joints[i] = joint
		end
		hum1.RigType = Enum.HumanoidRigType.R6
		hum1.HipHeight = 0
	end
end

local v = "Tool"


--find rig joints

local function fakemotor()
    return {C0=cf(), C1=cf()}
end

local torso = gp(c, "Torso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")

local neck = gp(torso, "Neck", "Motor6D")
neck = neck or fakemotor()

local rootJoint = gp(root, "RootJoint", "Motor6D")
rootJoint = rootJoint or fakemotor()

local leftShoulder = gp(torso, "Left Shoulder", "Motor6D")
leftShoulder = leftShoulder or fakemotor()

local rightShoulder = gp(torso, "Right Shoulder", "Motor6D")
rightShoulder = rightShoulder or fakemotor()

local leftHip = gp(torso, "Left Hip", "Motor6D")
leftHip = leftHip or fakemotor()

local rightHip = gp(torso, "Right Hip", "Motor6D")
rightHip = rightHip or fakemotor()

--120 fps

local fps = 60
local event = Instance.new("BindableEvent", c)
event.Name = "120 fps"
local floor = math.floor
fps = 1 / fps
local tf = 0
local con = nil
con = game:GetService("RunService").RenderStepped:Connect(function(s)
	if not c then
		con:Disconnect()
		return
	end
    --tf += s
	if tf >= fps then
		for i=1, floor(tf / fps) do
			event:Fire(c)
		end
		tf = 0
	end
end)
local event = event.Event

local hedrot = v3(0, 5, 0)

local uis = game:GetService("UserInputService")
local function isPressed(key)
    return (not uis:GetFocusedTextBox()) and uis:IsKeyDown(Enum.KeyCode[key])
end

local biggesthandle = nil
for i, v in pairs(c:GetChildren()) do
    if v:IsA("Tool") then
        local handle = gp(v, "Handle", "BasePart")
        if biggesthandle then
            if biggesthandle.Size.Magnitude < handle.Size.Magnitude then
                biggesthandle = handle
            end
        else
            biggesthandle = gp(v, "Handle", "BasePart")
        end
    end
end

if not biggesthandle then
    return
end

local handle1 = gp(gp(model, biggesthandle.Parent.Name, "Tool"), "Handle", "BasePart")
if not handle1 then
    return
end

handle1.Destroying:Connect(function()
    handle1 = nil
end)
biggesthandle.Destroying:Connect(function()
    biggesthandle = nil
end)

biggesthandle:BreakJoints()
biggesthandle.Anchored = true

for i, v in pairs(handle1:GetDescendants()) do
    if v:IsA("AlignOrientation") then
        v.Enabled = false
    end
end

local mouse = lp:GetMouse()
local fling = false
mouse.Button1Down:Connect(function()
    fling = true
end)
mouse.Button1Up:Connect(function()
    fling = false
end)

omgHuman = game.Players.LocalPlayer.Character.HumanoidRootPart
UselessPartLmao = Instance.new("Part", omgHuman)
UselessPartLmao.Name = "life fucking sucks and i wanna jump off a bridge"
UselessPartLmao.CanCollide = false
UselessPartLmao.Transparency = 1

well = Instance.new("Weld", UselessPartLmao)
well.Name = "Lois family guy"
well.Part0 = UselessPartLmao
well.Part1 = omgHuman
well.C0 = cf(0, 12.5, 0)
well.C1 = cf(0, 0, 0)

local function doForSignal(signal, vel)
    spawn(function()
        while signal:Wait() and c and handle1 and biggesthandle do
            if fling == true and mouse.Target then
                biggesthandle.Position = mouse.Hit.Position
            end
            if fling == false then
                biggesthandle.Position = UselessPartLmao.Position
            end
            handle1.RotVelocity = Vector3.new(9999999,9999999,9999999)
        end
    end)
end
doForSignal(stepped, v3(0, 0, 0))
doForSignal(renderstepped, v3(0, 0, 0))
doForSignal(heartbeat, v3(200000000000000000000000000000, 200000000000000000000000000000, 200000000000000000000000000000))
--Hat1

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = Vector3.zero
local inf = math.huge

local cplayer = lp.Character

local v3 = Vector3.new

local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
        for i, v in pairs(parent:GetChildren()) do
            if (v.Name == name) and v:IsA(className) then
                return v
            end
        end
    end
    return nil
end

 
 
local hat2 = gp(cplayer, "Tetra-Suit", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Torso"] --any part of humanoid
att2.Position = Vector3.new(-0, 0, 0)
att2.Rotation = Vector3.new(0, 0, -0)--you can delete this 


local hat2 = gp(cplayer, "Extra Left hand (Blocky)_white", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Left Arm"]
att2.Position = Vector3.new(-0, -0, -0)
att2.Rotation = Vector3.new(-110, -0, 0)

local hat2 = gp(cplayer, "Extra Right hand (Blocky)_white", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Arm"]
att2.Position = Vector3.new(-0, -0, 0)
att2.Rotation = Vector3.new(-110, 0, -0) --LavanderHair

local hat2 = gp(cplayer, "dummyhead", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Leg"]
att2.Position = Vector3.new(-0, -0.25, 0) --Robloxclassicred
att2.Rotation = Vector3.new(90, 90, 0)

local hat2 = gp(cplayer, "RectangleHead", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Left Leg"]
att2.Position = Vector3.new(-0, -0.25, 0)
att2.Rotation = Vector3.new(90, -90, 0)
 
 local omgitskorn =  Instance.new("Highlight")  
omgitskorn.Parent = handle1


game.Players.LocalPlayer.Character.Head.Anchored = false
 
  
 
  

pcalle = pcall

caughterrors = {}

function pcallo(dd)
	local eje,errorr = pcalle(dd)
	if not eje and not caughterrors[errorr] then
		print(errorr)
		caughterrors[errorr] = true
	end
	return eje,errorr
end

pcall = pcallo
cammove = false -------Change this to true for the proper & better camera movement for third person.

wait(1/60)
warn([[
Derpz Glitcher: The Final Chapter
Started 28/10/2020 17:42
This is the finale for the series. If this ever gets leaked, Please know there will be no more after this.
I got bored. I really got bored with this. Please enjoy the final in the derpz glitcher series. I might make a spinoff after this is done...
But for now, This is the last one. DGV1, DGV2, DGV3, DGV4 & 4.5, DGV5, DGS, DS, DG:TR, DG:UC, And now, DG:TLC.
I hope you enjoy.
Yours Sincerely,
Derpz.
	By DerpzDeNugget_YT.
	WACKYEFFECT by Shackluster
	Several assets from Lunnekoo, Footplanting (but slightly edited) by KnottyEeveez.
	FE Convert by Melon
	Converted effects to CR by KnottyEeveez and thanks to M O A I because he made the damn og script for CR effects
]])

plr = game:GetService("Players").LocalPlayer
Player = plr
mouse = plr:GetMouse()
cam = game.Workspace.CurrentCamera
cam.CameraType = "Custom"
if cammove == true then
	script.CameraMovement.Disabled = false
elseif cammove == false then

end
MorphedInto = "Ryan" 
local throwhitsounds = {1428541279,1428541279,200632136,199145146}
char = plr.Character
Character = char
hum = char.Humanoid
Humanoid = hum
t = char.Torso
Torso = t
h = char.Head
Head = h
tors = Torso
lleg = char["Left Leg"]
root = char.HumanoidRootPart
RootPart = root
hed = h
rleg = char["Right Leg"]
rarm = char["Right Arm"]
larm = char["Left Arm"]
local RightShoulderC0 = CFrame.new(0,0,0)
local LeftShoulderC0 = CFrame.new(0,0,0)
--Above is for Emanuelecaja18's Animation Maker Compatibility
Euler = CFrame.fromEulerAnglesXYZ
vt = Vector3.new
it = Instance.new
cf = CFrame.new
Face = hed.face
muted = false
local RyansOST = Instance.new("Sound",Torso)
RyansOST.SoundId = "rbxassetid://1609244948"
RyansOST.Name = "RyansOST"
RyansOST.Volume = 2
RyansOST.Pitch = 1.03
RyansOST.Looped = true
RyansOST:Play()
local sleepymusic = Instance.new("Sound",char.Head)
sleepymusic.SoundId = "rbxassetid://328340676"
sleepymusic.Name = "sleepymusic"
sleepymusic.Volume = 2
sleepymusic.Pitch = 1
sleepymusic.Looped = true
sleepymusic:Play()
sleepymusic:Pause()
script.Main.VisFrame.Visualiser.Disabled = false
print("Creating arm")
local ArmModel = Instance.new("Model",char)
local MainPart = Instance.new("Part",ArmModel)
MainPart.Anchored = true
MainPart.Material = Enum.Material.ForceField
MainPart.Size = Vector3.new(1, 2, 1)
MainPart.Position = Vector3.new(-171.027, 1, -79.291)
MainPart.Orientation = Vector3.new(0,0,0)
MainPart.Transparency = 1
MainPart.Color = Color3.fromRGB(163, 162, 165)
local Part = Instance.new("Part",ArmModel)
Part.Anchored = true
Part.Material = Enum.Material.Glass
Part.Size = Vector3.new(1.05, 0.19, 1.05)
Part.Transparency = 0.35
Part.Position = Vector3.new(-171.027, 1.76, -79.291)
Part.Orientation = Vector3.new(0,0,0)
Part.Color = Color3.fromRGB(223, 223, 222)
local Part = Instance.new("Part",ArmModel)
Part.Anchored = true
Part.Material = Enum.Material.DiamondPlate
Part.Transparency = 0
Part.Position = Vector3.new(-171.027, 0.53, -79.291)
Part.Orientation = Vector3.new(0,0,0)
Part.Size = Vector3.new(1.01, 0.3, 1.01)
Part.Color = Color3.fromRGB(17,17,17)
local Part = Instance.new("Part",ArmModel)
Part.Anchored = true
Part.Material = Enum.Material.DiamondPlate
Part.Transparency = 0
Part.Position = Vector3.new(-171.027, 1.76, -79.291)
Part.Orientation = Vector3.new(0,0,0)
Part.Size = Vector3.new(1.01, 0.3, 1.01)
Part.Color = Color3.fromRGB(17,17,17)
local Part = Instance.new("Part",ArmModel)
Part.Anchored = true
Part.Material = Enum.Material.DiamondPlate
Part.Transparency = 0
Part.Position = Vector3.new(-171.027, 0.53, -79.291)
Part.Orientation = Vector3.new(0,0,0)
Part.Size = Vector3.new(1.02, 0.2, 1.02)
Part.Color = Color3.fromRGB(223, 223, 222)
local Part = Instance.new("Part",ArmModel)
Part.Anchored = true
Part.Material = Enum.Material.DiamondPlate
Part.Transparency = 0
Part.Position = Vector3.new(-171.027, 1.76, -79.291)
Part.Orientation = Vector3.new(0,0,0)
Part.Size = Vector3.new(1.02, 0.2, 1.02)
Part.Color = Color3.fromRGB(223, 223, 222)
local Part = Instance.new("Part",ArmModel)
Part.Anchored = true
Part.Material = Enum.Material.Glass
Part.Size = Vector3.new(1.05, 0.19, 1.05)
Part.Transparency = 0.35
Part.Position = Vector3.new(-171.027, 0.53, -79.291)
Part.Orientation = Vector3.new(0,0,0)
Part.Color = Color3.fromRGB(223, 223, 222)
local Part = Instance.new("WedgePart",ArmModel)
Part.Anchored = true
Part.Material = Enum.Material.DiamondPlate
Part.Size = Vector3.new(0.058, 0.326, 0.151)
Part.Transparency = 0
Part.Position = Vector3.new(-170.501, 0.953, -79.386)
Part.Orientation = Vector3.new(0, 0, 180)
Part.Color = Color3.fromRGB(27, 42, 53)
local Part = Instance.new("WedgePart",ArmModel)
Part.Anchored = true
Part.Material = Enum.Material.DiamondPlate
Part.Size = Vector3.new(0.058, 0.326, 0.151)
Part.Transparency = 0
Part.Position = Vector3.new(-170.501, 1.267, -79.386)
Part.Orientation = Vector3.new(0, 0, 0)
Part.Color = Color3.fromRGB(27, 42, 53)
local Part = Instance.new("WedgePart",ArmModel)
Part.Anchored = true
Part.Material = Enum.Material.DiamondPlate
Part.Size = Vector3.new(0.058, 0.326, 0.151)
Part.Transparency = 0
Part.Position = Vector3.new(-171.555, 1.267, -79.234)
Part.Orientation = Vector3.new(0, 180, 0)
Part.Color = Color3.fromRGB(27, 42, 53)
local Part = Instance.new("WedgePart",ArmModel)
Part.Anchored = true
Part.Material = Enum.Material.DiamondPlate
Part.Size = Vector3.new(0.058, 0.326, 0.151)
Part.Transparency = 0
Part.Position = Vector3.new(-170.501, 0.953, -79.234)
Part.Orientation = Vector3.new(0, 180, 180)
Part.Color = Color3.fromRGB(27, 42, 53)
local Part = Instance.new("WedgePart",ArmModel)
Part.Anchored = true
Part.Material = Enum.Material.DiamondPlate
Part.Size = Vector3.new(0.058, 0.326, 0.151)
Part.Transparency = 0
Part.Position = Vector3.new(-171.555, 0.953, -79.386)
Part.Orientation = Vector3.new(0, 0, 180)
Part.Color = Color3.fromRGB(27, 42, 53)
local Part = Instance.new("WedgePart",ArmModel)
Part.Anchored = true
Part.Material = Enum.Material.DiamondPlate
Part.Size = Vector3.new(0.058, 0.326, 0.151)
Part.Transparency = 0
Part.Position = Vector3.new(-170.521, 1.267, -79.234)
Part.Orientation = Vector3.new(0, 180, 0)
Part.Color = Color3.fromRGB(27, 42, 53)
local Part = Instance.new("WedgePart",ArmModel)
Part.Anchored = true
Part.Material = Enum.Material.DiamondPlate
Part.Size = Vector3.new(0.058, 0.326, 0.151)
Part.Transparency = 0
Part.Position = Vector3.new(-171.555, 0.953, -79.234)
Part.Orientation = Vector3.new(0, 180, 180)
Part.Color = Color3.fromRGB(27, 42, 53)
local Part = Instance.new("WedgePart",ArmModel)
Part.Anchored = true
Part.Material = Enum.Material.DiamondPlate
Part.Size = Vector3.new(0.058, 0.326, 0.151)
Part.Transparency = 0
Part.Position = Vector3.new(-171.555, 1.267, -79.386)
Part.Orientation = Vector3.new(0, 0, 0)
Part.Color = Color3.fromRGB(27, 42, 53)
local Neon = Instance.new("Part",ArmModel)
Neon.Anchored = true
Neon.Material = Enum.Material.Neon
Neon.Size = Vector3.new(1.04, 0.15, 1.04)
Neon.Transparency = 0
Neon.Position = Vector3.new(-171.027, 0.53, -79.291)
Neon.Orientation = Vector3.new(0, 0, 0)
Neon.Color = Color3.fromRGB(255,0,25)
local Neon = Instance.new("Part",ArmModel)
Neon.Anchored = true
Neon.Material = Enum.Material.Neon
Neon.Size = Vector3.new(1.04, 0.15, 1.04)
Neon.Transparency = 0
Neon.Position = Vector3.new(-171.027, 1.76, -79.291)
Neon.Orientation = Vector3.new(0, 0, 0)
Neon.Color = Color3.fromRGB(255, 0, 25)
local Neon = Instance.new("WedgePart",ArmModel)
Neon.Anchored = true
Neon.Material = Enum.Material.Neon
Neon.Size = Vector3.new(0.05, 0.28, 0.13)
Neon.Transparency = 0
Neon.Position = Vector3.new(-171.575, 0.97, -79.375)
Neon.Orientation = Vector3.new(0, 0, 180)
Neon.Color = Color3.fromRGB(255, 0, 25)
local Neon = Instance.new("WedgePart",ArmModel)
Neon.Anchored = true
Neon.Material = Enum.Material.Neon
Neon.Size = Vector3.new(0.05, 0.28, 0.13)
Neon.Transparency = 0
Neon.Position = Vector3.new(-170.481, 1.24, -79.375)
Neon.Orientation = Vector3.new(0, 0, 0)
Neon.Color = Color3.fromRGB(255, 0, 25)
local Neon = Instance.new("WedgePart",ArmModel)
Neon.Anchored = true
Neon.Material = Enum.Material.Neon
Neon.Size = Vector3.new(0.05, 0.28, 0.13)
Neon.Transparency = 0
Neon.Position = Vector3.new(-171.575, 0.97, -79.245)
Neon.Orientation = Vector3.new(0, 180, 180)
Neon.Color = Color3.fromRGB(255, 0, 25)
local Neon = Instance.new("WedgePart",ArmModel)
Neon.Anchored = true
Neon.Material = Enum.Material.Neon
Neon.Size = Vector3.new(0.05, 0.28, 0.13)
Neon.Transparency = 0
Neon.Position = Vector3.new(-171.575, 1.24, -79.375)
Neon.Orientation = Vector3.new(0, 0, 0)
Neon.Color = Color3.fromRGB(255, 0, 25)
local Neon = Instance.new("WedgePart",ArmModel)
Neon.Anchored = true
Neon.Material = Enum.Material.Neon
Neon.Size = Vector3.new(0.05, 0.28, 0.13)
Neon.Transparency = 0
Neon.Position = Vector3.new(-170.481, 0.97, -79.375)
Neon.Orientation = Vector3.new(0, 0, 180)
Neon.Color = Color3.fromRGB(255, 0, 25)
local Neon = Instance.new("WedgePart",ArmModel)
Neon.Anchored = true
Neon.Material = Enum.Material.Neon
Neon.Size = Vector3.new(0.05, 0.28, 0.13)
Neon.Transparency = 0
Neon.Position = Vector3.new(-170.481, 1.24, -79.245)
Neon.Orientation = Vector3.new(0, 180, 0)
Neon.Color = Color3.fromRGB(255, 0, 25)
local Neon = Instance.new("WedgePart",ArmModel)
Neon.Anchored = true
Neon.Material = Enum.Material.Neon
Neon.Size = Vector3.new(0.05, 0.28, 0.13)
Neon.Transparency = 0
Neon.Position = Vector3.new(-170.481, 0.97, -79.245)
Neon.Orientation = Vector3.new(0, 180, 180)
Neon.Color = Color3.fromRGB(255, 0, 25)
local Neon = Instance.new("WedgePart",ArmModel)
Neon.Anchored = true
Neon.Material = Enum.Material.Neon
Neon.Size = Vector3.new(0.05, 0.28, 0.13)
Neon.Transparency = 0
Neon.Position = Vector3.new(-171.575, 1.24, -79.245)
Neon.Orientation = Vector3.new(0, 180, 0)
Neon.Color = Color3.fromRGB(255, 0, 25)
local ArmModelEnd = Instance.new("Part",ArmModel)
ArmModelEnd.Anchored = true
ArmModelEnd.Size = Vector3.new(0.05,0.05,0.05)
ArmModelEnd.Transparency = 1
ArmModelEnd.CanCollide = false
ArmModelEnd.Position = Vector3.new(-171.027, -0.58, -79.291)
ArmModelEnd.Orientation = Vector3.new(0, 0, 0)
ArmModelEnd.Color = Color3.fromRGB(27, 42, 53)
for _,i in pairs(ArmModel:GetChildren()) do
	local Weld = Instance.new("WeldConstraint",i)
	Weld.Part0 = i
	Weld.Part1 = MainPart
	i.Anchored = false
end
ManThemeColor = Color3.new(0,0,0)
MainPart.CFrame = char:WaitForChild("Right Arm").CFrame
local WeldS = Instance.new("WeldConstraint",MainPart)
WeldS.Part0 = char:WaitForChild("Right Arm")
WeldS.Part1 = MainPart
spawn(function()
	while ArmModel.Parent~=nil or ArmModel~=nil do
		for _,i in pairs(ArmModel:GetChildren()) do
			if i.Material == Enum.Material.Neon then
				i.Color = ManThemeColor
			end
		end
		wait()
	end
end)
print("Arm gauntlet creation done")
local RK = script.RealKnife
local RKWeld = Instance.new("Weld",RK)
RKWeld.Part0 = RK.Main
RKWeld.Part1 = rarm
RKWeld.C0 = CFrame.new(0,0,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
--Stupid transparency func
for i,v in pairs(RK:GetChildren()) do
	if v.Name ~= "Weld" then
		v.Anchored = false
	end
end

--Face changing functions
local DabKick = "MY EYES JUST DIED CAUSE OF CRINGE AAAAAA"
--Derpz (And some others') Faces
function Bored() --hhh..
Face.Texture = "http://www.roblox.com/asset/?id=4611467856"
end
function Neutral() --okthen
Face.Texture = "rbxassetid://2755423294"
end
function Upset() --cri
Face.Texture = "http://www.roblox.com/asset/?id=4611468085"
end
function Happy() --HHHHHHHHHHHHHHHHHHHHHHHH
Face.Texture = "http://www.roblox.com/asset/?id=4611484914"
end
function Determined() --It'S NOt oVEr uNtIl iT'S OveR
	Face.Texture = "rbxassetid://2755480100"
end
function Insane() --hahahhahah
	Face.Texture = "http://www.roblox.com/asset/?id=4611467568"
end
function Sleeping() --Yes, I did make a sleeping face.
	Face.Texture = "rbxassetid://3009289203"
end
function HappyMemey() --c:
	Face.Texture = "rbxassetid://3988001776"
end
function Shocked() --JESUS CHRIST WHAT THE HELL IS THAT DEAD BODY DOING ON THE FLOOR
	Face.Texture = "http://www.roblox.com/asset/?id=4365795547"
end
function die() --die
	Face.Texture = "rbxassetid://4821072198"
end
--rbxassetid://4821072198
--Jake_D Faces (If the script is about them)
function JakeNeutral() --meh.
Face.Texture = "rbxassetid://3557021423"
end
function JakeUpset() --u mak me mad >:c
Face.Texture = "rbxassetid://3557022030"
end
function JakeHappy() --help
Face.Texture = "rbxassetid://3557022523"
end
--Face changing functions

--Focus
function Focus(whatone,timebeforeend,twoplayersonly,playerone,playertwo) --Time is used in ticks, Not seconds.
					if twoplayersonly == true then
							for i,v in pairs(game:GetService("Players"):GetChildren()) do
		if script.Focus[whatone].Parent ~= nil then
			if v.Name == playerone or v.Name == playertwo then
	local var = script.Focus[whatone]:Clone()
	var.PersonName.Value = plr.Name
	var.Time.Value = timebeforeend
	var.Parent = v.PlayerGui
	var.Disabled = false
			else
				end
	end
	end
					elseif twoplayersonly == false or twoplayersonly == nil then
						

	for i,v in pairs(game:GetService("Players"):GetChildren()) do
		if script.Focus[whatone].Parent ~= nil then
			if plr.Name == "DerpzDeNugget_YT" then
	local var = script.Focus[whatone]:Clone()
		var.PersonName.Value = plr.Name
	var.Time.Value = timebeforeend
	var.Parent = v.PlayerGui
	var.Disabled = false

	end
		end
		end
	end
end
--Focus


--Camera Shake
	local NewInstance = function(instance,parent,properties)
		local inst = Instance.new(instance,parent)
		if(properties)then
			for i,v in next, properties do
				pcall(function() inst[i] = v end)
			end
		end
		return inst;
	end
FXFolder=script.Effects
function CamShake2(who,data)
	coroutine.wrap(function()
		if(FXFolder:FindFirstChild'CamShake')then
			local cam = FXFolder.CamShake:Clone()
			cam:WaitForChild'intensity'.Value = data.Intensity or 5
			cam:WaitForChild'duration'.Value = data.Duration or 5
			cam:WaitForChild'speed'.Value = data.Speed or 10;
	 		if(data.Origin)then NewInstance((typeof(data.Origin) == 'Instance' and "ObjectValue" or typeof(data.Origin) == 'Vector3' and 'Vector3Value' or typeof(data.Origin)=='CFrame' and 'CFrameValue'),cam,{Name='origin',Value=data.Origin}) end
			cam:WaitForChild'rot'.Value = data.Rotation or Vector3.new(1,1,5)
			cam:WaitForChild'pos'.Value = data.Position or Vector3.new(.5,.5,.5)
			cam:WaitForChild'startdist'.Value = data.DropDist or 25;
			cam:WaitForChild'enddist'.Value = data.IneffectiveDist or 150;
			
			cam.Parent = who
			wait()
			cam.Disabled = false
			wait(3)
			cam:Destroy()
		end
	end)()
end

function CamShakeAll2(data)
	for _,v in next, game:service'Players':players() do
		CamShake2(v:FindFirstChildOfClass'PlayerGui' or v:FindFirstChildOfClass'Backpack' or v.Character,data)
	end
end
--Camera Shake
--Animation Testing
function nonlerpanim(jointorweld,cframe,alpha,easestyle,easedirect)
	local info = TweenInfo.new(alpha,easestyle,easedirect,0,false,0)
	local actualanim = game:GetService("TweenService"):Create(jointorweld,info,{C0=cframe})
	actualanim:Play()
	return actualanim
end
function Animate(jointorweld,cframe,alpha,easestyle,easedirect)
	local info = TweenInfo.new(alpha,easestyle,easedirect,0,false,0)
	local actualanim = game:GetService("TweenService"):Create(jointorweld,info,{C0=cframe})
	actualanim:Play()
	return actualanim
end
--stole from knotty lo
function TweenAnimate(object,Aniim,time,easingstyle,easingdirection,repet,reverse,deelay)
	local infos=TweenInfo.new(time,Enum.EasingStyle[easingstyle],Enum.EasingDirection[easingdirection],repet,reverse,deelay)
	local tween=game:GetService("TweenService"):Create(object,infos,Aniim)
	tween:Play()
	return tween
end
function TweenAnimate2(object,Aniim,time,easingstyle,easingdirection,repet,reverse,deelay)
	local infos=TweenInfo.new(time or (20/60),Enum.EasingStyle[easingstyle or "Linear"],Enum.EasingDirection[easingdirection or "InOut"],repet or 0,reverse or false,deelay or 0)
	local tween=game:GetService("TweenService"):Create(object,infos,Aniim)
	tween:Play()
	return tween
end

function LocalTweenAnimate(object,Aniim,time,easingstyle,easingdirection,repet,reverse,deelay)
	script.LocalTweenyThing:InvokeClient(Player,object,Aniim,time,easingstyle,easingdirection,repet,reverse,deelay)
end
--Animation Testing


--Morphs

-----------------Ryan_L-----------------
lol = script.Ryan_LMorph["morph (Ryan.)"] lol.Name = "morph (Ryan.) for "..plr.Name lol.Parent = game:GetService("ServerStorage")
local derpz = Character:GetChildren()
 
local clothesa = game:GetService("ServerStorage")["morph (Ryan.) for "..plr.Name]:Clone()
local clothes1 = clothesa:GetChildren()
 

local Ryan_LMorphLARM = script.Ryan_LMorph["L Arm"]
local finalweld3 = Instance.new("Weld",Ryan_LMorphLARM.Main)
finalweld3.Part0 = Ryan_LMorphLARM.Main
finalweld3.Part1 = larm
finalweld3.C0 = CFrame.new(0,-0.45,-0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
finalweld3.Name = "Weldiuehgiuewhguishgafgbsdgkfvjdhsagbk.sfk derpz's weld ok"
local Ryan_LMorphRARM = script.Ryan_LMorph["R Arm"]
local finalweld3 = Instance.new("Weld",Ryan_LMorphRARM.Main)
finalweld3.Part0 = Ryan_LMorphRARM.Main
finalweld3.Part1 = rarm
finalweld3.C0 = CFrame.new(0,-0.45,-0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
finalweld3.Name = "Weldiuehgiuewhguishgafgbsdgkfvjdhsagbk.sfk derpz's weld ok"
for i,v in pairs (Ryan_LMorphRARM:GetChildren()) do
	if v.Name ~= "main" then
		v.Transparency = 1
	end
end
local Ryan_LMorphLLEG = script.Ryan_LMorph["L Leg"]
local finalweld3 = Instance.new("Weld",Ryan_LMorphLLEG.Main)
finalweld3.Part0 = Ryan_LMorphLLEG.Main
finalweld3.Part1 = lleg
finalweld3.C0 = CFrame.new(0,-0.045,-0)*CFrame.Angles(math.rad(0),math.rad(180),math.rad(0))
finalweld3.Name = "Weldiuehgiuewhguishgafgbsdgkfvjdhsagbk.sfk derpz's weld ok"
local Ryan_LMorphRLEG = script.Ryan_LMorph["R Leg"]
local finalweld3 = Instance.new("Weld",Ryan_LMorphRLEG.Main)
finalweld3.Part0 = Ryan_LMorphRLEG.Main
finalweld3.Part1 = rleg
finalweld3.C0 = CFrame.new(0,-0.045,-0)*CFrame.Angles(math.rad(0),math.rad(180),math.rad(0))
finalweld3.Name = "Weldiuehgiuewhguishgafgbsdgkfvjdhsagbk.sfk derpz's weld ok"
local Ryan_LMorphTORS = script.Ryan_LMorph["Tors"]
local finalweld3 = Instance.new("Weld",Ryan_LMorphTORS.Main)
finalweld3.Part0 = Ryan_LMorphTORS.Main
finalweld3.Part1 = tors
finalweld3.C0 = CFrame.new(0,-0.03,-0)*CFrame.Angles(math.rad(0),math.rad(180),math.rad(0))
finalweld3.Name = "Weldiuehgiuewhguishgafgbsdgkfvjdhsagbk.sfk derpz's weld ok"

VisorV2 = script.Ryan_LMorph.Visor
local finalweld33 = Instance.new("Weld",VisorV2.main)
finalweld33.Part0 = VisorV2.main
finalweld33.Part1 = Head
finalweld33.C0 = CFrame.new(.5,-.17,.48)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
finalweld33.Name = "Weldiuehgiuewhguishgafgbsdgkfvjdhsagbk.sfk derpz's weld ok"
for i,v in pairs(VisorV2:GetChildren()) do
	v.Anchored = false
end


script.Ryan_LMorph.Parent = char



-----------------Ryan_L-----------------



-----------------Eyes------------------
--CFrame.new(.2,.2,-.2)
EyesFolder = script.Eyes
local finalweld3 = Instance.new("Weld",EyesFolder.LeftEye)
finalweld3.Part0 = EyesFolder.LeftEye
finalweld3.Part1 = Head
finalweld3.C0 = CFrame.new( 0.0984573364, -0.200519562, 0.586151123)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
finalweld3.C1 = CFrame.new(-0.5,0,-0.5)*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0))
finalweld3.Name = "Weldiuehgiuewhguishgafgbsdgkfvjdhsagbk.sfk derpz's weld ok"
local finalweld3 = Instance.new("Weld",EyesFolder.RightEye)
finalweld3.Part0 = EyesFolder.RightEye
finalweld3.Part1 = Head
finalweld3.C0 = CFrame.new( -0.0984573364, -0.200519562, 0.586151123)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))
finalweld3.C1 = CFrame.new(0.5,0,-0.5)*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0))
finalweld3.Name = "Weldiuehgiuewhguishgafgbsdgkfvjdhsagbk.sfk derpz's weld ok"

-----------------Eyes------------------
--Morphs

	local NewInstance = function(instance,parent,properties)
		local inst = Instance.new(instance,parent)
		if(properties)then
			for i,v in next, properties do
				pcall(function() inst[i] = v end)
			end
		end
		return inst;
	end
	MAINRUINCOLOR = BrickColor.new("Navy blue")
 
New = function(Object, Parent, Name, Data)
	local Object = Instance.new(Object)
	for Index, Value in pairs(Data or {}) do
		Object[Index] = Value
	end
	Object.Parent = Parent
	Object.Name = Name
	return Object
end



--Rainbow Effects
function boop(X)
	 return math.acos(math.cos(X*math.pi))/math.pi
	 end

counter = 0
--Rainbow Effects





function CreateParta(parent,transparency,reflectance,material,brickcolor)
local p = Instance.new("Part")
p.TopSurface = 0
p.BottomSurface = 0
p.Parent = parent
p.Size = Vector3.new(0.1,0.1,0.1)
p.Transparency = transparency
p.Reflectance = reflectance
p.CanCollide = false
p.Locked = true
p.BrickColor = brickcolor
p.Material = material
return p
end

function CreateMesh(parent,meshtype,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = meshtype
mesh.Scale = Vector3.new(x1*10,y1*10,z1*10)
return mesh
end

function CreateSpecialMesh(parent,meshid,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = "FileMesh"
mesh.MeshId = meshid
mesh.Scale = Vector3.new(x1,y1,z1)
return mesh
end


function CreateSpecialGlowMesh(parent,meshid,x1,y1,z1)
local mesh = Instance.new("SpecialMesh",parent)
mesh.MeshType = "FileMesh"
mesh.MeshId = meshid
mesh.TextureId = "http://www.roblox.com/asset/?id=269748808"
mesh.Scale = Vector3.new(x1,y1,z1)
mesh.VertexColor = Vector3.new(parent.BrickColor.r, parent.BrickColor.g, parent.BrickColor.b)
return mesh
end

function CreateWeld(parent,part0,part1,C1X,C1Y,C1Z,C1Xa,C1Ya,C1Za,C0X,C0Y,C0Z,C0Xa,C0Ya,C0Za)
local weld = Instance.new("Weld")
weld.Parent = parent
weld.Part0 = part0
weld.Part1 = part1
weld.C1 = CFrame.new(C1X,C1Y,C1Z)*CFrame.Angles(C1Xa,C1Ya,C1Za)
weld.C0 = CFrame.new(C0X,C0Y,C0Z)*CFrame.Angles(C0Xa,C0Ya,C0Za)
return weld
end


function RemoveOutlines(part)
  part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
  local Part = Create("Part")({
    Parent = Parent,
    Reflectance = Reflectance,
    Transparency = Transparency,
    CanCollide = false,
    Locked = true,
    BrickColor = BrickColor.new(tostring(BColor)),
    Name = Name,
    Size = Size,
    Material = Material
  })
  Part.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
  RemoveOutlines(Part)
  return Part
end
function CreateMesha(Mesh, Part, MeshType, MeshId, OffSet, Scale)
  local Msh = Create(Mesh)({
    Parent = Part,
    Offset = OffSet,
    Scale = Scale
  })
  if Mesh == "SpecialMesh" then
    Msh.MeshType = MeshType
    Msh.MeshId = MeshId
  end
  return Msh
end
function CreateWeld(Parent, Part0, Part1, C0, C1)
  local Weld = Create("Weld")({
    Parent = Parent,
    Part0 = Part0,
    Part1 = Part1,
    C0 = C0,
    C1 = C1
  })
  return Weld
end
Player = plr
Character=Player.Character 
PlayerGui=Player.PlayerGui 
Backpack=Player.Backpack 
Torso=Character.Torso 
Head=Character.Head 
Humanoid=Character.Humanoid
m=Instance.new('Model',Character)
LeftArm=Character["Left Arm"] 
LeftLeg=Character["Left Leg"] 
RightArm=Character["Right Arm"] 
RightLeg=Character["Right Leg"] 
LS=Torso["Left Shoulder"] 
LH=Torso["Left Hip"] 
RS=Torso["Right Shoulder"] 
RH=Torso["Right Hip"] 
Face = Head.face
Neck=Torso.Neck
it=Instance.new
attacktype=1
vt=Vector3.new
cf=CFrame.new
euler=CFrame.fromEulerAnglesXYZ
angles=CFrame.Angles
cloaked=false
necko=cf(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
necko2=cf(0, -0.5, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
LHC0=cf(-1,-1,0,-0,-0,-1,0,1,0,1,0,0)
LHC1=cf(-0.5,1,0,-0,-0,-1,0,1,0,1,0,0)
RHC0=cf(1,-1,0,0,0,1,0,1,0,-1,-0,-0)
RHC1=cf(0.5,1,0,0,0,1,0,1,0,-1,-0,-0)
RootPart=Character.HumanoidRootPart
RootJoint=RootPart.RootJoint
RootCF=euler(-1.57,0,3.14)
attack = false 
attackdebounce = false 
deb=false
equipped=true
hand=false
MMouse=nil
combo=0
mana=0
trispeed=.2
attackmode='none'
local idle=0
local Anim="Idle"
local Effects={}
local gun=false
local shoot=false
local sine = 0
local change = 1

--Lunnekoo's Arm Weld Setup 
RSH, LSH=nil, nil
RW, LW=Instance.new("Weld"), Instance.new("Weld") 
RW.Name="Right Shoulder" LW.Name="Left Shoulder"
LH=Torso["Left Hip"]
RH=Torso["Right Hip"]
TorsoColor=Torso.BrickColor
function NoOutline(Part)
Part.TopSurface,Part.BottomSurface,Part.LeftSurface,Part.RightSurface,Part.FrontSurface,Part.BackSurface = 10,10,10,10,10,10
end
ch=Character
RSH=ch.Torso["Right Shoulder"] 
LSH=ch.Torso["Left Shoulder"] 
-- 
RSH.Parent=nil 
LSH.Parent=nil 
-- 
RW.Name="Right Shoulder"
RW.Part0=ch.Torso 
RW.C0=cf(1.5, 0.5, 0)
RW.C1=cf(0, 0.5, 0) 
RW.Part1=ch["Right Arm"] 
RW.Parent=ch.Torso 
-- 
LW.Name="Left Shoulder"
LW.Part0=ch.Torso 
LW.C0=cf(-1.5, 0.5, 0)
LW.C1=cf(0, 0.5, 0) 
LW.Part1=ch["Left Arm"] 
LW.Parent=ch.Torso 

local toggleTag = true
local txt = script.GuiStuff.MainName
txt.Parent = hed
txt.Name = "NameDetect"
text = txt.Main.Text
textgr = text.UIGradient
desc = txt.Desc
desctext = desc.textie
desctextgr = desctext.UIGradient
linegr = desc.Line.UIGradient
mainfr = txt.Main
img1 = mainfr.Heckers1
img2 = mainfr.Heckers2
img3 = mainfr.Heckers3

ModeOfCharacter = "Exasperation"

--GUI STUFF
gui = script.Main
gui.Parent = plr.PlayerGui
MainFrame = gui.Main
NameOfScript = gui.NameOfScript
NameOfMode = gui.NameOfMode
SongNameTxt = MainFrame.SongName


function swait(num)
if num == 0 or num == nil then
game:GetService("RunService").Stepped:wait()
	else
		for i = 1, num do
game:GetService("RunService").Stepped:wait()
		end
	end
end


coreweld = Instance.new("Weld",tors)
core = script.Core
coreweld.Part0 = tors
coreweld.Part1 = core.Core
core.Core.Anchored = false
coreweld.C1 = CFrame.new(0,1.5,-1.2)*angles(math.rad(90),math.rad(0),math.rad(0))
LetterDW = core.Core.D
LetterDW.C0 = CFrame.new(0,0,0)*angles(math.rad(-90),math.rad(0),math.rad(180))
LetterDW.C1 = CFrame.new(0,0,0)
core1weld = core.Core.Color1b
core1weld.C0 = CFrame.new(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))
core1weld.C1 = CFrame.new(0,0,0)
core2weld = core.Core.Color2b
core2weld.C0 = CFrame.new(0,0,0)*angles(math.rad(0),math.rad(45),math.rad(0))
core2weld.C1 = CFrame.new(0,0,0)
core3weld = core.Core.Color3b
core3weld.C0 = CFrame.new(0,0,0)*angles(math.rad(0),math.rad(45),math.rad(0))
core3weld.C1 = CFrame.new(0,0,0)
for i,v in pairs(core:GetChildren()) do
if v.Name ~= "Weld" then
v.Anchored = false
end
end


wing1weld = Instance.new("Weld",core.Core)
wing1 = script.Wing:Clone()
wing1.Parent = script
wing1weld.Part0 = core.Core
wing1weld.Part1 = wing1.Core
wing1.Core.Anchored = false
wing1weld.C1 = CFrame.new(0,0,-3)*angles(math.rad(-90),math.rad(0),math.rad(90))
for i,v in pairs(wing1:GetChildren()) do
if v.Name ~= "Weld" then
v.Anchored = false
end
end

wing2weld = Instance.new("Weld",core.Core)
wing2 = script.Wing:Clone()
wing2.Parent = script
wing2weld.Part0 = core.Core
wing2weld.Part1 = wing2.Core
wing2.Core.Anchored = false
wing2weld.C1 = CFrame.new(0,0,-5)*angles(math.rad(-90),math.rad(0),math.rad(90))
for i,v in pairs(wing2:GetChildren()) do
if v.Name ~= "Weld" then
v.Anchored = false
end
end

wing3weld = Instance.new("Weld",core.Core)
wing3 = script.Wing:Clone()
wing3.Parent = script
wing3weld.Part0 = core.Core
wing3weld.Part1 = wing3.Core
wing3.Core.Anchored = false
wing3weld.C1 = CFrame.new(0,0,-7)*angles(math.rad(-90),math.rad(0),math.rad(90))
for i,v in pairs(wing3:GetChildren()) do
if v.Name ~= "Weld" then
v.Anchored = false
end
end
wing4weld = Instance.new("Weld",core.Core)
wing4 = script.Wing:Clone()
wing4.Parent = script
wing4weld.Part0 = core.Core
wing4weld.Part1 = wing4.Core
wing4.Core.Anchored = false
wing4weld.C1 = CFrame.new(0,0,3)*angles(math.rad(-90),math.rad(0),math.rad(90))
for i,v in pairs(wing4:GetChildren()) do
if v.Name ~= "Weld" then
v.Anchored = false
end
end
wing5weld = Instance.new("Weld",core.Core)
wing5 = script.Wing:Clone()
wing5.Parent = script
wing5weld.Part0 = core.Core
wing5weld.Part1 = wing5.Core
wing5.Core.Anchored = false
wing5weld.C1 = CFrame.new(0,0,5)*angles(math.rad(-90),math.rad(0),math.rad(90))
for i,v in pairs(wing5:GetChildren()) do
if v.Name ~= "Weld" then
v.Anchored = false
end
end
wing6weld = Instance.new("Weld",core.Core)
wing6 = script.Wing
wing6weld.Part0 = core.Core
wing6weld.Part1 = wing6.Core
wing6.Core.Anchored = false
wing6weld.C1 = CFrame.new(0,0,7)*angles(math.rad(-90),math.rad(0),math.rad(90))
for i,v in pairs(wing6:GetChildren()) do
if v.Name ~= "Weld" then
v.Anchored = false
end
end


--Blink Functions
blinking = false
function blinkfunction()
	if blinking == false then
		blinking = true
		coroutine.resume(coroutine.create(function()
--EyesFolder.RightEye.Size = Vector3.new(0.05, 0.082, 0.162)
--EyesFolder.LeftEye.Size = Vector3.new(0.05, 0.082, 0.162)
local tweenService = game:GetService("TweenService")

		local tweeningInformation = TweenInfo.new(.3,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut,0,false,0.01)
		local tweeningInformation2 = TweenInfo.new(.5,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut,0,false,0.01)

local partProperties = {
			Size = Vector3.new(0.05, 0.082, 0.162);
		}
local partProperties2 = {
			Size = Vector3.new(0.05, 0.202, 0.162);
}

		local Tween1 = tweenService:Create(EyesFolder.LeftEye,tweeningInformation,partProperties):Play()
		local Tween2 = tweenService:Create(EyesFolder.RightEye,tweeningInformation,partProperties):Play()
			--print("hurb")
			wait(.4)
				local Tween3 = tweenService:Create(EyesFolder.LeftEye,tweeningInformation2,partProperties2):Play()
			local Tween4 = tweenService:Create(EyesFolder.RightEye,tweeningInformation2,partProperties2):Play()
			wait(.6)
		--print("bruh")
		--EyesFolder.RightEye.Size = Vector3.new(0.05, 0.202, 0.162)
--EyesFolder.LeftEye.Size = Vector3.new(0.05, 0.202, 0.162)
		end))
					blinking = false
	end
end
--Blink Functions

--Wacky Effects
-- Start of Pity's Variables
IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor
local SINE = 0
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
--ROBLOXIDLEANIMATION.Parent = Humanoid
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "eggdog"
local Weapon = IT("Model")
Weapon.Name = "Adds"
local Effects = Instance.new("Folder",char)
Effects.Name = "EffectsWack"

local S = Instance.new("Sound")
function CreateSound5(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.SoundId = "rbxassetid://" .. ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat
				wait(1)
			until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end

function CreateMesh5(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
    local NEWMESH = IT(MESH)
    if MESH == "SpecialMesh" then
        NEWMESH.MeshType = MESHTYPE
        if MESHID ~= "nil" and MESHID ~= "" then
            NEWMESH.MeshId = "http://www.roblox.com/asset/?id="..MESHID
        end
        if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
            NEWMESH.TextureId = "http://www.roblox.com/asset/?id="..TEXTUREID
        end
    end
    NEWMESH.Offset = OFFSET or VT(0, 0, 0)
    NEWMESH.Scale = SCALE
    NEWMESH.Parent = PARENT
    return NEWMESH
end
 
function CreatePart5(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
    local NEWPART = IT("Part")
    NEWPART.formFactor = FORMFACTOR
    NEWPART.Reflectance = REFLECTANCE
    NEWPART.Transparency = TRANSPARENCY
    NEWPART.CanCollide = false
    NEWPART.Locked = true
    NEWPART.Anchored = true
    if ANCHOR == false then
        NEWPART.Anchored = false
    end
    NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
    NEWPART.Name = NAME
    NEWPART.Size = SIZE
    NEWPART.Position = Torso.Position
    NEWPART.Material = MATERIAL
    NEWPART:BreakJoints()
    NEWPART.Parent = PARENT
    return NEWPART
end

-- End of Pity's Variables --

--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
--WACKYEFFECT({EffectType = "", Size = VT(1,1,1), Size2 = VT(0,0,0), Transparency = 0, Transparency2 = 1, CFrame = CF(), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = C3(1,1,1), SoundID = nil, SoundPitch = nil, SoundVolume = nil})
function WACKYEFFECT(Table)
	Whatever:FireAllClients("WACKYEFFECT",Table,char,Effects)
	--animThing.WACKYEFFECT(Table,char,Effects)
end
--Wacky Effects
 
--Sound Effects
function soundeffect(id,pit,parent,vol,pos,name)
	local sound = Instance.new("Sound")
	sound.Parent = parent
	sound.Name = name
	sound.SoundId = "rbxassetid://"..id
	sound.Pitch = pit
	sound.Volume = vol
	sound.TimePosition = pos
	sound.PlayOnRemove = true
	sound:Remove()
end

function soundeffectecho(id,pit,parent,vol,pos,name,times,timebetweenecho)
	coroutine.resume(coroutine.create(function()
		for i = 0,times do
			local sound = Instance.new("Sound")
			sound.Parent = parent
			sound.Name = name
			sound.SoundId = "rbxassetid://"..id
			sound.Pitch = pit
			sound.Volume = vol
			sound.TimePosition = pos
			sound.PlayOnRemove = true
			sound:Remove()
			wait(timebetweenecho)
		end
	end))
end

--Guis


function chatfunc(textie,speed,color,havestops,font1,font2)
	for i,v in pairs(game:GetService("Players"):GetPlayers()) do
		if v.PlayerGui:FindFirstChild("FillScrLocal")~= nil then
			v.PlayerGui:FindFirstChild("FillScrLocal"):destroy()
		end

		thing = script.GuiStuff.ChatfuncLocal:Clone()
		local success,fail = pcall(function()
			if color:find("Rainbow") or color:find("Random") then
			end
		end)
		if success then
			thing.IsString.Value = true
			thing.ColorSelect.Value = color
		elseif not success then
			thing.IsString.Value = false
			thing.ColorValue.Value = color
		end
		thing.MorphedIntoName.Value = MorphedInto
		thing.Text.Value = textie
		thing.Speed.Value = speed
		thing.OriginalPlayer.Value = plr.Name
		thing.HasStops.Value = havestops
		if font1 == nil then

			thing.Font1.Value = "Arcade"
		elseif font2 == nil then

			thing.Font2.Value = "Arcade"
		elseif font1 ~= nil and font2 ~= nil then
			thing.Font1.Value = font1
			thing.Font2.Value = font2
		end

		thing.Parent = v.PlayerGui
		thing.Disabled = false
	end
end


function FillScreen(color,timetowait)

	for i,v in pairs(game:GetService("Players"):GetPlayers()) do
		if v.PlayerGui:FindFirstChild("FillScrLocal")~= nil then
			v.PlayerGui:FindFirstChild("FillScrLocal"):destroy()
		end

		thing = script.GuiStuff.FillScrLocal:Clone()
		thing.valuetowait.Value = timetowait
		thing.Color.Value = color
		thing.Parent = v.PlayerGui
		thing.Disabled = false
	end


end

function BossChatFuncTop(text,represfont,color,color2)
	for i,v in pairs(game:GetService("Players"):GetPlayers()) do
		if v.PlayerGui:FindFirstChild("TopBossChatLocal")~= nil then
			v.PlayerGui:FindFirstChild("TopBossChatLocal"):destroy()
		end

		thing = script.GuiStuff.TopBossChatLocal:Clone()
		thing.Font.Value = represfont
		thing.Text.Value = text
		thing.Color1.Value = color
		thing.Color2.Value = color2
		thing.Parent = v.PlayerGui
		thing.Disabled = false
	end
end
function ohnou()
for i,v in pairs(game:GetService("Players"):GetPlayers()) do
coroutine.resume(coroutine.create(function()
if v.PlayerGui:FindFirstChild("ALERT")~= nil then
v.PlayerGui:FindFirstChild("ALERT"):destroy()
end
local scrg = Instance.new("ScreenGui",v.PlayerGui)
scrg.Name = "boi"
local ohno2 = script.GuiStuff:WaitForChild("ALERT").Frame:Clone()
local ohno = ohno2.TextLabel
ohno2.Parent = scrg
ohno2:TweenPosition(UDim2.new(0, 0,0.227,0),Enum.EasingDirection.Out,Enum.EasingStyle.Back,2)
swait(2)
ohno2:TweenPosition(UDim2.new(0, 0,-0.15,0),Enum.EasingDirection.Out,Enum.EasingStyle.Back,2)

end))		
end
end
function Alert(valuetowait)
	for i,v in pairs(game:GetService("Players"):GetPlayers()) do
		if v.PlayerGui:FindFirstChild("AlertLocal")~= nil then
			v.PlayerGui:FindFirstChild("AlertLocal"):destroy()
		end

		thing = script.GuiStuff.AlertLocal:Clone()
		thing.valuetowait.Value = valuetowait
		thing.Parent = v.PlayerGui
		thing.Disabled = false
	end
end



function getAttachment0(character, attachmentName)
    for _,child in next,character:GetChildren() do
        local attachment = child:FindFirstChild(attachmentName)
        if attachment then
            return attachment
        end
    end
end
 
function recurse(root,callback,i)
    i= i or 0
    for _,v in pairs(root:GetChildren()) do
        i = i + 1
        callback(i,v)
       
        if #v:GetChildren() > 0 then
            i = recurse(v,callback,i)
        end
    end
   
    return i
end
function clerp(a,b,t) 
	local qa = {QuaternionFromCFrame(a)}
	local qb = {QuaternionFromCFrame(b)} 
	local ax, ay, az = a.x, a.y, a.z 
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1-t
	return QuaternionToCFrame(_t*ax + t*bx, _t*ay + t*by, _t*az + t*bz,QuaternionSlerp(qa, qb, t)) 
end 

function aclerp(startCF,endCF,alpha)
	return startCF:lerp(endCF, alpha)
end

function QuaternionFromCFrame(cf) 
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components() 
	local trace = m00 + m11 + m22 
	if trace > 0 then 
		local s = math.sqrt(1 + trace) 
		local recip = 0.5/s 
		return (m21-m12)*recip, (m02-m20)*recip, (m10-m01)*recip, s*0.5 
	else 
		local i = 0 
		if m11 > m00 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then 
			i = 2 
		end 
		if i == 0 then 
			local s = math.sqrt(m00-m11-m22+1) 
			local recip = 0.5/s 
			return 0.5*s, (m10+m01)*recip, (m20+m02)*recip, (m21-m12)*recip 
		elseif i == 1 then 
			local s = math.sqrt(m11-m22-m00+1) 
			local recip = 0.5/s 
			return (m01+m10)*recip, 0.5*s, (m21+m12)*recip, (m02-m20)*recip 
		elseif i == 2 then 
			local s = math.sqrt(m22-m00-m11+1) 
			local recip = 0.5/s return (m02+m20)*recip, (m12+m21)*recip, 0.5*s, (m10-m01)*recip 
		end 
	end 
end

function QuaternionToCFrame(px, py, pz, x, y, z, w) 
	local xs, ys, zs = x + x, y + y, z + z 
	local wx, wy, wz = w*xs, w*ys, w*zs 
	local xx = x*xs 
	local xy = x*ys 
	local xz = x*zs 
	local yy = y*ys 
	local yz = y*zs 
	local zz = z*zs 
	return CFrame.new(px, py, pz,1-(yy+zz), xy - wz, xz + wy,xy + wz, 1-(xx+zz), yz - wx, xz - wy, yz + wx, 1-(xx+yy)) 
end

function QuaternionSlerp(a, b, t) 
	local cosTheta = a[1]*b[1] + a[2]*b[2] + a[3]*b[3] + a[4]*b[4] 
	local startInterp, finishInterp; 
	if cosTheta >= 0.0001 then 
		if (1 - cosTheta) > 0.0001 then 
			local theta = math.acos(cosTheta) 
			local invSinTheta = 1/math.sin(theta) 
			startInterp = math.sin((1-t)*theta)*invSinTheta 
			finishInterp = math.sin(t*theta)*invSinTheta  
		else 
			startInterp = 1-t 
			finishInterp = t 
		end 
	else 
		if (1+cosTheta) > 0.0001 then 
			local theta = math.acos(-cosTheta) 
			local invSinTheta = 1/math.sin(theta) 
			startInterp = math.sin((t-1)*theta)*invSinTheta 
			finishInterp = math.sin(t*theta)*invSinTheta 
		else 
			startInterp = t-1 
			finishInterp = t 
		end 
	end 
	return a[1]*startInterp + b[1]*finishInterp, a[2]*startInterp + b[2]*finishInterp, a[3]*startInterp + b[3]*finishInterp, a[4]*startInterp + b[4]*finishInterp 
end

weldfolder = Instance.new("Folder",workspace)
function weldBetween(part1,part2)
local ANewWeld = Instance.new("Weld",weldfolder)
ANewWeld.Part0 = part1
ANewWeld = part2
end
 function ArtificialHitbox(Part)
    local HITBOX = CreatePart(3, Part, "Metal", 0, 1, "Really black", "Hitbox", Part.Size/2, false)
    HITBOX.CanCollide = true
    HITBOX.CFrame = Part.CFrame
    weldBetween(Part,HITBOX)
end

function ragdollJoint(character, part0, part1, attachmentName, className, properties)
end

function R15Ragdoll(character,KeepArms)
end
 
function Ragdoll(Character2,CharTorso,KeepArms)
end


function Damagefunc(Part, hit, minim, maxim, knockback, Type, Property, Delay, HitSound, HitPitch)
end

function RemoveOutlines(part)
  part.TopSurface, part.BottomSurface, part.LeftSurface, part.RightSurface, part.FrontSurface, part.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreatePart(Parent, Material, Reflectance, Transparency, BColor, Name, Size)
  local Part = Create("Part")({
    Parent = Parent,
    Reflectance = Reflectance,
    Transparency = Transparency,
    CanCollide = false,
    Locked = true,
    BrickColor = BrickColor.new(tostring(BColor)),
    Name = Name,
    Size = Size,
    Material = Material
  })
  Part.CustomPhysicalProperties = PhysicalProperties.new(0.001, 0.001, 0.001, 0.001, 0.001)
  RemoveOutlines(Part)
  return Part
end
--ShowDamage(Part.CFrame * CFrame.new(0, 0, Part.Size.Z / 2).p + Vector3.new(0, 1.5, 0), -Damage, 1.5, Part.BrickColor.Color)
function ShowDamage(Pos, Text, Time, Color)
	coroutine.resume(coroutine.create(function()
		foundtext = false
		if Effects:FindFirstChild("DamagePart_"..script.Name) then
			Effects:FindFirstChild("DamagePart_"..script.Name).Visible = false
			foundtext = true
		else
			foundtext = false
		end 
		local EffPart = Instance.new("Part",Effects)
		EffPart.Anchored = true
		EffPart.Size = vt(0.01,0.01,0.01)
		EffPart.Name = "DamagePart_"..script.Name
		EffPart.Transparency = 1
		EffPart.Position = Pos
		local gui = script.GuiStuff.DamageGUI:Clone()
		gui.Parent = EffPart
		gui.Enabled = true
		gui.dmg.Text = Text
		gui.dmg.TextStrokeColor3 = Color
		gui.img.ImageColor3 = Color
		gui.border.ImageColor3 = Color3.fromRGB(0, 52, 130)
		gui.borderin.ImageColor3 = Color3.fromRGB(0, 29, 71)
		
		gui.dmg.TextTransparency = 1
		gui.img.ImageTransparency = 1
		gui.border.ImageTransparency = 1
		gui.borderin.ImageTransparency = 1
		local numlo = 0
		for i = 0,4,0.1 do
			swait()
			numlo = numlo + 1/40
			gui.StudsOffset = Vector3.new(0,3+numlo,0)
			gui.dmg.TextTransparency = gui.dmg.TextTransparency - 1/40
			gui.img.ImageTransparency = gui.img.ImageTransparency - 1/40
			gui.border.ImageTransparency = gui.border.ImageTransparency - 1/40
			gui.borderin.ImageTransparency = gui.borderin.ImageTransparency - 1/40
			gui.img.Rotation = gui.img.Rotation + 5 + RyansOST.PlaybackLoudness/100
			gui.border.Rotation = 2 * math.cos(sine/40)
			gui.borderin.Rotation = 2 * math.cos(sine/40)
		end
		for i = 0,10,0.1 do
			swait()
			gui.img.Rotation = gui.img.Rotation + 5 + RyansOST.PlaybackLoudness/100
			gui.border.Rotation = 2 * math.cos(sine/40)
			gui.borderin.Rotation = 2 * math.cos(sine/40)
		end

		for i = 0,3,0.1 do
			swait()
			numlo = numlo + .1
			gui.border.Rotation = gui.border.Rotation - 1
			gui.borderin.Rotation = gui.borderin.Rotation - 1
			gui.StudsOffset = Vector3.new(0,4+numlo,0)
			gui.dmg.TextTransparency = gui.dmg.TextTransparency + 1/30
			gui.img.ImageTransparency = gui.img.ImageTransparency + 1/30
			gui.border.ImageTransparency = gui.border.ImageTransparency + 1/30
			gui.borderin.ImageTransparency = gui.borderin.ImageTransparency + 1/30
			gui.img.Rotation = gui.img.Rotation + 5 + RyansOST.PlaybackLoudness/100
		end
		EffPart:Destroy()
		
		
end))
end

function MagniDamage(Part, magni, mindam, maxdam, knock, Type)
end

function MagniDamageWithEffect(Part, magni, mindam, maxdam, knock, Type)
  for _, c in pairs(workspace:children()) do
    local hum = c:findFirstChild("Humanoid")
    if hum ~= nil then
      local head = c:findFirstChild("Torso")
      if head ~= nil then
        local targ = head.Position - Part.Position
        local mag = targ.magnitude
        if magni >= mag and c.Name ~= Player.Name then
	--MagicBlock(BrickColor.new("Pastel light blue"),head.CFrame,5,5,5,1,1,1,0.05)
          Damagefunc(head, head, mindam, maxdam, knock, Type, RootPart, 0.1, "rbxassetid://231917784", 1)
        end
      end
    end
  end
end
function rayCast(Pos, Dir, Max, Ignore)  -- Origin Position , Direction, MaxDistance , IgnoreDescendants
return game:service("Workspace"):FindPartOnRay(Ray.new(Pos, Dir.unit * (Max or 999.999)), Ignore) 
end 

--[Head movement core]

local Ang = CFrame.Angles
local aSin = math.asin
local aTan = math.atan

--[Constants]:

local Cam = cam
headmovementenabled = true
local Plr = plr
local Mouse = mouse
local Body = Plr.Character
local Head = hed
local Hum = hum
local Core = Body:WaitForChild("HumanoidRootPart")
local IsR6 = (Hum.RigType.Value==0)
local Trso = (IsR6 and Body:WaitForChild("Torso")) or Body:WaitForChild("UpperTorso")
local Neck = (IsR6 and Trso:WaitForChild("Neck")) or Head:WaitForChild("Neck")
local Waist = (not IsR6 and Trso:WaitForChild("Waist"))
local MseGuide = true
local TurnCharacterToMouse = false
local HeadHorFactor = 1
local HeadVertFactor = 0.6
local BodyHorFactor = 0.5
local BodyVertFactor = 0.4
local UpdateSpeed = 0.1

local NeckOrgnC0 = Neck.C0
local WaistOrgnC0 = (not IsR6 and Waist.C0)

--[Setup]:

Neck.MaxVelocity = 1/3

-- Activation]:
if TurnCharacterToMouse == true then
	MseGuide = true
	HeadHorFactor = 0
	BodyHorFactor = 0
end
game:GetService("RunService").Stepped:Connect(function()
	if headmovementenabled then
	local CamCF = Cam.CoordinateFrame
	if ((IsR6 and Body["Torso"]) or Body["UpperTorso"])~=nil and Body["Head"]~=nil then	
		local TrsoLV = Trso.CFrame.lookVector
		local HdPos = Head.CFrame.p
		if IsR6 and Neck or Neck and Waist then
			if UpdateSpeed == 0.1 then
				local Dist = nil;
				local Diff = nil;
				if not MseGuide then	
					Dist = (Head.CFrame.p-CamCF.p).magnitude
					Diff = Head.CFrame.Y-CamCF.Y
					if not IsR6 then
						Neck.C0 = Neck.C0:lerp(NeckOrgnC0*Ang((aSin(Diff/Dist)*HeadVertFactor), -(((HdPos-CamCF.p).Unit):Cross(TrsoLV)).Y*HeadHorFactor, 0), UpdateSpeed/2)
						Waist.C0 = Waist.C0:lerp(WaistOrgnC0*Ang((aSin(Diff/Dist)*BodyVertFactor), -(((HdPos-CamCF.p).Unit):Cross(TrsoLV)).Y*BodyHorFactor, 0), UpdateSpeed/2)
					else
						Neck.C0 = Neck.C0:lerp(NeckOrgnC0*Ang(-(aSin(Diff/Dist)*HeadVertFactor), 0, -(((HdPos-CamCF.p).Unit):Cross(TrsoLV)).Y*HeadHorFactor),UpdateSpeed/2)
					end
				else
					local Point = Mouse.Hit.p
					Dist = (Head.CFrame.p-Point).magnitude
					Diff = Head.CFrame.Y-Point.Y
					if not IsR6 then
						Neck.C0 = Neck.C0:lerp(NeckOrgnC0*Ang(-(aTan(Diff/Dist)*HeadVertFactor), (((HdPos-Point).Unit):Cross(TrsoLV)).Y*HeadHorFactor, 0), UpdateSpeed/2)
						Waist.C0 = Waist.C0:lerp(WaistOrgnC0*Ang(-(aTan(Diff/Dist)*BodyVertFactor), (((HdPos-Point).Unit):Cross(TrsoLV)).Y*BodyHorFactor, 0), UpdateSpeed/2)
					else
						Neck.C0 = Neck.C0:lerp(NeckOrgnC0*Ang((aTan(Diff/Dist)*HeadVertFactor), 0, (((HdPos-Point).Unit):Cross(TrsoLV)).Y*HeadHorFactor), UpdateSpeed/2)
					end
				end
			end
		end
	end
	if TurnCharacterToMouse == true then
		Hum.AutoRotate = false
		Core.CFrame = Core.CFrame:lerp(CFrame.new(Core.Position, Vector3.new(Mouse.Hit.p.x, Core.Position.Y, Mouse.Hit.p.z)), UpdateSpeed / 2)
	else
		Hum.AutoRotate = true
	end
	end
end)
------------------




function sphere(bonuspeed,type,pos,scale,value,color)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
 
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(RyansOST.PlaybackLoudness/1000,RyansOST.PlaybackLoudness/1000,RyansOST.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = scale
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if ModeOfGlitch == 9 then
coroutine.resume(coroutine.create(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(RyansOST.PlaybackLoudness/1000,RyansOST.PlaybackLoudness/1000,RyansOST.PlaybackLoudness/1000)
else
break
end
end
end))
end
local scaler2 = 1
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if rainbowmode == true then
rng.Color = Color3.new(r/255,g/255,b/255)
end
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end
if chaosmode == true then
rng.BrickColor = BrickColor.random()
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, scaler2*bonuspeed)
end
rng:Destroy()
end))
end
TheGameChangerValue = false -- quit snooping :c
--for refrence of RG.


function sphere2(bonuspeed,type,pos,scale,value,value2,value3,color)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
if ModeOfGlitch ~= 9 then
        rng.BrickColor = color
elseif ModeOfGlitch == 9 then
rng.Color = Color3.new(RyansOST.PlaybackLoudness/1000,RyansOST.PlaybackLoudness/1000,RyansOST.PlaybackLoudness/1000)
end
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = scale
local scaler2 = 1
local scaler2b = 1
local scaler2c = 1
if type == "Add" then
scaler2 = 1*value
scaler2b = 1*value2
scaler2c = 1*value3
elseif type == "Divide" then
scaler2 = 1/value
scaler2b = 1/value2
scaler2c = 1/value3
end
if ModeOfGlitch == 9 then
coroutine.resume(coroutine.create(function()
while true do
swait()
if rng.Parent ~= nil then
rng.Color = Color3.new(RyansOST.PlaybackLoudness/1000,RyansOST.PlaybackLoudness/1000,RyansOST.PlaybackLoudness/1000)
else
break
end
end
end))
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()
if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
scaler2b = scaler2b - 0.01*value/bonuspeed
scaler2c = scaler2c - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
scaler2b = scaler2b - 0.01/value*bonuspeed
scaler2c = scaler2c - 0.01/value*bonuspeed
end
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2b*bonuspeed, scaler2c*bonuspeed)
end
rng:Destroy()
end))
end

function slash(bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color)
Whatever:FireAllClients("slash",bonuspeed,rotspeed,rotatingop,typeofshape,type,typeoftrans,pos,scale,value,color,effectz)
end


function sphereMK(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true

        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 0
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)



local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()

if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end

speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency + 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end


function sphereMKCharge(bonuspeed,FastSpeed,type,pos,x1,y1,z1,value,color,outerpos)
local type = type
local rng = Instance.new("Part", char)
        rng.Anchored = true
        rng.CanCollide = false
        rng.FormFactor = 3
        rng.Name = "Ring"
        rng.Material = "Neon"
        rng.Size = Vector3.new(1, 1, 1)
        rng.Transparency = 1
        rng.TopSurface = 0
        rng.BottomSurface = 0
        rng.CFrame = pos
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*outerpos
        local rngm = Instance.new("SpecialMesh", rng)
        rngm.MeshType = "Sphere"
rngm.Scale = vt(x1,y1,z1)

local scaler2 = 1
local speeder = FastSpeed
if type == "Add" then
scaler2 = 1*value
elseif type == "Divide" then
scaler2 = 1/value
end
coroutine.resume(coroutine.create(function()
for i = 0,10/bonuspeed,0.1 do
swait()

if type == "Add" then
scaler2 = scaler2 - 0.01*value/bonuspeed
elseif type == "Divide" then
scaler2 = scaler2 - 0.01/value*bonuspeed
end

speeder = speeder - 0.01*FastSpeed*bonuspeed
rng.CFrame = rng.CFrame + rng.CFrame.lookVector*speeder*bonuspeed
rng.Transparency = rng.Transparency - 0.01*bonuspeed
rngm.Scale = rngm.Scale + Vector3.new(scaler2*bonuspeed, scaler2*bonuspeed, 0)
end
rng:Destroy()
end))
end

dmgbrickcolor = MAINRUINCOLOR
function dmg(dude)
end

--Derpz effect functions
function explode_residue(howmuch,part,color,material,transparency,minimum,maximum,sizemin,sizemax)
	
	--WIP
	if game.Workspace.Terrain:FindFirstChild(plr.Name.."'s Residue for "..script.Name) then
		game.Workspace.Terrain:FindFirstChild(plr.Name.."'s Residue for "..script.Name):Destroy()
	else
		
	end
	local folder = Instance.new("Model",game.Workspace.Terrain)
	folder.Name = plr.Name.."'s Residue for "..script.Name
	for i = 0,howmuch do
		
		local groundres = script.Effects.GroundEffectResidue:Clone()
		groundres.Parent = folder
		groundres.Anchored = false
		groundres.Color = color
		groundres.Trail.Color = ColorSequence.new(color,Color3.new(1,1,1))
		groundres.Material = material
		groundres.Transparency = transparency
		groundres.Size = Vector3.new(math.random(sizemin,sizemax),math.random(sizemin,sizemax),math.random(sizemin,sizemax))
		groundres.Name = part.Name.." Residue"
		if part.CFrame then
			groundres.CFrame = part.CFrame
		else
			groundres.CFrame = part
		end
		local groundbodyvel = Instance.new("BodyVelocity",groundres)
		groundbodyvel.MaxForce = Vector3.new(math.huge,math.huge,math.huge)
		groundbodyvel.Velocity = Vector3.new(math.random(minimum,maximum),150,math.random(minimum,maximum))
		
		coroutine.resume(coroutine.create(function()
			game:GetService("Debris"):AddItem(groundbodyvel,.2)
			wait(6)
			if groundres.Transparency < 0 then
				groundres.Transparency = 0
			else
			end
			for i = 0,10,0.1 do
				swait()
				groundres.Transparency = groundres.Transparency + 1/100
			end
			game:GetService("Debris"):AddItem(groundres,1)
			
			
		end))
	end	
end
--Derpz effect functions








function FindNearestHead(Position, Distance, SinglePlayer)
	if SinglePlayer then
		return (SinglePlayer.Torso.CFrame.p - Position).magnitude < Distance
	end
	local List = {}
	for i, v in pairs(workspace:GetChildren()) do
		if v:IsA("Model") then
			if v:findFirstChild("Head") then
				if v ~= Character then
					if (v.Head.Position - Position).magnitude <= Distance then
						table.insert(List, v)
					end 
				end 
			end 
		end 
	end
	return List
end

function FaceMouse()
  Cam = workspace.CurrentCamera
  return {
    CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
    Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
  }
end

function FaceMouse2()
  Cam = workspace.CurrentCamera
  return {
    CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)),
    Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
  }
end
local storehumanoidWS = 16

--Ability Storage
SwimType = 1
function Hello()
attack = true
	hum.WalkSpeed = 0
	chatfunc("Hello, I'm Derpz.",13,"Red")
	for i = 0,20,0.1 do
		swait()
		local Alpha = .25    
		RootJoint.C0 = RootJoint.C0:lerp(cf(0,0+0.05*math.cos(sine/10),0)*angles(math.rad(4+-4*math.cos(sine/20)),math.rad(-5),math.rad(6+2*math.cos(sine/10)))*RootCF,Alpha)    
		LH.C0 = LH.C0:lerp(cf(-1,-1+-0.05*math.cos(sine/10),0.1+-0.1*math.cos(sine/20))*angles(math.rad(-4+4*math.cos(sine/20)),math.rad(0),math.rad(-6+-2*math.cos(sine/10)))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)    
		RH.C0 = RH.C0:lerp(cf(1,-1.1+-0.05*math.cos(sine/10),0.1+-0.1*math.cos(sine/20))*angles(math.rad(-4+4*math.cos(sine/20)),math.rad(0),math.rad(6+-2*math.cos(sine/10)))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)    
		LW.C0 = LW.C0:lerp(cf(-1.5,0.5,0)*angles(math.rad(0+5*math.cos(sine/10)),math.rad(10+10*math.sin(sine/20)),math.rad(-10+5*math.sin(sine/10)))*LeftShoulderC0,Alpha)    
		RW.C0 = RW.C0:lerp(cf(1.5,0.8+0.1*math.cos(sine/10),0)*angles(math.rad(176+5*math.sin(sine/10)),math.rad(25+10*math.cos(sine/20)),math.rad(15+20*math.cos(sine/10)))*RightShoulderC0,Alpha)    
		Neck.C0 = Neck.C0:lerp(necko*cf(0,0,0)*angles(math.rad(4+4*math.cos(sine/20)),math.rad(-6+2*math.cos(sine/10)),math.rad(-6+2*math.sin(sine/10))),Alpha) 
	end
hum.WalkSpeed = storehumanoidWS
attack = false
end
function attackone() --new
attack = true
hum.WalkSpeed = 0

  local easingstyle = Enum.EasingStyle.Quad
  local easingdir = Enum.EasingDirection.In
  local animatetime = .25
   Animate(RootJoint,cf(0,0,0)*angles(math.rad(11.9),math.rad(20.3),math.rad(-9.8))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1.1,-1.2,-0.3)*angles(math.rad(-11.5),math.rad(10.2),math.rad(-15.8))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1,0)*angles(math.rad(-27.6),math.rad(-26.8),math.rad(7.6))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.6,0.6,0.8)*angles(math.rad(73.7),math.rad(13.6),math.rad(-31.2)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.4,0.7,0.2)*angles(math.rad(9),math.rad(-20),math.rad(24.9)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(-0.1,0,0.2)*angles(math.rad(-13.2),math.rad(-20),math.rad(-4.6))*necko,animatetime,easingstyle,easingdir).Completed:wait()

  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.Out
  local animatetime = .25
   Animate(RootJoint,cf(0,0,0)*angles(math.rad(17.9),math.rad(45.2),math.rad(-13.1))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-0.9,-0.5,-0.5)*angles(math.rad(-11.5),math.rad(10.2),math.rad(-15.8))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1.1,0.1)*angles(math.rad(-27.6),math.rad(-26.8),math.rad(-5.8))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.5,0.6,0.8)*angles(math.rad(73.7),math.rad(13.6),math.rad(-8.1)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.3,0.9,0.2)*angles(math.rad(1.6),math.rad(-42.4),math.rad(46.5)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(-0.1,0,0.2)*angles(math.rad(-15.7),math.rad(-43),math.rad(-5.9))*necko,animatetime,easingstyle,easingdir).Completed:wait()
soundeffect(4306980885,.4,tors,5,0,"punch")
  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.In
  local animatetime = .2
   Animate(RootJoint,cf(-0.1,0,-0.2)*angles(math.rad(-0.8),math.rad(8.7),math.rad(-5.4))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-0.9,-0.7,-0.3)*angles(math.rad(-3.7),math.rad(7.9),math.rad(-17))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1,0)*angles(math.rad(-6.6),math.rad(-22.7),math.rad(16.5))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.7,0.3,-0.4)*angles(math.rad(105.2),math.rad(-25.6),math.rad(41.7)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.3,0.8,0.3)*angles(math.rad(-2.7),math.rad(-42.9),math.rad(35)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(-0.1,0.1,0.3)*angles(math.rad(-18.3),math.rad(-10),math.rad(-6.4))*necko,animatetime,easingstyle,easingdir).Completed:wait()
		local bodyvel = Instance.new("BodyVelocity",RootPart)
local pep = 10000000
bodyvel.P = pep
bodyvel.MaxForce = Vector3.new(pep,0,pep)
bodyvel.Velocity = RootPart.CFrame.lookVector*5

  local easingstyle = Enum.EasingStyle.Back
  local easingdir = Enum.EasingDirection.Out
  local animatetime = .2
   Animate(RootJoint,cf(0.1,0,-1)*angles(math.rad(-29.5),math.rad(-34.6),math.rad(-20.8))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1,-1.3,-0.1)*angles(math.rad(23.6),math.rad(12.6),math.rad(3.7))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1.1,0.2)*angles(math.rad(-8.5),math.rad(-23.2),math.rad(15.8))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1,0.5,-1.1)*angles(math.rad(86.1),math.rad(-10.9),math.rad(39.1)),animatetime,Enum.EasingStyle.Sine,easingdir)
  	Animate(RW,cf(1.1,0.8,0.4)*angles(math.rad(31.5),math.rad(-61.7),math.rad(62.7)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(0.2,0.1,0.3)*angles(math.rad(-22.4),math.rad(21.5),math.rad(9.7))*necko,animatetime,easingstyle,easingdir).Completed:wait()
MagniDamage(larm,4,20,30,0.1,"Normal")
  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.In
  local animatetime = .2
   Animate(RootJoint,cf(0.1,0.1,-1)*angles(math.rad(-24.6),math.rad(-26),math.rad(-14.6))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1,-1.3,-0.1)*angles(math.rad(21.6),math.rad(12.2),math.rad(3))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1.2,0.2)*angles(math.rad(-2.5),math.rad(-21.5),math.rad(18.1))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-0.5,0,-1.6)*angles(math.rad(73.5),math.rad(9.2),math.rad(76.3)),animatetime,easingstyle,Enum.EasingDirection.Out)
  	Animate(RW,cf(1.2,0.8,0.3)*angles(math.rad(16.1),math.rad(-46),math.rad(45.1)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(0.1,0,0.3)*angles(math.rad(-17.1),math.rad(16.4),math.rad(7))*necko,animatetime,easingstyle,easingdir).Completed:wait()
bodyvel:Destroy()

  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.Out
  local animatetime = .1
   Animate(RootJoint,cf(0.1,0.2,-1)*angles(math.rad(-22.3),math.rad(-18.9),math.rad(-10.5))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1,-1.4,-0.2)*angles(math.rad(20.8),math.rad(12.1),math.rad(3.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1.3,0.2)*angles(math.rad(3.1),math.rad(-19.7),math.rad(20))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.2,0.1,-1)*angles(math.rad(48.1),math.rad(-32.9),math.rad(39.2)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.3,0.8,0.2)*angles(math.rad(10.5),math.rad(-29.8),math.rad(36.7)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(0.1,0,0.2)*angles(math.rad(-12.4),math.rad(12.7),math.rad(5.4))*necko,animatetime,easingstyle,easingdir).Completed:wait()


  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.Out
  local animatetime = .3
   Animate(RootJoint,cf(0.1,0.2,-1)*angles(math.rad(-21.4),math.rad(-15.5),math.rad(-8.7))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1,-1.4,-0.2)*angles(math.rad(20.4),math.rad(12.1),math.rad(3.3))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1.1,-1.4,0.2)*angles(math.rad(5.8),math.rad(-18.8),math.rad(20.9))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.5,0.1,-0.7)*angles(math.rad(46.8),math.rad(-34),math.rad(23.3)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.4,0.8,0.2)*angles(math.rad(9),math.rad(-21.9),math.rad(33.8)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(0.1,0,0.2)*angles(math.rad(-10.3),math.rad(10.8),math.rad(4.8))*necko,animatetime,easingstyle,easingdir).Completed:wait()

hum.WalkSpeed = storehumanoidWS
attack = false
end

function attacktwo() --new
attack = true
hum.WalkSpeed = 0

  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.Out
  local animatetime = .15
   Animate(RootJoint,cf(0,0,0)*angles(math.rad(6),math.rad(-24.9),math.rad(-3.2))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1,-1.2,-0.1)*angles(math.rad(-9.6),math.rad(24.3),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1,0.1)*angles(math.rad(1),math.rad(-20.4),math.rad(15.1))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.5,0.4,0.2)*angles(math.rad(-9),math.rad(26),math.rad(-12.7)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.3,0.5,0.3)*angles(math.rad(60.9),math.rad(-7.1),math.rad(20.7)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(0,0,0.3)*angles(math.rad(-14.3),math.rad(16.1),math.rad(-1.9))*necko,animatetime,easingstyle,easingdir).Completed:wait()

  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.In
  local animatetime = .15
   Animate(RootJoint,cf(0,0,0)*angles(math.rad(11.5),math.rad(-48.1),math.rad(-3.8))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-0.9,-1.4,-0.1)*angles(math.rad(-14.6),math.rad(37),math.rad(8.6))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-0.9,0.1)*angles(math.rad(1),math.rad(-20.4),math.rad(23.3))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.5,0.4,0.2)*angles(math.rad(6.1),math.rad(24.1),math.rad(-24.1)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(0.9,0.5,0.7)*angles(math.rad(80.9),math.rad(-19.6),math.rad(50.2)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(0,0,0.3)*angles(math.rad(-13.4),math.rad(39.6),math.rad(-2.3))*necko,animatetime,easingstyle,easingdir).Completed:wait()

  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.In
  local animatetime = .15
   Animate(RootJoint,cf(0,0,-0.3)*angles(math.rad(1.1),math.rad(-10.1),math.rad(-4.9))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1,-0.6,-0.3)*angles(math.rad(-11.4),math.rad(16.7),math.rad(7.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1.1,-0.8,-0.3)*angles(math.rad(2.8),math.rad(-19.7),math.rad(23.9))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.5,0.4,0.2)*angles(math.rad(-15),math.rad(30.7),math.rad(-14.2)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(0.9,0.5,0.7)*angles(math.rad(108.3),math.rad(15.1),math.rad(51.4)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(0,0.1,0.4)*angles(math.rad(-21.9),math.rad(5.3),math.rad(-1.1))*necko,animatetime,easingstyle,easingdir).Completed:wait()


soundeffect(4306980885,0.8,tors,5,0,"punch")
		local bodyvel = Instance.new("BodyVelocity",RootPart)
local pep = 10000000
bodyvel.P = pep
bodyvel.MaxForce = Vector3.new(pep,0,pep)
bodyvel.Velocity = RootPart.CFrame.lookVector*5

MagniDamage(rarm,4,10,15,0.1,"Normal")

  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.Out
  local animatetime = .15
   Animate(RootJoint,cf(0.1,-0.2,-0.9)*angles(math.rad(-24.2),math.rad(37.6),math.rad(12.6))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1,-1.1,-0.4)*angles(math.rad(18.8),math.rad(18),math.rad(-2.1))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1.1,-1.1,0.1)*angles(math.rad(-17.2),math.rad(-50),math.rad(17.4))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.6,0.3,0.1)*angles(math.rad(-34.4),math.rad(13.2),math.rad(-26.4)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.1,0.4,-1.3)*angles(math.rad(108.3),math.rad(15.1),math.rad(-42.9)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(0,0.1,0.4)*angles(math.rad(-22.7),math.rad(-31.1),math.rad(-1.3))*necko,animatetime,easingstyle,easingdir).Completed:wait()
soundeffect(4306980885,0.95,tors,5,0,"punch")
bodyvel.Velocity = RootPart.CFrame.lookVector*10
MagniDamage(rarm,4,20,30,0.1,"Normal")

  local easingstyle = Enum.EasingStyle.Back
  local easingdir = Enum.EasingDirection.Out
  local animatetime = .3
   Animate(RootJoint,cf(-0.3,-0.2,-1.1)*angles(math.rad(-34.9),math.rad(35.2),math.rad(5.8))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1.1,-1.1,-0.7)*angles(math.rad(18.8),math.rad(18),math.rad(13))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(0.7,-1,0.4)*angles(math.rad(-45.1),math.rad(-54.3),math.rad(2.8))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.6,0.1,-0.1)*angles(math.rad(-48),math.rad(-14.6),math.rad(-26.6)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(0.8,0.3,-1.2)*angles(math.rad(120),math.rad(15.8),math.rad(-88)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(-0.2,0.1,0.2)*angles(math.rad(-22.8),math.rad(-36.2),math.rad(-14.3))*necko,animatetime,easingstyle,easingdir).Completed:wait()

bodyvel:Destroy()
  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.Out
  local animatetime = .3
   Animate(RootJoint,cf(-0.1,0.1,-0.9)*angles(math.rad(-26.7),math.rad(33.5),math.rad(8.6))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1,-1.3,-0.3)*angles(math.rad(21.3),math.rad(-25.5),math.rad(-3.1))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1.4,0.2)*angles(math.rad(-16.9),math.rad(-31.7),math.rad(-2.7))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.6,0.3,-0.1)*angles(math.rad(14.4),math.rad(-37.9),math.rad(-14.9)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.6,0.5,-0.1)*angles(math.rad(73.8),math.rad(16.3),math.rad(-40.6)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(-0.2,0.1,0.4)*angles(math.rad(-31.9),math.rad(-32.6),math.rad(-16.8))*necko,animatetime,easingstyle,easingdir).Completed:wait()

  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.InOut
  local animatetime = .6
   Animate(RootJoint,cf(0,0.1,-0.8)*angles(math.rad(-5.3),math.rad(34),math.rad(-1.3))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1,-1.3,-0.2)*angles(math.rad(1.2),math.rad(13.3),math.rad(-1.8))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1.1,0.1)*angles(math.rad(-11.4),math.rad(-24.8),math.rad(18.5))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.6,0.1,-0.1)*angles(math.rad(-7.3),math.rad(-28.1),math.rad(-11.1)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.4,0.3,-0.3)*angles(math.rad(15),math.rad(27.7),math.rad(-6.1)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(-0.1,0,0.3)*angles(math.rad(-22),math.rad(-39.3),math.rad(-10.6))*necko,animatetime,easingstyle,easingdir).Completed:wait()

hum.WalkSpeed = storehumanoidWS
attack = false
end





function attackthree() --new
attack = true
hum.WalkSpeed = 0
  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.In
  local animatetime = .15
   Animate(RootJoint,cf(0,0,0)*angles(math.rad(-5.7),math.rad(-6.9),math.rad(0.9))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1,-0.4,-0.5)*angles(math.rad(-30),math.rad(9.9),math.rad(-0.7))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1.2,0)*angles(math.rad(11.7),math.rad(-15.8),math.rad(6.4))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.5,0.4,0.2)*angles(math.rad(4.2),math.rad(27.5),math.rad(-8.1)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.5,0.4,0.2)*angles(math.rad(2.8),math.rad(-19.7),math.rad(8.2)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(0,0,0.2)*angles(math.rad(-11.3),math.rad(8.9),math.rad(1.2))*necko,animatetime,easingstyle,easingdir).Completed:wait()
  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.Out
  local animatetime = .3
   Animate(RootJoint,cf(0,0,0)*angles(math.rad(10.6),math.rad(-22.8),math.rad(7))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-0.9,0.3,-0.3)*angles(math.rad(4.1),math.rad(7.9),math.rad(-6.1))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1.1,0)*angles(math.rad(-15.6),math.rad(-17),math.rad(-1.5))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.4,0.8,0.3)*angles(math.rad(4.2),math.rad(27.5),math.rad(-8.1)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.4,0.8,0.2)*angles(math.rad(2.8),math.rad(-19.7),math.rad(8.2)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(0,0,0.1)*angles(math.rad(-3.4),math.rad(30.7),math.rad(0))*necko,animatetime,easingstyle,easingdir).Completed:wait()
MagniDamage(rleg,4,30,40,0.1,"Normal")
  local easingstyle = Enum.EasingStyle.Back
  local easingdir = Enum.EasingDirection.Out
  local animatetime = .3
   Animate(RootJoint,cf(0,0,0)*angles(math.rad(31.4),math.rad(-19),math.rad(14.5))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1.1,-0.9,-0.7)*angles(math.rad(75.5),math.rad(0.3),math.rad(-29.5))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1.3,0)*angles(math.rad(-22.9),math.rad(-16.7),math.rad(-3.6))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.3,0.6,0.3)*angles(math.rad(-29.6),math.rad(27.5),math.rad(-21.9)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.5,0.3,0)*angles(math.rad(-42.3),math.rad(-19.8),math.rad(15.1)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(0,0.1,0.4)*angles(math.rad(-21.8),math.rad(27.3),math.rad(-2.4))*necko,animatetime,easingstyle,easingdir).Completed:wait()
MagniDamage(rleg,4,20,30,0.1,"Normal")
  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.In
  local animatetime = .4
   Animate(RootJoint,cf(0,0,0)*angles(math.rad(10.6),math.rad(-22.8),math.rad(7))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1,-1.3,-0.4)*angles(math.rad(57),math.rad(10.5),math.rad(-27.7))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1.1,0)*angles(math.rad(-15.6),math.rad(-17),math.rad(-1.5))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.5,0.4,0.2)*angles(math.rad(-24.4),math.rad(27.7),math.rad(-4.3)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.5,0.2,0.1)*angles(math.rad(-25.1),math.rad(-21.2),math.rad(10)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,cf(0,0,0.1)*angles(math.rad(-8.8),math.rad(19.6),math.rad(1))*necko,animatetime,easingstyle,easingdir).Completed:wait()
hum.WalkSpeed = storehumanoidWS
attack = false
end


function attackfour()
	attack = true
	   Animate(RootJoint,cf(0,0,0)*angles(math.rad(-42.9),math.rad(-41.7),math.rad(-31.7))*RootCF,.5,Enum.EasingStyle.Sine,Enum.EasingDirection.In)
  	Animate(LH,cf(-1,-1.2,-0.1)*angles(math.rad(37.3),math.rad(50.8),math.rad(-7.7))*angles(math.rad(0),math.rad(-90),math.rad(0)),.5,Enum.EasingStyle.Sine,Enum.EasingDirection.In)
  	Animate(RH,cf(1.1,-1.2,0.1)*angles(math.rad(26.6),math.rad(-35.7),math.rad(-1.1))*angles(math.rad(0),math.rad(90),math.rad(0)),.5,Enum.EasingStyle.Sine,Enum.EasingDirection.In)
  	Animate(LW,cf(-1.1,0.2,0.6)*angles(math.rad(1.1),math.rad(48),math.rad(3.3)),.5,Enum.EasingStyle.Sine,Enum.EasingDirection.In)
  	Animate(RW,cf(1.5,0.5,0)*angles(math.rad(0),math.rad(0),math.rad(0)),.5,Enum.EasingStyle.Sine,Enum.EasingDirection.In)
  	Animate(Torso.Neck,cf(0.2,0,-0.1)*angles(math.rad(-3.2),math.rad(39.2),math.rad(18.3))*necko,.55,Enum.EasingStyle.Sine,Enum.EasingDirection.In).Completed:Wait()
--Anim 2
   Animate(RootJoint,cf(0,0,0)*angles(math.rad(158.2),math.rad(-84.6),math.rad(148.9))*RootCF,.7,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
  	Animate(LH,cf(-1,-1,0.3)*angles(math.rad(-45.4),math.rad(71.2),math.rad(32.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),.7,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
  	Animate(RH,cf(0.9,-0.9,0)*angles(math.rad(12.2),math.rad(-27.3),math.rad(25.3))*angles(math.rad(0),math.rad(90),math.rad(0)),.7,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
  	Animate(LW,cf(-1.3,0.9,0.2)*angles(math.rad(85.2),math.rad(-25.2),math.rad(-101.1)),.7,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
  	Animate(RW,cf(1.4,0.7,0.3)*angles(math.rad(34.8),math.rad(-14.7),math.rad(38.1)),.7,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
  	Animate(Torso.Neck,cf(0.1,0,0.2)*angles(math.rad(-27.4),math.rad(75.5),math.rad(17.7))*necko,.7,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
local distlook = 5
for i = 0, 6 do
swait(1)
local heck = Instance.new("Part", char)
        heck.Anchored = true
        heck.CanCollide = false
        heck.FormFactor = 3
        heck.Material = "Neon"
        heck.Size = Vector3.new(1, 1, 1)
        heck.Transparency = 1
        heck.TopSurface = 0
        heck.BottomSurface = 0
heck.CFrame = root.CFrame + root.CFrame.lookVector*distlook
sphere(3,"Add",heck.CFrame,vt(0,0,0),0.1,MAINRUINCOLOR)
sphere(6,"Add",heck.CFrame,vt(0,0,0),0.2,MAINRUINCOLOR)
MagniDamage(heck, 10, 15,35, 0, "Normal")
for i = 0, 2 do
sphereMK(3,0.2,"Add",heck.CFrame*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),0.1,0.1,2,-0.005,MAINRUINCOLOR,0)
end
soundeffect(183763506,0.9,heck,4,0,"boom")
soundeffect(178452221,0.8,heck,7,0,"heck")
game:GetService("Debris"):AddItem(heck, 5)
distlook = distlook + 7
end
attack = false
end

																																																																																DONTSETEVERYTHINGTOTRUE = false
																																																																																												if DONTSETEVERYTHINGTOTRUE == true then
																																																																																														error([[Core is not a valid member of Model "Workspace.]]..plr.Name..[["]])
																																																																																																	end

function jumpup()
	attack = true
hum.WalkSpeed = 0
soundeffect(1666361078,1.2,tors,3,0,"zoom")
for i = 0,5,0.1 do
swait()
root.Velocity = vt(0,200,0)
  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0.1)*angles(math.rad(8.2),math.rad(-0.1),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,0.1)*angles(math.rad(-7),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,0.2,-0.6)*angles(math.rad(0),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.2,0.4,0.4)*angles(math.rad(-26.8),math.rad(0),math.rad(21)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.3,0.3,0.2)*angles(math.rad(-26.8),math.rad(4.2),math.rad(-13.5)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,-0.3)*angles(math.rad(18.5),math.rad(0),math.rad(0))*necko,Alpha)
end
hum.WalkSpeed = storehumanoidWS
attack = false
end
aerrtee = 0
freefall = 0
--Ability Storage
swimtypenum = 1
function swimtypechange()
	swimtypenum = swimtypenum + 1
	if swimtypenum == 1 then
		SwimType = swimtypenum
		chatfunc("Changed to front crawl.",25,MAINRUINCOLOR.Color)
	elseif swimtypenum == 2 then
		SwimType = swimtypenum
		chatfunc("Changed to back stroke.",25,MAINRUINCOLOR.Color)
			elseif swimtypenum == 3 then
		SwimType = swimtypenum
		chatfunc("Changed to butterfly.",25,MAINRUINCOLOR.Color)
	elseif swimtypenum == 4 then
		SwimType = swimtypenum
		chatfunc("Changed to that one stroke i can't actually name due to roblox.",25,MAINRUINCOLOR.Color)
	elseif swimtypenum == 5 then
		SwimType = 1
		swimtypenum = 1
 
	end
end
sittingstyle = 1
function sittingstylechange()
	sittingstyle = sittingstyle + 1

			if sittingstyle == 6 then
sittingstyle = 1
	end
end

function dmgfuncdeath()
dmg(char)
end
function biga()
Animate(RW,cf(1.5,0.5,0)*angles(math.rad(152.4),math.rad(0),math.rad(0)),1,Enum.EasingStyle.Back,Enum.EasingDirection.InOut).Completed:wait()
end
function magicattack()
attack = true
Animate(LW,cf(-0.7,0.5,-0.9)*angles(math.rad(90),math.rad(-7.3),math.rad(77.5)),.5,Enum.EasingStyle.Exponential,Enum.EasingDirection.InOut)
  for i = 0, 2, 0.1 do
  	swait()
  	local Alpha = .5
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(0),math.rad(-23.9),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,0)*angles(math.rad(0),math.rad(31.2),math.rad(-8.1))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-1,0)*angles(math.rad(-2.6),math.rad(-44.6),math.rad(4.3))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)

  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(-0.1,0,0)*angles(math.rad(0),math.rad(22.7),math.rad(-6.5))*necko,Alpha)
  end

	 Animate(RW,cf(1.4,0.7,0.2)*angles(math.rad(-2.6),math.rad(-23.8),math.rad(24.8)),1,Enum.EasingStyle.Exponential,Enum.EasingDirection.In).Completed:wait()
	Animate(LW,cf(-1.3,0.8,0.4)*angles(math.rad(54),math.rad(9.4),math.rad(-89)),.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
	 Animate(RW,cf(1.3,0.7,0.3)*angles(math.rad(-11.7),math.rad(-53.2),math.rad(18.4)),.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
  for i = 0, 7, 0.1 do
  	swait()
  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(-11.3),math.rad(41.1),math.rad(7.5))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,0)*angles(math.rad(-7.1),math.rad(18.7),math.rad(-17.5))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1.2,-1.1,-0.2)*angles(math.rad(9.6),math.rad(-46.1),math.rad(16.8))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(-0.1,0,0.1)*angles(math.rad(-9.9),math.rad(-37.9),math.rad(-4.5))*necko,Alpha)
  end
attack = false
end
function easports()
	attack = true
	  for i = 0, 3, 0.1 do
  	swait()
  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0.1,-0.3,-0.2)*angles(math.rad(-19),math.rad(-21.4),math.rad(-7.2))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,0)*angles(math.rad(-15),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.6,-0.5)*angles(math.rad(19.4),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.2,0.2,-0.4)*angles(math.rad(48.5),math.rad(0),math.rad(71.6)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.1,0.2,-0.4)*angles(math.rad(53.3),math.rad(0),math.rad(-75.8)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0.2,0,0.2)*angles(math.rad(-14.3),math.rad(19.7),math.rad(9.9))*necko,Alpha)
	  end
	--Anim 1
		Animate(RootJoint,cf(-0.3,0,-0.1)*angles(math.rad(-12.1),math.rad(32.5),math.rad(-1.6))*RootCF,.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
	 Animate(Torso.Neck,cf(0.1,0,0.2)*angles(math.rad(-11.8),math.rad(9.8),math.rad(5))*necko,.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
		Animate(LH,cf(-0.8,-0.4,-0.6)*angles(math.rad(-44),math.rad(9.7),math.rad(-11.3))*angles(math.rad(0),math.rad(-90),math.rad(0)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
	 Animate(RH,cf(1.1,-1,-0.3)*angles(math.rad(-21.5),math.rad(-16.2),math.rad(17.9))*angles(math.rad(0),math.rad(90),math.rad(0)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
		Animate(LW,cf(-1.3,0.7,0.3)*angles(math.rad(48.5),math.rad(0),math.rad(-47.7)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
	 Animate(RW,cf(1.4,0.7,0.3)*angles(math.rad(53.3),math.rad(0),math.rad(43)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In).Completed:wait()
	--Anim 2
			Animate(RootJoint,cf(-0.3,0,-0.1)*angles(math.rad(140.6),math.rad(67.4),math.rad(-157.7))*RootCF,.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
	 Animate(Torso.Neck,cf(0,0,0.2)*angles(math.rad(-10.3),math.rad(0.7),math.rad(0.9))*necko,.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
		Animate(LH,cf(-1,-1,0)*angles(math.rad(-3.7),math.rad(0),math.rad(-14.8))*angles(math.rad(0),math.rad(-90),math.rad(0)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
	 Animate(RH,cf(1,-0.6,-0.5)*angles(math.rad(19.4),math.rad(0),math.rad(23.9))*angles(math.rad(0),math.rad(90),math.rad(0)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
		Animate(LW,cf(-1,0.8,0.4)*angles(math.rad(48.5),math.rad(0),math.rad(-92.7)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
	 Animate(RW,cf(1.1,0.8,0.4)*angles(math.rad(53.3),math.rad(0),math.rad(82.8)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In).Completed:wait()
	--Anim 3
	   Animate(RootJoint,cf(0.3,-0.1,-0.1)*angles(math.rad(162),math.rad(-4.5),math.rad(-171.6))*RootCF,.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
  	Animate(LH,cf(-1.2,-0.9,-0.3)*angles(math.rad(-29.7),math.rad(1.9),math.rad(-29.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
  	Animate(RH,cf(1,-1.4,-0.2)*angles(math.rad(-21.5),math.rad(-16.2),math.rad(-12.6))*angles(math.rad(0),math.rad(90),math.rad(0)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
  	Animate(LW,cf(-1.5,0.8,0.4)*angles(math.rad(48.5),math.rad(0),math.rad(-92.7)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
  	Animate(RW,cf(1.4,0.8,0.4)*angles(math.rad(53.3),math.rad(0),math.rad(82.8)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
  	Animate(Torso.Neck,cf(-0.1,0,0.2)*angles(math.rad(-9.5),math.rad(-8.5),math.rad(-2.9))*necko,.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In).Completed:wait()
	--Anim 4
	   Animate(RootJoint,cf(0.6,0.3,-0.4)*angles(math.rad(-176.7),math.rad(-68.4),math.rad(-168.9))*RootCF,.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
  	Animate(LH,cf(-1.2,-1.1,-0.3)*angles(math.rad(-0.3),math.rad(-13.9),math.rad(-13))*angles(math.rad(0),math.rad(-90),math.rad(0)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
  	Animate(RH,cf(1.2,-0.5,-0.5)*angles(math.rad(41.6),math.rad(-18.8),math.rad(8.3))*angles(math.rad(0),math.rad(90),math.rad(0)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
  	Animate(LW,cf(-2,0.7,0.3)*angles(math.rad(48.5),math.rad(0),math.rad(-40.2)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
  	Animate(RW,cf(1.7,0.7,0.2)*angles(math.rad(53.3),math.rad(0),math.rad(40)),.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In)
  	Animate(Torso.Neck,cf(-0.1,0,0.2)*angles(math.rad(-8.7),math.rad(6.8),math.rad(-2.9))*necko,.2,Enum.EasingStyle.Linear,Enum.EasingDirection.In).Completed:wait()
	--Anim 5
	   Animate(RootJoint,cf(0,-0.9,-0.6)*angles(math.rad(-12.8),math.rad(14.3),math.rad(0))*RootCF,.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
  	Animate(LH,cf(-1,-0.1,-0.6)*angles(math.rad(12.1),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
  	Animate(RH,cf(1,-1.2,-0.3)*angles(math.rad(-52.7),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
  	Animate(LW,cf(-1.6,0.5,0.4)*angles(math.rad(75.4),math.rad(7.8),math.rad(-76.8)),.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
  	Animate(RW,cf(1.4,0.6,-0.3)*angles(math.rad(-8.6),math.rad(29),math.rad(17.4)),.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
  	Animate(Torso.Neck,cf(0,0,0)*angles(math.rad(0),math.rad(-15.8),math.rad(0))*necko,.5,Enum.EasingStyle.Back,Enum.EasingDirection.Out).Completed:Wait()
wait(1)
	attack = false
end
function ragdolldeath()
	hum.Health = 0
	headmovementenabled = false
Ragdoll(char,Torso,true)
end




function DerpzMorphTrans(trans)
for i,v in pairs (DerpzMorphTORS:GetDescendants()) do
				if v.Name ~= "main"and v.ClassName ~= "Weld" then
			v.Transparency = trans
			end
	end
for i,v in pairs (DerpzMorphLARM:GetDescendants()) do
				if v.Name ~= "main"and v.ClassName ~= "Weld" then
			v.Transparency = trans
			end
	end
for i,v in pairs (DerpzMorphRARM:GetDescendants()) do
				if v.Name ~= "main"and v.ClassName ~= "Weld" then
			v.Transparency = trans
			end
	end
for i,v in pairs (DerpzMorphLLEG:GetDescendants()) do
				if v.Name ~= "main"and v.ClassName ~= "Weld" then
			v.Transparency = trans
			end
	end
for i,v in pairs (DerpzMorphRLEG:GetDescendants()) do
				if v.Name ~= "main"and v.ClassName ~= "Weld" then
			v.Transparency = trans
			end
end



end
function TailTrans(trans)
	for i,v in pairs (DerpzTail:GetChildren()) do
	if v.Name ~= "Main" then
			v.Transparency = trans
			end
end
end
function DerpzMorph2Trans(trans)
for i,v in pairs (DerpzMorph2TORS:GetDescendants()) do
				if v.Name ~= "main"and v.ClassName ~= "Weld" then
			v.Transparency = trans
			end
	end
for i,v in pairs (DerpzMorph2LARM:GetDescendants()) do
				if v.Name ~= "main"and v.ClassName ~= "Weld" then
			v.Transparency = trans
			end
	end
for i,v in pairs (DerpzMorph2RARM:GetDescendants()) do
				if v.Name ~= "main"and v.ClassName ~= "Weld" then
			v.Transparency = trans
			end
	end
for i,v in pairs (DerpzMorph2LLEG:GetDescendants()) do
				if v.Name ~= "main"and v.ClassName ~= "Weld" then
			v.Transparency = trans
			end
	end
for i,v in pairs (DerpzMorph2RLEG:GetDescendants()) do
				if v.Name ~= "main" and v.ClassName ~= "Weld" then
			v.Transparency = trans
			end
end



end

function JakeMorphTrans(trans)
	for i,v in pairs (JakeMorphTORS:GetDescendants()) do
		if v.ClassName ~= "Weld" then
			v.Transparency = trans
		end
	end
	for i,v in pairs (JakeMorphLARM:GetDescendants()) do
		if v.ClassName ~= "Weld" then
			v.Transparency = trans
		end
	end
	for i,v in pairs (JakeMorphRARM:GetDescendants()) do
		if v.ClassName ~= "Weld" then
			v.Transparency = trans
		end
	end
	for i,v in pairs (JakeMorphLLEG:GetDescendants()) do
		if v.ClassName ~= "Weld" and v.Name ~= "Mesh" then
			v.Transparency = trans
		end
	end
	for i,v in pairs (JakeMorphRLEG:GetDescendants()) do
		if v.ClassName ~= "Weld" and v.Name ~= "Mesh" then
			v.Transparency = trans
		end
	end



end

JakeD_EyeColor = Color3.fromRGB(0, 0, 143 - 80 * math.cos(sine/40))
Derpz_EyeColor = Color3.fromRGB(0, 0, 255 - 100* math.cos(sine/30))



function freefalldeathragdoll()
	attack = true
	--ragdoll function from one of my old scripts
	hum.Name = "Humanoid"
	hum.Health = 0.005
				Player.Character.Humanoid.PlatformStand = true
			lshclone = Player.Character.Torso["Left Shoulder"]:Clone()
rshclone = Player.Character.Torso["Right Shoulder"]:Clone()
lhclone = Player.Character.Torso["Left Hip"]:Clone()
rhclone = Player.Character.Torso["Right Hip"]:Clone()
local leftarm = Player.Character["Left Arm"]
local rightrm = Player.Character["Right Arm"]
local leftleg = Player.Character["Left Leg"]
local rightleg = Player.Character["Right Leg"]
Player.Character.Torso["Left Hip"]:destroy()
local head = Player.Character.Head
glue = Instance.new("Glue", Player.Character.Torso)
glue.Part0 = Player.Character.Torso
glue.Part1 = leftleg
glue.Name = "Left leg"
collider = Instance.new("Part", leftleg)
collider.Position = Vector3.new(0,999,0)
collider.Size = Vector3.new(1.5, 1, 1)
collider.Shape = "Cylinder"
local weld = Instance.new("Weld", collider)
weld.Part0 = leftleg
weld.Part1 = collider
weld.C0 = CFrame.new(0,-0.2,0) * CFrame.fromEulerAnglesXYZ(0, 0, math.pi/2)
collider.TopSurface = "Smooth"
collider.BottomSurface = "Smooth"
collider.formFactor = "Symmetric"
glue.C0 = CFrame.new(-0.5, -1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
glue.C1 = CFrame.new(-0, 1, 0, -0, -0, -1, 0, 1, 0, 1, 0, 0)
collider.Transparency = 1
------------
Player.Character.Torso["Right Hip"]:destroy()
glue1 = Instance.new("Glue", Player.Character.Torso)
glue1.Part0 = Player.Character.Torso
glue1.Part1 = rightleg
glue1.Name = "Right leg"
collider1 = Instance.new("Part", rightleg)
collider1.Position = Vector3.new(0,9999,0)
collider1.Size = Vector3.new(1.5, 1, 1)
collider1.Shape = "Cylinder"
local weld1 = Instance.new("Weld", collider1)
weld1.Part0 = rightleg
weld1.Part1 = collider1
weld1.C0 = CFrame.new(0,-0.2,0) * CFrame.fromEulerAnglesXYZ(0, 0, math.pi/2)
collider1.TopSurface = "Smooth"
collider1.BottomSurface = "Smooth"
collider1.formFactor = "Symmetric"
glue1.C0 = CFrame.new(0.5, -1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
glue1.C1 = CFrame.new(0, 1, 0, 0, 0, 1, 0, 1, 0, -1, -0, -0)
collider1.Transparency = 1
------------
Player.Character.Torso["Right Shoulder"]:destroy()
glue11 = Instance.new("Glue", Player.Character.Torso)
glue11.Part0 = Player.Character.Torso
glue11.Part1 = rightrm
glue11.Name = "Right shoulder"
collider11 = Instance.new("Part", rightrm)
collider11.Position = Vector3.new(0,9999,0)
collider11.Size = Vector3.new(1.8,1,1)
collider11.Shape = "Cylinder"
local weld11 = Instance.new("Weld", collider11)
weld11.Part0 = rightrm
weld11.Part1 = collider11
weld11.C0 = CFrame.new(0,-0.2,0) * CFrame.fromEulerAnglesXYZ(0, 0, math.pi/2)
collider11.TopSurface = "Smooth"
collider11.BottomSurface = "Smooth"
collider11.formFactor = "Symmetric"
glue11.C0 = CFrame.new(1.5, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
glue11.C1 = CFrame.new(0, 0.5, 0, 0, 0, 1, 0, 1, 0, -1, 0, 0)
collider11.Transparency = 1
------------
Player.Character.Torso["Left Shoulder"]:destroy()
glue111 = Instance.new("Glue", Player.Character.Torso)
glue111.Part0 = Player.Character.Torso
glue111.Part1 = leftarm
glue111.Name = "Left shoulder"
collider111 = Instance.new("Part", leftarm)
collider111.Position = Vector3.new(0,9999,0)
collider111.Size = Vector3.new(1.5, 1, 1)
collider111.Shape = "Cylinder"
local weld111 = Instance.new("Weld", collider111)
weld111.Part0 = leftarm
weld111.Part1 = collider111
weld111.C0 = CFrame.new(0,-0.2,0) * CFrame.fromEulerAnglesXYZ(0, 0, math.pi/2)
collider111.TopSurface = "Smooth"
collider111.BottomSurface = "Smooth"
collider111.formFactor = "Symmetric"
glue111.C0 = CFrame.new(-1.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
glue111.C1 = CFrame.new(0, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
collider111.Transparency = 1
end

smuggyval = false
function smuggy()
	attack = true
	
	hum.WalkSpeed = 0
	repeat
		  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.Out
  local animatetime = .25
   Animate(RootJoint,cf(0,-0.1,0)*angles(math.rad(0),math.rad(-11),math.rad(-8))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1,-1.1,0)*angles(math.rad(0),math.rad(15),math.rad(-6))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-0.7,-0.3)*angles(math.rad(2.9),math.rad(-6.7),math.rad(18.2))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1,0.4,-0.6)*angles(math.rad(81.2),math.rad(-27.6),math.rad(60)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.5,0.4,0.3)*angles(math.rad(63.4),math.rad(-24.1),math.rad(55.7)),animatetime,easingstyle,easingdir)
		  	Animate(Torso.Neck,necko*angles(math.rad(-0),math.rad(7),math.rad(8)),animatetime,easingstyle,easingdir).Completed:wait()
		  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.In
  local animatetime = .25
   Animate(RootJoint,cf(-0.1,0.1,0)*angles(math.rad(0),math.rad(5),math.rad(0))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1.1,-1.2,-0.2)*angles(math.rad(0),math.rad(15),math.rad(-6))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1,-0.2)*angles(math.rad(0),math.rad(0),math.rad(18))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.5,0.7,-0.3)*angles(math.rad(116),math.rad(-7.4),math.rad(-0.3)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.5,0.7,-0.4)*angles(math.rad(115.5),math.rad(-3.2),math.rad(-3.6)),animatetime,easingstyle,easingdir)
		  	Animate(Torso.Neck,necko*angles(math.rad(-6.5),math.rad(1.2),math.rad(-10)),animatetime,easingstyle,easingdir).Completed:wait()
		  local easingstyle = Enum.EasingStyle.Sine
		  local easingdir = Enum.EasingDirection.Out
		  local animatetime = .25
   Animate(RootJoint,cf(0,-0.2,0)*angles(math.rad(0),math.rad(5),math.rad(14))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1.2,-0.5,-0.3)*angles(math.rad(3.1),math.rad(20.2),math.rad(-24.8))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1.1,-0.2)*angles(math.rad(-3.5),math.rad(-10.2),math.rad(-5.6))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.7,0.2,-0.1)*angles(math.rad(100),math.rad(23.8),math.rad(-46.8)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1,0.5,-0.7)*angles(math.rad(95.2),math.rad(23.5),math.rad(-47.7)),animatetime,easingstyle,easingdir)
		  	Animate(Torso.Neck,necko*angles(math.rad(5.8),math.rad(-16.1),math.rad(-3.4)),animatetime,easingstyle,easingdir).Completed:wait()
		  local easingstyle = Enum.EasingStyle.Sine
  local easingdir = Enum.EasingDirection.In
  local animatetime = .2
   Animate(RootJoint,cf(-0.1,0.1,0)*angles(math.rad(0),math.rad(5),math.rad(0))*RootCF,animatetime,easingstyle,easingdir)
  	Animate(LH,cf(-1.1,-1.2,-0.2)*angles(math.rad(0),math.rad(15),math.rad(-6))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(RH,cf(1,-1,-0.2)*angles(math.rad(0),math.rad(0),math.rad(18))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
  	Animate(LW,cf(-1.5,0.8,-0.6)*angles(math.rad(116),math.rad(-7.4),math.rad(-0.3)),animatetime,easingstyle,easingdir)
  	Animate(RW,cf(1.5,0.7,-0.5)*angles(math.rad(115.5),math.rad(-3.2),math.rad(-3.6)),animatetime,easingstyle,easingdir)
  	Animate(Torso.Neck,necko*angles(math.rad(11.7),math.rad(0.3),math.rad(-9.7)),animatetime,easingstyle,easingdir).Completed:wait()
	until smuggyval == false
	attack = false
	hum.WalkSpeed = storehumanoidWS
end

WingStyle = "Classic"
function ModeSwitchLoop(data) --This function is for looping anything which needs to be looped. There's no tweening, And no audio changes.
if TheGameChangerValue then
text.Text = data.Name.." "..MorphedInto		
else
	text.Text = data.Name
end
	desctext.Text = data.desc
	text.Font = data.font
	desctext.Font = data.font
	NameOfMode.Text = "Mode name: "..data.Name
	NameOfMode.Font = data.font
	NameOfMode.UIGradient.Color = data.txtg1
	--SongNameTxt.Text = "Music: "..data.musicname
	SongNameTxt.Font = data.font
	SongNameTxt.UIGradient.Color = data.txtg2
	MAINRUINCOLOR = data.wcol1
	ManThemeColor = data.wcol1
	ModeOfCharacter = data.modestring
	textgr.Color = data.txtg1 
	desctextgr.Color = data.txtg2 
	linegr.Color = data.txtg3 
	img1.ImageColor3 = data.wcol1
	img2.ImageColor3 = data.wcol2
	img3.ImageColor3 = data.wcol1
	WingStyle = data.wstyle
	if data.ExtraOptions == true then
		if data.Unleashed == true then
			tors.EffectGoBrr.Enabled = true
		else
			tors.EffectGoBrr.Enabled = false
		end
		if data.HealthCap ~= nil then
			hum.MaxHealth = data.HealthCap
		else
		end
	else

	end
	--Wings and Core
	--local transitionInfo = TweenInfo.new(0.01,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut)
	for i,v in pairs(wing1:GetChildren()) do
		if v.Name == "ColorInside" then
			v.Color = data.wcol1
			v.Transparency = data.wtr1

			
		elseif v.Name == "ColorOutside" then
			v.Color = data.wcol2
			v.Transparency = data.wtr2
			
		elseif v.Name == "Core" then
			v.Color = data.wcol1
			v.Transparency = data.wtr1
			v.PointLight.Color = data.wcol1
			
		end
	end
	for i,v in pairs(wing2:GetChildren()) do
		if v.Name == "ColorInside" then
			v.Color = data.wcol1
			v.Transparency = data.wtr1


		elseif v.Name == "ColorOutside" then
			v.Color = data.wcol2
			v.Transparency = data.wtr2

		elseif v.Name == "Core" then
			v.Color = data.wcol1
			v.Transparency = data.wtr1
			v.PointLight.Color = data.wcol1

		end
	end
	for i,v in pairs(wing3:GetChildren()) do
		if v.Name == "ColorInside" then
			v.Color = data.wcol1
			v.Transparency = data.wtr1


		elseif v.Name == "ColorOutside" then
			v.Color = data.wcol2
			v.Transparency = data.wtr2

		elseif v.Name == "Core" then
			v.Color = data.wcol1
			v.Transparency = data.wtr1
			v.PointLight.Color = data.wcol1

		end
	end
	for i,v in pairs(wing4:GetChildren()) do
		if v.Name == "ColorInside" then
			v.Color = data.wcol1
			v.Transparency = data.wtr1


		elseif v.Name == "ColorOutside" then
			v.Color = data.wcol2
			v.Transparency = data.wtr2

		elseif v.Name == "Core" then
			v.Color = data.wcol1
			v.Transparency = data.wtr1
			v.PointLight.Color = data.wcol1

		end
	end
	for i,v in pairs(wing5:GetChildren()) do
		if v.Name == "ColorInside" then
			v.Color = data.wcol1
			v.Transparency = data.wtr1


		elseif v.Name == "ColorOutside" then
			v.Color = data.wcol2
			v.Transparency = data.wtr2

		elseif v.Name == "Core" then
			v.Color = data.wcol1
			v.Transparency = data.wtr1
			v.PointLight.Color = data.wcol1

		end
	end
	for i,v in pairs(wing6:GetChildren()) do
		if v.Name == "ColorInside" then
			v.Color = data.wcol1
			v.Transparency = data.wtr1


		elseif v.Name == "ColorOutside" then
			v.Color = data.wcol2
			v.Transparency = data.wtr2

		elseif v.Name == "Core" then
			v.Color = data.wcol1
			v.Transparency = data.wtr1
			v.PointLight.Color = data.wcol1

		end
	end
	for i,v in pairs(core:GetChildren()) do
		if v.Name == "Color1b" or v.Name == "Color3b" then
			v.Color = data.wcorecol1
			--local tween = game:GetService("TweenService"):Create(v, transitionInfo, {Color = data.wcorecol1}) tween:Play()
			v.Transparency = data.wtr1
		elseif v.Name == "Color2b" then
			v.Color = data.wcorecol2
			v.Transparency = data.wtr2
			--local tween = game:GetService("TweenService"):Create(v, transitionInfo, {Color = data.wcorecol1}) tween:Play()
		elseif v.Name == "D" then
			v.Color = data.wcorecol2
			v.Transparency = data.wtr2
			v.Attachment.ParticleEmitter.Color = ColorSequence.new(data.wcorecol1,data.wcorecol2)
			--local tween = game:GetService("TweenService"):Create(v, transitionInfo, {Color = data.wcorecol2}) tween:Play()
		end
	end








end

local CanLoop = true
function ModeSwitch(data)
	
	--[[
	
ModeSwitch({

Name = "Test",
desc = "Test Description",
modestring = "TestMode",
wcol1 = Color3.new(0,0,1),
wcol2 = Color3.new(0,0,0),
wcorecol1 = Color3.new(0,0,0),
wcorecol2 = Color3.new(0,1,0),
wtr1 = 0,
wtr2 = 0.5,
wstyle = "Classic",
txtg1 = ColorSequence.new(Color3.new(1,1,1),Color3.new(0,0,0)),
txtg2 = ColorSequence.new(Color3.new(1,1,1),Color3.new(0,0,0)),
txtg3 = ColorSequence.new(Color3.new(1,1,1),Color3.new(0,0,0)),
musicid = 5894657127,
musicname = "DerpzDeNugget - Expern Dreams",
musicpit = 1,
musicvol = 1,
musicpos = "DontChange",
ws = 16,
jp = 100,
emotion = Happy(),
ExtraOptions = false,
--Extra options
Unleashed = false,
--Adds a DBZ-Like Effect to the character
HealthCap = 100,
--Maxes the health to a specific value, Could be used for OP modes to nerf them






})
	




]]
	
	CanLoop = false
if TheGameChangerValue then
text.Text = data.Name.." "..MorphedInto
else
		text.Text = data.Name
end
	desctext.Text = data.desc
	text.Font = data.font
	desctext.Font = data.font
	NameOfMode.Text = "Mode name: "..data.Name
	NameOfMode.Font = data.font
	NameOfMode.UIGradient.Color = data.txtg1
	--SongNameTxt.Text = "Music: "..data.musicname
	SongNameTxt.Font = data.font
	SongNameTxt.UIGradient.Color = data.txtg2
	MAINRUINCOLOR = data.wcol1
	ManThemeColor = data.wcol1
	ModeOfCharacter = data.modestring
	textgr.Color = data.txtg1 
	desctextgr.Color = data.txtg2 
	linegr.Color = data.txtg3 
	img1.ImageColor3 = data.wcol1
	img2.ImageColor3 = data.wcol2
	img3.ImageColor3 = data.wcol1
	WingStyle = data.wstyle
	RyansOST.SoundId = "rbxassetid://"..data.musicid 
	RyansOST.Pitch = data.musicpit
	songnameboi = data.musicname
	local lolemotion = data.emotion
	storehumanoidWS = data.ws
	hum.WalkSpeed = data.ws
	hum.JumpPower = data.jp
	if muted == false then
		RyansOST.Volume = data.musicvol 
	elseif muted == true then
		RyansOST.Volume = 0
		
	end
	if data.musicpos ~= nil and data.musicpos ~= "DontChange" then
		RyansOST.TimePosition = data.musicpos
	end
	if data.ExtraOptions == true then
		if data.Unleashed == true then
			tors.EffectGoBrr.Enabled = true
		else
			tors.EffectGoBrr.Enabled = false
		end
		if data.HealthCap ~= nil then
			hum.MaxHealth = data.HealthCap
			else
		end
	else
		
	end
	--Wings and Core
	local transitionInfo = TweenInfo.new(.2,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut)
	for i,v in pairs(wing1:GetChildren()) do
		if v.Name == "ColorInside" then
			--v.Color = data.wcol1
			v.Transparency = data.wtr1
			
			local tween = game:GetService("TweenService"):Create(v, transitionInfo, {Color = data.wcol1}) tween:Play()
		elseif v.Name == "ColorOutside" then
			--v.Color = data.wcol2
			v.Transparency = data.wtr2
			local tween = game:GetService("TweenService"):Create(v, transitionInfo, {Color = data.wcol2}) tween:Play()
		elseif v.Name == "Core" then
			--v.Color = data.wcol1
			v.Transparency = data.wtr1
			v.PointLight.Color = data.wcol1
			local tween = game:GetService("TweenService"):Create(v, transitionInfo, {Color = data.wcol1}) tween:Play()
		end
	end
	for i,v in pairs(wing2:GetChildren()) do
		if v.Name == "ColorInside" then
			--v.Color = data.wcol1
			v.Transparency = data.wtr1

			local tween = game:GetService("TweenService"):Create(v, transitionInfo, {Color = data.wcol1}) tween:Play()
		elseif v.Name == "ColorOutside" then
			--v.Color = data.wcol2
			v.Transparency = data.wtr2
			local tween = game:GetService("TweenService"):Create(v, transitionInfo, {Color = data.wcol2}) tween:Play()
		elseif v.Name == "Core" then
			--v.Color = data.wcol1
			v.Transparency = data.wtr1
			v.PointLight.Color = data.wcol1
			local tween = game:GetService("TweenService"):Create(v, transitionInfo, {Color = data.wcol1}) tween:Play()
		end
	end
	for i,v in pairs(wing3:GetChildren()) do
		if v.Name == "ColorInside" then
			--v.Color = data.wcol1
			v.Transparency = data.wtr1

			local tween = game:GetService("TweenService"):Create(v, transitionInfo, {Color = data.wcol1}) tween:Play()
		elseif v.Name == "ColorOutside" then
			--v.Color = data.wcol2
			v.Transparency = data.wtr2
			local tween = game:GetService("TweenService"):Create(v, transitionInfo, {Color = data.wcol2}) tween:Play()
		elseif v.Name == "Core" then
			--v.Color = data.wcol1
			v.Transparency = data.wtr1
			v.PointLight.Color = data.wcol1
			local tween = game:GetService("TweenService"):Create(v, transitionInfo, {Color = data.wcol1}) tween:Play()
		end
	end
	for i,v in pairs(wing4:GetChildren()) do
		if v.Name == "ColorInside" then
			--v.Color = data.wcol1
			v.Transparency = data.wtr1

			local tween = game:GetService("TweenService"):Create(v, transitionInfo, {Color = data.wcol1}) tween:Play()
		elseif v.Name == "ColorOutside" then
			--v.Color = data.wcol2
			v.Transparency = data.wtr2
			local tween = game:GetService("TweenService"):Create(v, transitionInfo, {Color = data.wcol2}) tween:Play()
		elseif v.Name == "Core" then
			--v.Color = data.wcol1
			v.Transparency = data.wtr1
			v.PointLight.Color = data.wcol1
			local tween = game:GetService("TweenService"):Create(v, transitionInfo, {Color = data.wcol1}) tween:Play()
		end
	end
	for i,v in pairs(wing5:GetChildren()) do
		if v.Name == "ColorInside" then
			--v.Color = data.wcol1
			v.Transparency = data.wtr1

			local tween = game:GetService("TweenService"):Create(v, transitionInfo, {Color = data.wcol1}) tween:Play()
		elseif v.Name == "ColorOutside" then
			--v.Color = data.wcol2
			v.Transparency = data.wtr2
			local tween = game:GetService("TweenService"):Create(v, transitionInfo, {Color = data.wcol2}) tween:Play()
		elseif v.Name == "Core" then
			--v.Color = data.wcol1
			v.Transparency = data.wtr1
			v.PointLight.Color = data.wcol1
			local tween = game:GetService("TweenService"):Create(v, transitionInfo, {Color = data.wcol1}) tween:Play()
		end
	end
	for i,v in pairs(wing6:GetChildren()) do
		if v.Name == "ColorInside" then
			--v.Color = data.wcol1
			v.Transparency = data.wtr1

			local tween = game:GetService("TweenService"):Create(v, transitionInfo, {Color = data.wcol1}) tween:Play()
		elseif v.Name == "ColorOutside" then
			--v.Color = data.wcol2
			v.Transparency = data.wtr2
			local tween = game:GetService("TweenService"):Create(v, transitionInfo, {Color = data.wcol2}) tween:Play()
		elseif v.Name == "Core" then
			--v.Color = data.wcol1
			v.Transparency = data.wtr1
			v.PointLight.Color = data.wcol1
			local tween = game:GetService("TweenService"):Create(v, transitionInfo, {Color = data.wcol1}) tween:Play()
		end
	end
	for i,v in pairs(core:GetChildren()) do
		if v.Name == "Color1b" or v.Name == "Color3b" then
			--v.Color = data.wcorecol1
			local tween = game:GetService("TweenService"):Create(v, transitionInfo, {Color = data.wcorecol1}) tween:Play()
			v.Transparency = data.wtr1
		elseif v.Name == "Color2b" then
			--v.Color = data.wcorecol2
			v.Transparency = data.wtr2
			local tween = game:GetService("TweenService"):Create(v, transitionInfo, {Color = data.wcorecol1}) tween:Play()
		elseif v.Name == "D" then
			--v.Color = data.wcorecol2
			v.Transparency = data.wtr2
			v.Attachment.ParticleEmitter.Color = ColorSequence.new(data.wcorecol1,data.wcorecol2)
			local tween = game:GetService("TweenService"):Create(v, transitionInfo, {Color = data.wcorecol2}) tween:Play()
		end
	end
wait(.2)
CanLoop = true
	
	
	
	
	
	
end

--MOVES
function HeartCrushd()
	attack = true
	hum.WalkSpeed = 0
	local targetted = nil
	if mouse.Target.Parent ~= Character and mouse.Target.Parent.Parent ~= Character and mouse.Target.Parent:FindFirstChildOfClass("Humanoid") ~= nil then
		targetted = mouse.Target.Parent
	end
	local easingstyle = Enum.EasingStyle.Back
	local easingdir = Enum.EasingDirection.Out
	local animatetime = .3
	Animate(RootJoint,cf(0,0,0)*angles(math.rad(-10.1),math.rad(-38.7),math.rad(-6.3))*RootCF,animatetime,easingstyle,easingdir)
	Animate(LH,cf(-1.3,-1.2,0.4)*angles(math.rad(0),math.rad(50),math.rad(9.1))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
	Animate(RH,cf(1,-1,0)*angles(math.rad(5.1),math.rad(-22.1),math.rad(13.4))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
	Animate(LW,cf(-1.2,0,-0.5)*angles(math.rad(140.4),math.rad(-15.6),math.rad(60.3)),animatetime,easingstyle,easingdir)
	Animate(RW,cf(1.5,0.4,0)*angles(math.rad(-7.3),math.rad(0),math.rad(11.7)),animatetime,easingstyle,easingdir)
	Animate(Torso.Neck,necko*angles(math.rad(51.5),math.rad(32.9),math.rad(31)),animatetime,easingstyle,easingdir).Completed:wait()
	if targetted ~= nil then
		print("User found! Target is "..targetted.Name)
		RootPart.Position = targetted.HumanoidRootPart.Position + Vector3.new(0,0,3)
		RootPart.Orientation = targetted.HumanoidRootPart.Orientation
		targetted.HumanoidRootPart.Anchored = true
		local easingstyle = Enum.EasingStyle.Back
		local easingdir = Enum.EasingDirection.Out
		local animatetime = .4
		Animate(RootJoint,cf(0,0,0)*angles(math.rad(-10.1),math.rad(-38.7),math.rad(-6.3))*RootCF,animatetime,easingstyle,easingdir)
		Animate(LH,cf(-1.3,-1.2,0.4)*angles(math.rad(0),math.rad(50),math.rad(9.1))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
		Animate(RH,cf(1,-1,0)*angles(math.rad(5.1),math.rad(-22.1),math.rad(13.4))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
		Animate(LW,cf(-1.1,-0.2,-0.5)*angles(math.rad(140.4),math.rad(-15.6),math.rad(60.3)),animatetime,easingstyle,easingdir)
		Animate(RW,cf(1.6,0.3,0)*angles(math.rad(-3),math.rad(0.9),math.rad(11.7)),animatetime,easingstyle,easingdir)
		Animate(Torso.Neck,necko*angles(math.rad(45.8),math.rad(29.9),math.rad(34)),animatetime,easingstyle,easingdir).Completed:wait()
		for i = 0,4,0.1 do
			swait()
			local Alpha = .05
			RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(0),math.rad(43),math.rad(-5.4))*RootCF,Alpha)
			LH.C0 = LH.C0:lerp(cf(-1,-1.1,0)*angles(math.rad(3.1),math.rad(17.7),math.rad(-9.9))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
			RH.C0 = RH.C0:lerp(cf(1.2,-1,0.2)*angles(math.rad(0),math.rad(-44.5),math.rad(10.1))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
			LW.C0 = LW.C0:lerp(cf(-1.4,0.5,1)*angles(math.rad(96.5),math.rad(-27.6),math.rad(0)),Alpha)
			RW.C0 = RW.C0:lerp(cf(1.6,0.2,0)*angles(math.rad(0),math.rad(0),math.rad(13.2)),Alpha)
		end
		for i = 0,3,0.1 do
			swait()
			local Alpha = .1
			RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(1.4),math.rad(52.1),math.rad(-6.4))*RootCF,Alpha)
			LH.C0 = LH.C0:lerp(cf(-1,-1.1,0)*angles(math.rad(3.1),math.rad(17.7),math.rad(-9.9))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
			RH.C0 = RH.C0:lerp(cf(1.2,-1,0.2)*angles(math.rad(0),math.rad(-44.5),math.rad(10.1))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
			LW.C0 = LW.C0:lerp(cf(-1.4,0.5,1.1)*angles(math.rad(96.5),math.rad(-36.4),math.rad(0)),Alpha)
			RW.C0 = RW.C0:lerp(cf(1.6,0.2,0)*angles(math.rad(0),math.rad(0),math.rad(13.2)),Alpha)
			Torso.Neck.C0 = Torso.Neck.C0:lerp(necko*angles(math.rad(21.3),math.rad(-14),math.rad(-50.7)),Alpha)
		end
		--grab heart from body
		local easingstyle = Enum.EasingStyle.Back
		local easingdir = Enum.EasingDirection.Out
		local animatetime = .6
		Animate(RootJoint,cf(0,0,0)*angles(math.rad(-40),math.rad(-83.4),math.rad(-36.5))*RootCF,animatetime,easingstyle,easingdir)
		Animate(LH,cf(-1.1,-1.1,0.3)*angles(math.rad(19.9),math.rad(64),math.rad(-22))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
		Animate(RH,cf(1.1,-1,0.2)*angles(math.rad(18.4),math.rad(-40.5),math.rad(22.6))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
		Animate(LW,cf(-1.8,0.5,0)*angles(math.rad(90),math.rad(-6.3),math.rad(-89.9)),animatetime,easingstyle,easingdir)
		Animate(RW,cf(1.4,0.2,0.2)*angles(math.rad(11.2),math.rad(13.3),math.rad(34)),animatetime,easingstyle,easingdir)
		
		--Other person's animation
		if targetted.Humanoid.RigType == Enum.HumanoidRigType.R6 then
			Animate(Torso.Neck,necko*angles(math.rad(10),math.rad(0),math.rad(90)),animatetime,easingstyle,easingdir)
		local easingstyle = Enum.EasingStyle.Back
		local easingdir = Enum.EasingDirection.Out
		local animatetime = .6
		Animate(targetted.HumanoidRootPart.RootJoint,cf(0,0,0)*angles(math.rad(6.3),math.rad(0),math.rad(0))*RootCF,animatetime,easingstyle,easingdir)
		Animate(targetted.Torso["Left Hip"],cf(-1,-1.2,-0.2)*angles(math.rad(0),math.rad(0),math.rad(-5.1))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
		Animate(targetted.Torso["Right Hip"],cf(1,-1,-0.1)*angles(math.rad(-18.6),math.rad(0),math.rad(5.7))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
		Animate(targetted.Torso["Left Shoulder"],cf(-1.4,0.8,0.2)*angles(math.rad(12.7),math.rad(22.9),math.rad(-37.5)),animatetime,easingstyle,easingdir)
		Animate(targetted.Torso["Right Shoulder"],cf(1.3,0.7,0.3)*angles(math.rad(20.7),math.rad(-35.7),math.rad(33)),animatetime,easingstyle,easingdir)
			Animate(targetted.Torso["Neck"],necko*angles(math.rad(-15.5),math.rad(0),math.rad(0)),animatetime,easingstyle,easingdir).Completed:wait()
		else
			Animate(Torso.Neck,necko*angles(math.rad(10),math.rad(0),math.rad(90)),animatetime,easingstyle,easingdir).Completed:wait()
			end
		--Heart is in hand
		local easingstyle = Enum.EasingStyle.Back
		local easingdir = Enum.EasingDirection.Out
		local animatetime = 1
		Animate(RootJoint,cf(0,0,0.5)*angles(math.rad(-9.3),math.rad(-55),math.rad(-6.9))*RootCF,animatetime,easingstyle,easingdir)
		Animate(LH,cf(-1,-1,0)*angles(math.rad(0),math.rad(54.7),math.rad(-6.5))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
		Animate(RH,cf(1,-1,0)*angles(math.rad(3.7),math.rad(-32.8),math.rad(6.8))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
		Animate(LW,cf(-1.2,-0.1,0.3)*angles(math.rad(90.1),math.rad(-52.5),math.rad(-56)),animatetime,easingstyle,easingdir)
		Animate(RW,cf(1.5,0.2,0.1)*angles(math.rad(2.7),math.rad(7.4),math.rad(7)),animatetime,easingstyle,easingdir)
		
		

		
		
		--About to drop heart onto ground
		for i = 0,3,0.1 do
			local Alpha = .2
			RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0.5)*angles(math.rad(-3.6),math.rad(0.9),math.rad(-3.9))*RootCF,Alpha)
			LH.C0 = LH.C0:lerp(cf(-1,-1,0)*angles(math.rad(1.1),math.rad(15.2),math.rad(-4))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
			RH.C0 = RH.C0:lerp(cf(1,-1,0)*angles(math.rad(0),math.rad(-14.7),math.rad(8))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
			LW.C0 = LW.C0:lerp(cf(-0.7,0.2,0.6)*angles(math.rad(40.6),math.rad(-44.5),math.rad(-61.2)),Alpha)
			RW.C0 = RW.C0:lerp(cf(1.6,0,0.1)*angles(math.rad(2.7),math.rad(7.4),math.rad(14.3)),Alpha)
			Torso.Neck.C0 = Torso.Neck.C0:lerp(necko*angles(math.rad(3.9),math.rad(1.5),math.rad(-3.8)),Alpha)
		end
		--Other person's animation
		if targetted.Humanoid.RigType == Enum.HumanoidRigType.R6 then
			Animate(Torso.Neck,necko*angles(math.rad(16.8),math.rad(16.1),math.rad(48.6)),animatetime,easingstyle,easingdir)
			local easingstyle = Enum.EasingStyle.Linear
			local easingdir = Enum.EasingDirection.In
			local animatetime = .2
			Animate(targetted.HumanoidRootPart.RootJoint,cf(0,-0.1,-0.4)*angles(math.rad(-17.1),math.rad(0),math.rad(0))*RootCF,animatetime,easingstyle,easingdir)
			Animate(targetted.Torso["Left Hip"],cf(-1,-0.9,-0.2)*angles(math.rad(15.6),math.rad(-1.4),math.rad(-4.9))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
			Animate(targetted.Torso["Right Hip"],cf(1,-0.9,-0.6)*angles(math.rad(-18.6),math.rad(0),math.rad(5.7))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
			Animate(targetted.Torso["Left Shoulder"],cf(-1.5,0.7,-0.2)*angles(math.rad(-16.5),math.rad(-3.8),math.rad(-28.8)),animatetime,easingstyle,easingdir)
			Animate(targetted.Torso["Right Shoulder"],cf(1.4,0.7,-0.4)*angles(math.rad(-6.2),math.rad(12.4),math.rad(26.9)),animatetime,easingstyle,easingdir)
			Animate(targetted.Torso["Neck"],necko*angles(math.rad(7.1),math.rad(0),math.rad(0)),animatetime,easingstyle,easingdir).Completed:wait()
		else
			Animate(Torso.Neck,necko*angles(math.rad(16.8),math.rad(16.1),math.rad(48.6)),animatetime,easingstyle,easingdir).Completed:wait()
		end
		--Thrown down, about to stomp
		local easingstyle = Enum.EasingStyle.Linear
		local easingdir = Enum.EasingDirection.In
		local animatetime = .35
		Animate(RootJoint,cf(0,0,0.5)*angles(math.rad(0.6),math.rad(0.7),math.rad(-4))*RootCF,animatetime,easingstyle,easingdir)
		Animate(LH,cf(-1.1,-0.6,-0.4)*angles(math.rad(-23.6),math.rad(15.5),math.rad(2.6))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
		Animate(RH,cf(1,-1,0)*angles(math.rad(0.2),math.rad(-14.6),math.rad(8))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
		Animate(LW,cf(-1.4,0,-0.3)*angles(math.rad(31.2),math.rad(-42.8),math.rad(8.3)),animatetime,easingstyle,easingdir)
		Animate(RW,cf(1.6,0,0.1)*angles(math.rad(2.7),math.rad(7.4),math.rad(14.3)),animatetime,easingstyle,easingdir)
		Animate(Torso.Neck,necko*angles(math.rad(13.4),math.rad(0.9),math.rad(-4)),animatetime,easingstyle,easingdir).Completed:wait()
		--Other person's animation
		if targetted.Humanoid.RigType == Enum.HumanoidRigType.R6 then
			Animate(Torso.Neck,necko*angles(math.rad(13.4),math.rad(0.9),math.rad(-4)),animatetime,easingstyle,easingdir)
			local easingstyle = Enum.EasingStyle.Back
			local easingdir = Enum.EasingDirection.Out
			local animatetime = .35

			Animate(targetted.HumanoidRootPart.RootJoint,cf(0,-1.4,-0.5)*angles(math.rad(-43.7),math.rad(0),math.rad(0))*RootCF,animatetime,easingstyle,easingdir)
			Animate(targetted.Torso["Left Hip"],cf(-0.8,0.8,-0.4)*angles(math.rad(45.4),math.rad(3.7),math.rad(-7.7))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
			Animate(targetted.Torso["Right Hip"],cf(0.9,-0.6,-1.1)*angles(math.rad(-47.7),math.rad(-2.8),math.rad(5))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
			Animate(targetted.Torso["Left Shoulder"],cf(-1.6,0.3,-0.6)*angles(math.rad(36.6),math.rad(-25.7),math.rad(-14.1)),animatetime,easingstyle,easingdir)
			Animate(targetted.Torso["Right Shoulder"],cf(1.4,0.4,-0.9)*angles(math.rad(56.7),math.rad(29.4),math.rad(2)),animatetime,easingstyle,easingdir)
			Animate(targetted.Torso["Neck"],necko*angles(math.rad(27.4),math.rad(0),math.rad(0)),animatetime,easingstyle,easingdir).Completed:wait()
			
			
		else
			Animate(Torso.Neck,necko*angles(math.rad(13.4),math.rad(0.9),math.rad(-4)),animatetime,easingstyle,easingdir).Completed:wait()
		end
		--just about to stomp
		local easingstyle = Enum.EasingStyle.Sine
		local easingdir = Enum.EasingDirection.In
		local animatetime = .5
		Animate(RootJoint,cf(0,0,0.4)*angles(math.rad(17.6),math.rad(-0.5),math.rad(-4))*RootCF,animatetime,easingstyle,easingdir)
		Animate(LH,cf(-1,0.1,-0.4)*angles(math.rad(-1.4),math.rad(15.3),math.rad(-3.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
		Animate(RH,cf(0.9,-1,0.2)*angles(math.rad(-17.6),math.rad(-16.3),math.rad(3.2))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
		Animate(LW,cf(-1.5,-0.1,-0.2)*angles(math.rad(110.7),math.rad(3.1),math.rad(22.4)),animatetime,easingstyle,easingdir)
		Animate(RW,cf(1.6,0,0.1)*angles(math.rad(121.2),math.rad(9.3),math.rad(-13.2)),animatetime,easingstyle,easingdir)
		Animate(Torso.Neck,necko*angles(math.rad(44.3),math.rad(-1.3),math.rad(-3.9)),animatetime,easingstyle,easingdir).Completed:wait()
		--Stomped, Targetted dies
		delay(.2,function()
			--sound eff
			dmg(targetted)
		end)
		local easingstyle = Enum.EasingStyle.Back
		local easingdir = Enum.EasingDirection.Out
		local animatetime = .75
		Animate(RootJoint,cf(0,0,0.4)*angles(math.rad(-32.9),math.rad(2.8),math.rad(-3))*RootCF,animatetime,easingstyle,easingdir)
		Animate(LH,cf(-1,-0.7,-1.2)*angles(math.rad(39),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
		Animate(RH,cf(1.2,-1.3,-0.5)*angles(math.rad(-18.8),math.rad(-16.4),math.rad(2.9))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
		Animate(LW,cf(-1.5,-0.1,-0.2)*angles(math.rad(-53.7),math.rad(-10.2),math.rad(-19.3)),animatetime,easingstyle,easingdir)
		Animate(RW,cf(1.6,0,0.1)*angles(math.rad(-39.6),math.rad(-4.4),math.rad(15.5)),animatetime,easingstyle,easingdir)
		Animate(Torso.Neck,necko*angles(math.rad(31.6),math.rad(-0.4),math.rad(-4)),animatetime,easingstyle,easingdir).Completed:wait()
		
		
		for i = 0,4,0.1 do
			local Alpha = .3
			RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0.4)*angles(math.rad(-32.9),math.rad(2.8),math.rad(-3))*RootCF,Alpha)
			LH.C0 = LH.C0:lerp(cf(-1,-0.7,-1.2)*angles(math.rad(39),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
			RH.C0 = RH.C0:lerp(cf(1.2,-1.3,-0.5)*angles(math.rad(-18.8),math.rad(-16.4),math.rad(2.9))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
			LW.C0 = LW.C0:lerp(cf(-1.5,-0.1,-0.2)*angles(math.rad(-53.7),math.rad(-10.2),math.rad(-19.3)),Alpha)
			RW.C0 = RW.C0:lerp(cf(1.6,0,0.1)*angles(math.rad(-39.6),math.rad(-4.4),math.rad(15.5)),Alpha)
			Torso.Neck.C0 = Torso.Neck.C0:lerp(necko*angles(math.rad(31.6),math.rad(-0.4),math.rad(-4)),Alpha)
		end
		
	else
		print("No user selected, tping...")
		RootPart.Position = mouse.Hit.p
		local easingstyle = Enum.EasingStyle.Back
		local easingdir = Enum.EasingDirection.Out
		local animatetime = 1
		Animate(RootJoint,cf(0,0,0)*angles(math.rad(-10.1),math.rad(-38.7),math.rad(-6.3))*RootCF,animatetime,easingstyle,easingdir)
		Animate(LH,cf(-1.3,-1.2,0.4)*angles(math.rad(0),math.rad(50),math.rad(9.1))*angles(math.rad(0),math.rad(-90),math.rad(0)),animatetime,easingstyle,easingdir)
		Animate(RH,cf(1,-1,0)*angles(math.rad(5.1),math.rad(-22.1),math.rad(13.4))*angles(math.rad(0),math.rad(90),math.rad(0)),animatetime,easingstyle,easingdir)
		Animate(LW,cf(-1.1,-0.2,-0.5)*angles(math.rad(140.4),math.rad(-15.6),math.rad(60.3)),animatetime,easingstyle,easingdir)
		Animate(RW,cf(1.6,0.3,0)*angles(math.rad(-3),math.rad(0.9),math.rad(11.7)),animatetime,easingstyle,easingdir)
		Animate(Torso.Neck,necko*angles(math.rad(45.8),math.rad(29.9),math.rad(34)),animatetime,easingstyle,easingdir).Completed:wait()
	end
	attack = false
end
function RancroReturnsAGAINbutbetter()
	attack = true
	
	attack = false
end
--MOVES

--Important Removal Stuff
Humanoid.Animator.Parent = nil
for i,v in pairs (char:GetChildren()) do
if v.ClassName == "LocalScript" and v.Name ~= "Client" and v.Name ~= "waht" then
v:Destroy()
print(v.Name.. " Destroyed")
end
end
--Important Removal Stuff

--Mode setup
ModeSwitch({

	Name = "Exasperation",
	desc = "You're in for a hell of a ride.",
	font = "Ubuntu",
	modestring = "Exasperation",
	wcol1 = Color3.new(0.5,0,0),
	wcol2 = Color3.new(0,0,0.5),
	wcorecol1 = Color3.new(1,0,0),
	wcorecol2 = Color3.new(0,0,1),
	wtr1 = 0,
	wtr2 = 0.2,
	wstyle = "StarterMode",
	txtg1 = ColorSequence.new(Color3.new(0,0,1),Color3.new(1,0,0)),
	txtg2 = ColorSequence.new(Color3.new(1,0,0),Color3.new(0,0,1)),
	txtg3 = ColorSequence.new(Color3.new(0,0,1),Color3.new(1,0,0)),
	musicid = 5938181440,
	musicname = "DustTrust Phase 2 theme",
	musicpit = 0.89,
	musicvol = 10,
	musicpos = "DontChange",
	ws = 16,
	jp = 100,
	emotion = Upset(),
	ExtraOptions = false,
	--Extra options
	Unleashed = false,
	--Adds a DBZ-Like Effect to the character
	HealthCap = 100,
	--Maxes the health to a specific value, Could be used for OP modes to nerf them






})
--Mode setup
local OHNOYOUMADEHIMMAD = false


--Click, Letter and Number Key Setup + Chat Setup
local attacknumber = 1
mouse.Button1Down:connect(function()
  if attack == false and attacknumber == 1 then
    attacknumber = 2
    attackone()
  elseif attack == false and attacknumber == 2 then
    attacknumber = 3
   attacktwo()
  elseif attack == false and attacknumber == 3 then
    attacknumber = 4
    attackthree()
  elseif attack == false and attacknumber == 4 then
    attacknumber = 1
    attackfour()
  end
end)
mouse.KeyDown:connect(function(k)
if k == "l" and muted == false then
muted = true
chatfunc("Muted.",10,BrickColor.new("Really red").Color)
RyansOST.Volume = 0
elseif k == "l" and muted == true then
muted = false
chatfunc("Unmuted.",10,BrickColor.new("Bright green").Color)
RyansOST.Volume = 1.25
end
if k == "t" and attack == false then
Hello()
end

	if k == "z" and attack == false and ModeOfCharacter == "Exasperation" then
		HeartCrushd()
	end
	if k == "1" and attack == false and ModeOfCharacter ~= "Exasperation" then
		--ModeChangeExp()
		ModeSwitch({

			Name = "Exasperation",
			desc = "You're in for a hell of a ride.",
			font = "Ubuntu",
			modestring = "Exasperation",
			wcol1 = Color3.new(0.5,0,0),
			wcol2 = Color3.new(0,0,0.5),
			wcorecol1 = Color3.new(1,0,0),
			wcorecol2 = Color3.new(0,0,1),
			wtr1 = 0,
			wtr2 = 0.2,
			wstyle = "StarterMode",
			txtg1 = ColorSequence.new(Color3.new(0,0,1),Color3.new(1,0,0)),
			txtg2 = ColorSequence.new(Color3.new(1,0,0),Color3.new(0,0,1)),
			txtg3 = ColorSequence.new(Color3.new(0,0,1),Color3.new(1,0,0)),
			musicid = 5938181440,
			musicname = "DustTrust Phase 2 theme",
			musicpit = 0.89,
			musicvol = 10,
			musicpos = "DontChange",
			ws = 16,
			jp = 100,
			emotion = Upset(),
			ExtraOptions = false,
			--Extra options
			Unleashed = false,
			--Adds a DBZ-Like Effect to the character
			HealthCap = 100,
			--Maxes the health to a specific value, Could be used for OP modes to nerf them






		})
	end
	if k == "m" and attack == false and ModeOfCharacter == "Exasperation" then
		--ModeChangeExp()
		ModeSwitch({

			Name = "Unsympathetic",
			desc = "A meaning of being Hostile twards another person...Hold on; isn't this just a rename of Hostility?",
			font = "Fantasy",
			modestring = "Hostility",
			wcol1 = Color3.new(0.5,0,0),
			wcol2 = Color3.new(1,0,0),
			wcorecol1 = Color3.new(1,0,0),
			wcorecol2 = Color3.new(.5,0,0),
			wtr1 = 0.7,
			wtr2 = 0.5,
			wstyle = "FlyingClassic",
			txtg1 = ColorSequence.new(Color3.new(1,0,0),Color3.new(.5,0,0),Color3.new(1,0.2,0)),
			txtg2 = ColorSequence.new(Color3.new(0.5,0,0),Color3.new(1,0.2,0),Color3.new(1,0,0)),
			txtg3 = ColorSequence.new(Color3.new(1,0.2,0),Color3.new(1,0,0),Color3.new(0.5,0,0)),
			musicid = 5766507915,
			musicname = "t+pazolite - BIG HEAD BANGING",
			musicpit = 1,
			musicvol = 10,
			musicpos = 0,
			ws = 50,
			jp = 300,
			emotion = Neutral(),
			ExtraOptions = false,
			--Extra options
			Unleashed = false,
			--Adds a DBZ-Like Effect to the character
			HealthCap = 100,
			--Maxes the health to a specific value, Could be used for OP modes to nerf them






		})
	end
	if k == "n" and attack == false and ModeOfCharacter == "Exasperation" then

		ModeSwitch({

			Name = "THEORIES",
			desc = "Huh wait isn't this just a Star glitcher form?",
			font = "SciFi",
			modestring = "Theories",
			wcol1 = Color3.new(1,1,0),
			wcol2 = Color3.new(0,1,1),
			wcorecol1 = Color3.new(1,1,0),
			wcorecol2 = Color3.new(0,1,1),
			wtr1 = 0,
			wtr2 = 00,
			wstyle = "FlyingClassic",
			txtg1 = ColorSequence.new(Color3.new(1,1,0),Color3.new(0,0.5,0.5),Color3.new(0,1,1)),
			txtg2 = ColorSequence.new(Color3.new(1,1,0),Color3.new(0,0.5,0.5),Color3.new(0,1,1)),
			txtg3 = ColorSequence.new(Color3.new(1,1,0),Color3.new(0,0.5,0.5),Color3.new(0,1,1)),
			musicid = 1485663990,
			musicname = "DJ Nate - Theory of Everything 3",
			musicpit = 1.01,
			musicvol = 10,
			musicpos = 0,
			ws = 150,
			jp = 300,
			emotion = Neutral(),
			ExtraOptions = false,
			--Extra options
			Unleashed = false,
			--Adds a DBZ-Like Effect to the character
			HealthCap = 100,
			--Maxes the health to a specific value, Could be used for OP modes to nerf them






		})
	end
	if k == "2" and attack == false and ModeOfCharacter ~= "Serene" then
		--ModeChangeExp()
		ModeSwitch({

			Name = "Peaceful",
			desc = "Joyful, Gleeful, Not a care in the world.",
			font = "Arcade",
			modestring = "Serene",
			wcol1 = Color3.new(0,1,1),
			wcol2 = Color3.new(0,.5,1),
			wcorecol1 = Color3.new(0,1,.65),
			wcorecol2 = Color3.new(0,1,1),
			wtr1 = 0,
			wtr2 = 0,
			wstyle = "Classic",
			txtg1 = ColorSequence.new(Color3.new(0,.5,1),Color3.new(0,1,1)),
			txtg2 = ColorSequence.new(Color3.new(0,1,1),Color3.new(0,.5,1)),
			txtg3 = ColorSequence.new(Color3.new(0,.5,1),Color3.new(0,1,1)),
			musicid = 6171106564,
			musicname = "EMBRZ - Make Your Way",
			musicpit = 1,
			musicvol = 10,
			musicpos = "DontChange",
			ws = 16,
			jp = 100,
			emotion = Happy(),
			ExtraOptions = false,
			--Extra options
			Unleashed = false,
			--Adds a DBZ-Like Effect to the character
			HealthCap = 100,
			--Maxes the health to a specific value, Could be used for OP modes to nerf them






		})
		end
		if k == "m" and attack == false and ModeOfCharacter == "Serene" then
		--ModeChangeExp()
		local funnyid = 0
		local funnyname = ""
		local rdm = math.random(1,2)
		if rdm == 1 then
			funnyid = 4597796561
			funnyname = "Geoxor - Neon Eyes"
		elseif rdm == 2 then
			funnyid = 3780810795
			funnyname = "Geoxor - Euphoria"
		end
			ModeSwitch({

				Name = "Unrestrained",
			desc = "Relax.",
			font = "IndieFlower",
				modestring = "Unrestrained",
				wcol1 = Color3.new(0,0,.3),
			wcol2 = Color3.new(0,0,.5),
			wcorecol1 = Color3.new(0,0,.5),
			wcorecol2 = Color3.new(0,0,.3),
				wtr1 = 0,
				wtr2 = 0,
				wstyle = "Classic",
			txtg1 = ColorSequence.new(Color3.new(0,0,.5),Color3.new(0,0,1)),
			txtg2 = ColorSequence.new(Color3.new(0,0,1),Color3.new(0,0,.5)),
			txtg3 = ColorSequence.new(Color3.new(0,0,.5),Color3.new(0,0,1)),
				musicid = 3780810795,
				musicname = "Geoxor - Euphoria",
				musicpit = 1,
				musicvol = 10,
				musicpos = 0,
				ws = 18,
				jp = 100,
				emotion = Bored(),
				ExtraOptions = false,
				--Extra options
				Unleashed = false,
				--Adds a DBZ-Like Effect to the character
				HealthCap = 100,
				--Maxes the health to a specific value, Could be used for OP modes to nerf them






			})
	end
	if k == "n" and attack == false and ModeOfCharacter == "Serene" then
		--ModeChangeExp()
		ModeSwitch({

			Name = "Exstatic",
			desc = "Let's party!",
			font = "FredokaOne",
			modestring = "Exstatic",
			wcol1 = Color3.new(0,1,1),
			wcol2 = Color3.new(0,.5,1),
			wcorecol1 = Color3.new(0,1,.65),
			wcorecol2 = Color3.new(0,1,1),
			wtr1 = 0,
			wtr2 = 0,
			wstyle = "Classic",
			txtg1 = ColorSequence.new(Color3.new(0,.5,1),Color3.new(0,1,1)),
			txtg2 = ColorSequence.new(Color3.new(0,1,1),Color3.new(0,.5,1)),
			txtg3 = ColorSequence.new(Color3.new(0,.5,1),Color3.new(0,1,1)),
			musicid = 4862131378,
			musicname = "Geoxor & Canonblade - Sakura",
			musicpit = 1.05,
			musicvol = 10,
			musicpos = "DontChange",
			ws = 40,
			jp = 100,
			emotion = Happy(),
			ExtraOptions = false,
			--Extra options
			Unleashed = false,
			--Adds a DBZ-Like Effect to the character
			HealthCap = 100,
			--Maxes the health to a specific value, Could be used for OP modes to nerf them






		})
	end
	
	if k == "3" and attack == false and ModeOfCharacter ~= "Crim" then
		ModeSwitch({

			Name = "CRIMINALITIC",
			desc = "a vassile soul, one should not deal with this...It's innaccecptable...",
			font = "SpecialElite",
			modestring = "Crim",
			wcol1 = Color3.new(math.random(0,1),0,0),
			wcol2 = Color3.new(math.random(0,1),0,0),
			wcorecol1 = Color3.new(math.random(0,1),0,0),
			wcorecol2 = Color3.new(math.random(0,1),0,0),
			wtr1 = 0,
			wtr2 = 0,
			wstyle = "Classic",
			txtg1 = ColorSequence.new(Color3.new(math.random(0,1),0,0),Color3.new(math.random(0,1),0,0)),
			txtg2 = ColorSequence.new(Color3.new(math.random(0,1),0,0),Color3.new(math.random(0,1),0,0)),
			txtg3 = ColorSequence.new(Color3.new(math.random(0,1),0,0),Color3.new(math.random(0,1),0,0)),
			musicid = 6173808889,
			musicname = [[Undertale - "Megalo Strike Back [Kill Everybody]" NITRO Remix]], 
			musicpit = 1,
			musicvol = 10,
			musicpos = "DontChange",
			ws = 16,
			jp = 100,
			emotion = Neutral(),
			ExtraOptions = false,
			--Extra options
			Unleashed = false,
			--Adds a DBZ-Like Effect to the character
			HealthCap = 100,
			--Maxes the health to a specific value, Could be used for OP modes to nerf them






		})
	end
	if k == "4" and attack == false and ModeOfCharacter ~= "REVULSION" then
		ModeSwitch({

			Name = "REVULSION",
			desc = [[Hatred, not so much a trait,  but a corruption of one.  Shapeless, twisted, and unfathomable, Hate seeks to consume and corrupt all. Justice would judge that perhaps not even the innocent are exempt from punishment. Integrity would lose sight of what is right. Bravery would stop to cowardly acts. Kindness would stop playing nice. Patience would be done waiting around. Perseverance would strike back at those who have wronged them. As for a Soul of Determination corrupted by Hate...that's something I don't like to think about. A Soul made of pure HATE is quite difficult to perceive, difficult, but not impossible. It would require the user of the Soul giving up their trait and allowing HATE to fully corrupt them, similar to how a Soul of Bravery might shift their trait into the Soul of FEAR, but such a procedure would reduce the user of everything they were, as they must also be rid of their own humanity, leaving them in a dark husk of their own Hatred. HATE has been around long before any Soul of Human or Monster has been born, and it will most definitely be around when we are all gone.]],
			font = Enum.Font.JosefinSans,
			modestring = "REVULSION",
			wcol1 = Color3.new(0.5,0.5,0.5),
			wcol2 = Color3.new(0.5,0.5,0.5),
			wcorecol1 = Color3.new(0.5,0.5,0.5),
			wcorecol2 = Color3.new(0.5,0.5,0.5),
			wtr1 = 0,
			wtr2 = 0,
			wstyle = "Classic",
			txtg1 = ColorSequence.new(Color3.new(0.5,0.5,0.5),Color3.new(0.5,0.5,0.5)),
			txtg2 = ColorSequence.new(Color3.new(0.5,0.5,0.5),Color3.new(0.5,0.5,0.5)),
			txtg3 = ColorSequence.new(Color3.new(0.5,0.5,0.5),Color3.new(0.5,0.5,0.5)),
			musicid = 4559801621,
			musicname = [[Hate - Instrumental Mix (FULL)]], 
			musicpit = 0.76,
			musicvol = 10,
			musicpos = "DontChange",
			ws = 9,
			jp = 100,
			emotion = Upset(),
			ExtraOptions = false,
			--Extra options
			Unleashed = false,
			--Adds a DBZ-Like Effect to the character
			HealthCap = 100,
			--Maxes the health to a specific value, Could be used for OP modes to nerf them
})
		
	end
	if k == "n" and attack == false and ModeOfCharacter == "REVULSION" then
		ModeSwitch({

			Name = "DISTURBED",
			desc = [[...]],
			font = Enum.Font.Fondamento,
			modestring = "DISTURBED",
			wcol1 = Color3.new(0.5,0.5,0.5),
			wcol2 = Color3.new(0,1,0),
			wcorecol1 = Color3.new(0.5,0.5,0.5),
			wcorecol2 = Color3.new(0,1,0),
			wtr1 = 0,
			wtr2 = 0,
			wstyle = "Classic",
			txtg1 = ColorSequence.new(Color3.new(0,1,0),Color3.new(0.5,0.5,0.5)),
			txtg2 = ColorSequence.new(Color3.new(0.5,0.5,0.5),Color3.new(0,1,0)),
			txtg3 = ColorSequence.new(Color3.new(0,1,0),Color3.new(0.5,0.5,0.5)),
			musicid = 4483123832,
			musicname = [[CAMELLIA - NIGHT RAID WITH A DRAGON]], 
			musicpit = 1,
			musicvol = 10,
			musicpos = "DontChange",
			ws = 150,
			jp = 100,
			emotion = Insane(),
			ExtraOptions = false,
			--Extra options
			Unleashed = false,
			--Adds a DBZ-Like Effect to the character
			HealthCap = 100,
			--Maxes the health to a specific value, Could be used for OP modes to nerf them
		})

	end
	if k == "5" and attack == false and ModeOfCharacter ~= "flying boi" then
		ModeSwitch({

			Name = "WindBorne",
			desc = "I uh....yeah just fly.",
			font = "FredokaOne",
			modestring = "flying boi",
			wcol1 = Color3.new(0,0,0.5),
			wcol2 = Color3.new(0,.3,.5),
			wcorecol1 = Color3.new(0,0,0.5),
			wcorecol2 = Color3.new(0,.3,.5),
			wtr1 = 0,
			wtr2 = 0,
			wstyle = "FlyingClassic",
			txtg1 = ColorSequence.new(Color3.new(0,0,0.5),Color3.new(0,.3,.5)),
			txtg2 = ColorSequence.new(Color3.new(0,.3,.5),Color3.new(0,.3,.5)),
			txtg3 = ColorSequence.new(Color3.new(0,0,0.5),Color3.new(0,1,1)),
			musicid = 5885529454,
			musicname = "GUTTER - Nostalga",
			musicpit = 1,
			musicvol = 10,
			musicpos = "DontChange",
			ws = 40,
			jp = 100,
			emotion = Neutral(),
			ExtraOptions = false,
			--Extra options
			Unleashed = false,
			--Adds a DBZ-Like Effect to the character
			HealthCap = 100,
			--Maxes the health to a specific value, Could be used for OP modes to nerf them






		})
	end
	if k == "6" and attack == false and ModeOfCharacter ~= "That one rainbow mode" then
		ModeSwitch({

			Name = "PRISM",
			desc = "I cant come up with a desc",
			font = "FredokaOne",
			modestring = "That one rainbow mode",
			wcol1 = Color3.new(0,0,0.5),
			wcol2 = Color3.new(0,.3,.5),
			wcorecol1 = Color3.new(0,0,0.5),
			wcorecol2 = Color3.new(0,.3,.5),
			wtr1 = 0,
			wtr2 = 0,
			wstyle = "FlyingClassic",
			txtg1 = ColorSequence.new(Color3.new(0,0,0.5),Color3.new(0,.3,.5)),
			txtg2 = ColorSequence.new(Color3.new(0,.3,.5),Color3.new(0,.3,.5)),
			txtg3 = ColorSequence.new(Color3.new(0,0,0.5),Color3.new(0,1,1)),
			musicid = 6187072944,
			musicname = "Geoplex - Prismatic",
			musicpit = 1,
			musicvol = 10,
			musicpos = "DontChange",
			ws = 40,
			jp = 100,
			emotion = Neutral(),
			ExtraOptions = false,
			--Extra options
			Unleashed = false,
			--Adds a DBZ-Like Effect to the character
			HealthCap = 100,
			--Maxes the health to a specific value, Could be used for OP modes to nerf them






		})
	end
	if k == "7" and attack == false and ModeOfCharacter ~= "PESSIMISTIC" then
		local lolDepressedOrMad = math.random(0,3)
		if lolDepressedOrMad == 3 then
			OHNOYOUMADEHIMMAD = true  --Unlockes tension mode. (N ON PESSIMISTIC.)
		end
		ModeSwitch({

			Name = "Pessimistic...",
			desc = "Darkened, Depressed. Nothing will change...In this state.",
			font = Enum.Font.Fondamento,
			modestring = "PESSIMISTIC",
			wcol1 = Color3.new(0,0,0.5),
			wcol2 = Color3.new(0,0,0),
			wcorecol1 = Color3.new(0,0,0.5),
			wcorecol2 = Color3.new(0,0,0),
			wtr1 = 0.5,
			wtr2 = 0,
			wstyle = "ClassicSlow",
			txtg1 = ColorSequence.new(Color3.new(0,0,0.5),Color3.new(0,0,.0)),
			txtg2 = ColorSequence.new(Color3.new(0,0,.5),Color3.new(0,.0,.0)),
			txtg3 = ColorSequence.new(Color3.new(0,0,0),Color3.new(0,0,.5)),
			musicid = 5985172726,
			musicname = "Undertale - It's raining somewhere else.",
			musicpit = 1,
			musicvol = 10,
			musicpos = "DontChange",
			ws = 8,
			jp = 19,
			emotion = Upset(),
			ExtraOptions = false,
			--Extra options
			Unleashed = false,
			--Adds a DBZ-Like Effect to the character
			HealthCap = 100,
			--Maxes the health to a specific value, Could be used for OP modes to nerf them






		})
		chatfunc("Leave me alone...please..",6,Color3.new(0,0,0.5),true)
		wait(7) 
		chatfunc("I...Don't want to hurt you...",7,Color3.new(0,0,0.5),true)

	end
	if k == "n" and attack == false and OHNOYOUMADEHIMMAD == true and ModeOfCharacter ~= "TENSION" then
		ModeSwitch({

			Name = "...",
			desc = "...",
			font = Enum.Font.Fondamento,
			modestring = "TENSION",
			wcol1 = Color3.new(0,0,0.5),
			wcol2 = Color3.new(0,0,0),
			wcorecol1 = Color3.new(0,0,0.5),
			wcorecol2 = Color3.new(0,0,0),
			wtr1 = 0.5,
			wtr2 = 0,
			wstyle = "FlyingClassic",
			txtg1 = ColorSequence.new(Color3.new(0,0,0.5),Color3.new(0,0,.0)),
			txtg2 = ColorSequence.new(Color3.new(0,0,.5),Color3.new(0,.0,.0)),
			txtg3 = ColorSequence.new(Color3.new(0,0,0),Color3.new(0,0,.5)),
			musicid = 4517242376,
			musicname = "Camellia - Bangin' Burst [Outburst]",
			musicpit = 1,
			musicvol = 10,
			musicpos = "DontChange",
			ws = 8,
			jp = 19,
			emotion = Upset(),
			ExtraOptions = false,
			--Extra options
			Unleashed = false,
			--Adds a DBZ-Like Effect to the character
			HealthCap = 100,
			--Maxes the health to a specific value, Could be used for OP modes to nerf them






		})
	end
	
	if k == "8" and attack == false and ModeOfCharacter ~= "SunRise" then -- Subaru SSG refrence.
		ModeSwitch({

			Name = "Sunrise",
			desc = "The Nightsky is pretty, but It's better with the sun!",
			font = Enum.Font.RobotoMono,
			modestring = "SunRise",
			wcol1 = Color3.new(0,0,0),
			wcol2 = Color3.new(1,1,0),
			wcorecol1 = Color3.new(1,1,0),
			wcorecol2 = Color3.new(0,0,0),
			wtr1 = 0,
			wtr2 = 0,
			wstyle = "Classic",
			txtg1 = ColorSequence.new(Color3.new(1,1,0),Color3.new(0,0,0)),
			txtg2 = ColorSequence.new(Color3.new(0,0,0),Color3.new(1,1,0)),
			txtg3 = ColorSequence.new(Color3.new(1,1,0),Color3.new(0,0,0)),
			musicid = 4977330109,
			musicname = "Aesthetic Alone",
			musicpit = 1,
			musicvol = 10,
			musicpos = "DontChange",
			ws = 16,
			jp = 100,
			emotion = Happy(),
			ExtraOptions = false,
			--Extra options
			Unleashed = false,
			--Adds a DBZ-Like Effect to the character
			HealthCap = 100,
			--Maxes the health to a specific value, Could be used for OP modes to nerf them






		})
	end
	if k == "0" and attack == false and ModeOfCharacter ~= "HELP IM STUCK FLYING HELP HELP HELP HELP" then
		ModeSwitch({

			Name = "OH GOD IM FLYING SOMEONE HELP ME",
			desc = "I-...Wh-....how?",
			font = "FredokaOne",
			modestring = "HELP IM STUCK FLYING HELP HELP HELP HELP",
			wcol1 = Color3.new(1,0,1),
			wcol2 = Color3.new(1,0,1),
			wcorecol1 = Color3.new(1,0,1),
			wcorecol2 = Color3.new(1,0,1),
			wtr1 = 0,
			wtr2 = 0,
			wstyle = "FlyingClassic",
			txtg1 = ColorSequence.new(Color3.new(1,0,1),Color3.new(1,0,1)),
			txtg2 = ColorSequence.new(Color3.new(1,0,1),Color3.new(1,0,1)),
			txtg3 = ColorSequence.new(Color3.new(1,0,1),Color3.new(1,0,1)),
			musicid = 2744154867,
			musicname = "Super Ghostbusters by Vinesauce Joel",
			musicpit = 1,
			musicvol = 10,
			musicpos = "DontChange",
			ws = 40,
			jp = 100,
			emotion = Neutral(),
			ExtraOptions = false,
			--Extra options
			Unleashed = false,
			--Adds a DBZ-Like Effect to the character
			HealthCap = 100,
			--Maxes the health to a specific value, Could be used for OP modes to nerf them






		})
	end
	if k == "x" and attack == false and ModeOfCharacter == "That one rainbow mode" and smuggyval == false then
		smuggyval = true
		smuggy()
	elseif k == "x" and attack == true and ModeOfCharacter == "That one rainbow mode" and smuggyval == true then
		smuggyval = false
	end
	if k == "q" then
		dmg(game.Workspace.DmgFuncTest)
	end
if k == "f" and attack == false then
swimtypechange()
end
if k == "g" and attack == false then
sittingstylechange()
end

	
	
	
end)
mouse.KeyUp:connect(function(k)

end)


plr.Chatted:connect(function(message)
chatfunc(message,20,MAINRUINCOLOR,false)
end)





--song name
--RyansOST.SoundId = "rbxassetid://4801578241"
--songnameboi = "Noah - Necrofantasia"
--MainFrame.SongName.Text = "Music Name: " ..songnameboi
--song name


doinglol = false


heckfallnum = 1
youredead = false
--RNG to depend if you fall to your death while falling down, or live and go straight down without a scratch.
					rdm = math.random(1,2)
					if rdm == 0 then
						heckfallnum = 1
					else
						heckfallnum = 2
					end
				
--Click, Letter and Number Key Setup + Chat Setup

--Protection & Name

Instance.new("ForceField",char).Visible = false
--Protection & Name

--"while true do" Animations, repeated colors, effects
	tired = false
	particles = script.Particles
particles.Parent = Head
hahayes = 0
while true do -- repeated stuff

    for i = 0,1,0.001*5 do 
        omgitskorn.FillColor = Color3.fromHSV(i,1,1)
        omgitskorn.FillTransparency = 0
        omgitskorn.OutlineColor = Color3.fromHSV(0,0,0)
        task.wait()
        
	if ModeOfCharacter ~= "PESSIMISTIC" then
		for i,v in pairs(RK:GetChildren()) do
			if v.Name == "Main" and v.Name ~= "RealKnife" then
				v.Transparency = 1
			elseif v.Name == "RealKnife" then
				v.Transparency = 1
				
			end
		end
	elseif ModeOfCharacter == "PESSIMISTIC" then
		for i,v in pairs(RK:GetChildren()) do
			if v.Name == "Main" and v.Name ~= "RealKnife" then
				v.Transparency = 1
			elseif v.Name == "RealKnife" then
				v.Transparency = 0	
			end
		end
	end
	if ModeOfCharacter == "SunRise" then
		game.Lighting.ClockTime = 6.12
	else
	game.Lighting.TimeOfDay = 12
	end
	--WING/ABOVE HEAD GUI ANIMATION
	if WingStyle == "Classic" then --Normal
		hahayes = hahayes + 1
		desctextgr.Rotation = hahayes
		linegr.Rotation = hahayes
		textgr.Rotation = hahayes
		textgr.Parent.Rotation = 3 * math.cos(sine/70)
		img1.Rotation = 4 * math.sin(sine/70)
		img1.Position = UDim2.new(0.4,0,0.2 + .06 * math.cos(sine/70),0)
		img3.Rotation = img3.Rotation + RyansOST.PlaybackLoudness/100
		img2.Rotation = hahayes*2
		local Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2 = .1,'Linear','Out',0,false,0
		TweenAnimate(core1weld,{C0=CFrame.new(0,0,0)*angles(math.rad(0),math.rad(0 + hahayes/2),math.rad(0))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(core2weld,{C0=CFrame.new(0,0,0)*angles(math.rad(0),math.rad(45 + hahayes*2),math.rad(0))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(core3weld,{C0=CFrame.new(0,0,0)*angles(math.rad(0),math.rad(45 + hahayes/2),math.rad(0))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(wing1weld,{C0=CFrame.new(0,-.3 + .2 * math.cos(sine/50),-.3 + .05 * math.cos(sine/25))*angles(math.rad(0 + 5 * math.cos(sine/25)),math.rad(12 + 7 * math.cos(sine/25)),math.rad(0+ 5 * math.cos(sine/25)))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(wing2weld,{C0=CFrame.new(0,-.6 + .2 * math.cos(sine/50),-.2 + .05 * math.cos(sine/25))*angles(math.rad(0 + 8 * math.cos(sine/25)),math.rad(14 + 10 * math.cos(sine/25)),math.rad(0+ 8 * math.cos(sine/25)))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(wing3weld,{C0=CFrame.new(0,-.9 + .2 * math.cos(sine/50),-0.05 + .05 * math.cos(sine/25))*angles(math.rad(0 + 13 * math.cos(sine/25)),math.rad(17 + 13 * math.cos(sine/25)),math.rad(0+ 12 * math.cos(sine/25)))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(wing4weld,{C0=CFrame.new(0,-.3 + .2 * math.cos(sine/50),-.3 + .05 * math.cos(sine/25))*angles(math.rad(0 + 5 * math.cos(sine/25)),math.rad(-12 - 7 * math.cos(sine/25)),math.rad(0- 5 * math.cos(sine/25)))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(wing5weld,{C0=CFrame.new(0,-.6 + .2 * math.cos(sine/50),-.2 + .05 * math.cos(sine/25))*angles(math.rad(0 + 8 * math.cos(sine/25)),math.rad(-14 - 10 * math.cos(sine/25)),math.rad(0- 8 * math.cos(sine/25)))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(wing6weld,{C0=CFrame.new(0,-.9 + .2 * math.cos(sine/50),-0.05 + .05 * math.cos(sine/25))*angles(math.rad(0 + 13 * math.cos(sine/25)),math.rad(-17 - 13 * math.cos(sine/25)),math.rad(0- 12 * math.cos(sine/25)))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
	elseif WingStyle == "ClassicSlow" then
		hahayes = hahayes + 1
		desctextgr.Rotation = hahayes
		linegr.Rotation = hahayes
		textgr.Rotation = hahayes
		textgr.Parent.Rotation = 3 * math.cos(sine/100)
		img1.Rotation = 4 * math.sin(sine/100)
		img1.Position = UDim2.new(0.4,0,0.2 + .06 * math.cos(sine/100),0)
		img3.Rotation = img3.Rotation + RyansOST.PlaybackLoudness/100
		img2.Rotation = hahayes*2
		local Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2 = .1,'Linear','Out',0,false,0
		TweenAnimate(core1weld,{C0=CFrame.new(0,0,0)*angles(math.rad(0),math.rad(0 + hahayes/2),math.rad(0))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(core2weld,{C0=CFrame.new(0,0,0)*angles(math.rad(0),math.rad(45 + hahayes*2),math.rad(0))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(core3weld,{C0=CFrame.new(0,0,0)*angles(math.rad(0),math.rad(45 + hahayes/2),math.rad(0))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(wing1weld,{C0=CFrame.new(0,-.3 + .2 * math.cos(sine/100),-.3 + .05 * math.cos(sine/45))*angles(math.rad(0 + 5 * math.cos(sine/45)),math.rad(12 + 7 * math.cos(sine/45)),math.rad(0+ 5 * math.cos(sine/45)))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(wing2weld,{C0=CFrame.new(0,-.6 + .2 * math.cos(sine/100),-.2 + .05 * math.cos(sine/45))*angles(math.rad(0 + 8 * math.cos(sine/45)),math.rad(14 + 10 * math.cos(sine/45)),math.rad(0+ 8 * math.cos(sine/45)))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(wing3weld,{C0=CFrame.new(0,-.9 + .2 * math.cos(sine/100),-0.05 + .05 * math.cos(sine/45))*angles(math.rad(0 + 13 * math.cos(sine/45)),math.rad(17 + 13 * math.cos(sine/45)),math.rad(0+ 12 * math.cos(sine/45)))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(wing4weld,{C0=CFrame.new(0,-.3 + .2 * math.cos(sine/100),-.3 + .05 * math.cos(sine/45))*angles(math.rad(0 + 5 * math.cos(sine/45)),math.rad(-12 - 7 * math.cos(sine/45)),math.rad(0- 5 * math.cos(sine/45)))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(wing5weld,{C0=CFrame.new(0,-.6 + .2 * math.cos(sine/100),-.2 + .05 * math.cos(sine/45))*angles(math.rad(0 + 8 * math.cos(sine/45)),math.rad(-14 - 10 * math.cos(sine/45)),math.rad(0- 8 * math.cos(sine/45)))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(wing6weld,{C0=CFrame.new(0,-.9 + .2 * math.cos(sine/100),-0.05 + .05 * math.cos(sine/45))*angles(math.rad(0 + 13 * math.cos(sine/45)),math.rad(-17 - 13 * math.cos(sine/45)),math.rad(0- 12 * math.cos(sine/45)))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)

	elseif WingStyle == "StarterMode" then --Starter Mode (Mode 1)
		hahayes = hahayes + 1
		desctextgr.Rotation = hahayes
		linegr.Rotation = hahayes
		textgr.Rotation = hahayes
		textgr.Parent.Rotation = 3 * math.cos(sine/70)
		img1.Rotation = 4 * math.sin(sine/70)
		img1.Position = UDim2.new(0.4,0,0.2 + .06 * math.cos(sine/70),0)
		img3.Rotation = img3.Rotation + RyansOST.PlaybackLoudness/100
		img2.Rotation = hahayes*2
		local Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2 = .1,'Linear','Out',0,false,0
		TweenAnimate(core1weld,{C0=CFrame.new(0,0,0)*angles(math.rad(0),math.rad(0 + hahayes/2),math.rad(0))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(core2weld,{C0=CFrame.new(0,0,0)*angles(math.rad(0),math.rad(45 + hahayes*2),math.rad(0))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(core3weld,{C0=CFrame.new(0,0,0)*angles(math.rad(0),math.rad(45 + hahayes/2),math.rad(0))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(wing1weld,{C0=CFrame.new(0,-.3 + .2 * math.cos(sine/50),-.3 + .05 * math.cos(sine/25))*angles(math.rad(0 + 5 * math.cos(sine/25)),math.rad(12 + 7 * math.cos(sine/25)),math.rad(0+ 5 * math.cos(sine/25)))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(wing2weld,{C0=CFrame.new(0,-.6 + .2 * math.cos(sine/50),-.2 + .05 * math.cos(sine/25))*angles(math.rad(0 + 8 * math.cos(sine/25)),math.rad(14 + 10 * math.cos(sine/25)),math.rad(0+ 8 * math.cos(sine/25)))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(wing3weld,{C0=CFrame.new(0,-.9 + .2 * math.cos(sine/50),-0.05 + .05 * math.cos(sine/25))*angles(math.rad(0 + 13 * math.cos(sine/25)),math.rad(17 + 13 * math.cos(sine/25)),math.rad(0+ 12 * math.cos(sine/25)))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(wing4weld,{C0=CFrame.new(0,-.3 + .2 * math.cos(sine/50),-.3 + .05 * math.cos(sine/25))*angles(math.rad(0 + 5 * math.cos(sine/25)+math.random(-4,4)),math.rad(-12 - 7 * math.cos(sine/25)+math.random(-4,4)),math.rad(0- 5 * math.cos(sine/25)+math.random(-4,4)))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(wing5weld,{C0=CFrame.new(0,-.6 + .2 * math.cos(sine/50),-.2 + .05 * math.cos(sine/25))*angles(math.rad(0 + 8 * math.cos(sine/25)+math.random(-4,4)),math.rad(-14 - 10 * math.cos(sine/25)+math.random(-4,4)),math.rad(0- 8 * math.cos(sine/25)+math.random(-4,4)))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(wing6weld,{C0=CFrame.new(0,-.9 + .2 * math.cos(sine/50),-0.05 + .05 * math.cos(sine/25))*angles(math.rad(0 + 13 * math.cos(sine/25)+math.random(-4,4)),math.rad(-17 - 13 * math.cos(sine/25)+math.random(-4,4)),math.rad(0- 12 * math.cos(sine/25)+math.random(-4,4)))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)

	elseif WingStyle == "FlyingClassic" then --Flying
		hahayes = hahayes + 2
		desctextgr.Rotation = hahayes
		linegr.Rotation = hahayes
		textgr.Rotation = hahayes
		textgr.Parent.Rotation = 2 * math.cos(sine/35)
		img1.Rotation = 3 * math.sin(sine/35)
		img1.Position = UDim2.new(0.4,0,0.2 + .04 * math.cos(sine/35),0)
		img3.Rotation = img3.Rotation + RyansOST.PlaybackLoudness/75
		img2.Rotation = hahayes*2
		local Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2 = .1,'Linear','Out',0,false,0
		TweenAnimate(core1weld,{C0=CFrame.new(0,0,0)*angles(math.rad(0),math.rad(0 + hahayes),math.rad(0))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(core2weld,{C0=CFrame.new(0,0,0)*angles(math.rad(0),math.rad(45 + hahayes*4),math.rad(0))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(core3weld,{C0=CFrame.new(0,0,0)*angles(math.rad(0),math.rad(45 + hahayes),math.rad(0))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(wing1weld,{C0=CFrame.new(0,-.3 + .2 * math.cos(sine/25),-.3 + .05 * math.cos(sine/12.5))*angles(math.rad(0 + 5 * math.cos(sine/12.5)),math.rad(12 + 7 * math.cos(sine/12.5)),math.rad(0+ 5 * math.cos(sine/12.5)))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(wing2weld,{C0=CFrame.new(0,-.6 + .2 * math.cos(sine/25),-.2 + .05 * math.cos(sine/12.5))*angles(math.rad(0 + 8 * math.cos(sine/12.5)),math.rad(14 + 10 * math.cos(sine/12.5)),math.rad(0+ 8 * math.cos(sine/12.5)))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(wing3weld,{C0=CFrame.new(0,-.9 + .2 * math.cos(sine/25),-0.05 + .05 * math.cos(sine/12.5))*angles(math.rad(0 + 13 * math.cos(sine/12.5)),math.rad(17 + 13 * math.cos(sine/12.5)),math.rad(0+ 12 * math.cos(sine/12.5)))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(wing4weld,{C0=CFrame.new(0,-.3 + .2 * math.cos(sine/25),-.3 + .05 * math.cos(sine/12.5))*angles(math.rad(0 + 5 * math.cos(sine/12.5)),math.rad(-12 - 7 * math.cos(sine/12.5)),math.rad(0- 5 * math.cos(sine/12.5)))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(wing5weld,{C0=CFrame.new(0,-.6 + .2 * math.cos(sine/25),-.2 + .05 * math.cos(sine/12.5))*angles(math.rad(0 + 8 * math.cos(sine/12.5)),math.rad(-14 - 10 * math.cos(sine/12.5)),math.rad(0- 8 * math.cos(sine/12.5)))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
		TweenAnimate(wing6weld,{C0=CFrame.new(0,-.9 + .2 * math.cos(sine/25),-0.05 + .05 * math.cos(sine/12.5))*angles(math.rad(0 + 13 * math.cos(sine/12.5)),math.rad(-17 - 13 * math.cos(sine/12.5)),math.rad(0- 12 * math.cos(sine/12.5)))},Alpha2,Easing2,Direction2,Repeat2,Reverse2,Delay2)
	else
	end
	

	--COLOR LOOPS
	if CanLoop == true then

			if ModeOfCharacter == "Exasperation" then
			local mult = (math.sin(sine/25) + 1)/2
			one = Color3.fromRGB(0, 150, 0):Lerp(Color3.fromRGB(0, 255, 255),mult)
			two = Color3.fromRGB(0, 255, 255):Lerp(Color3.fromRGB(0, 150, 0),mult)
				ModeSwitchLoop({

					Name = "Exasperation",
					desc = "You're in for a hell of a ride.",
					font = "Ubuntu",
					modestring = "Exasperation",
					wcol1 = one,
					wcol2 = two,
					wcorecol1 = one,
					wcorecol2 = two,
					wtr1 = 0,
					wtr2 = math.random(5,6)/10,
					wstyle = "StarterMode",
					txtg1 = ColorSequence.new(one,two),
					txtg2 = ColorSequence.new(two,one),
					txtg3 = ColorSequence.new(one,two),
					ExtraOptions = false,
					--Extra options
					Unleashed = false,
					--Adds a DBZ-Like Effect to the character
					HealthCap = 100,
					--Maxes the health to a specific value, Could be used for OP modes to nerf them






			})
			elseif ModeOfCharacter == "Crim" then

				one = Color3.new(math.random(0,1),0,0)
			two = Color3.new(math.random(0,1),0,0)
				ModeSwitchLoop({

					Name = "CRIMINALITIC",
					desc = "One vassile hatred....",
					font = "SciFi",
					modestring = "Crim",
					wcol1 = one,
					wcol2 = two,
					wcorecol1 = one,
					wcorecol2 = two,
					wtr1 = 0,
					wtr2 = math.random(5,6)/10,
					wstyle = "StarterMode",
					txtg1 = ColorSequence.new(one,two),
					txtg2 = ColorSequence.new(two,one),
					txtg3 = ColorSequence.new(one,two),
					ExtraOptions = false,
					--Extra options
					Unleashed = false,
					--Adds a DBZ-Like Effect to the character
					HealthCap = 100,
					--Maxes the health to a specific value, Could be used for OP modes to nerf them






			})
		elseif ModeOfCharacter == "DISTURBED" then

			one = Color3.fromRGB(0,0 + 255 * RyansOST.PlaybackLoudness/480,0)
			two = Color3.new(0 + 1 * math.cos(sine/9),0 + 1 * math.cos(sine/9),0 + 1 * math.cos(sine/9))
			ModeSwitchLoop({

				Name = "DISTURBED",
				desc = "He's been through a lot. Nothing can save him from his emotion....",
				font = "SciFi",
				modestring = "DISTURBED",
				wcol1 = one,
				wcol2 = two,
				wcorecol1 = one,
				wcorecol2 = two,
				wtr1 = 0,
				wtr2 = math.random(4,5)/10,
				wstyle = "StarterMode",
				txtg1 = ColorSequence.new(one,two),
				txtg2 = ColorSequence.new(two,one),
				txtg3 = ColorSequence.new(one,two),
				ExtraOptions = false,
				--Extra options
				Unleashed = false,
				--Adds a DBZ-Like Effect to the character
				HealthCap = 100,
				--Maxes the health to a specific value, Could be used for OP modes to nerf them






			})
		elseif ModeOfCharacter == "Exstatic" then
			ModeSwitchLoop({

				Name = "Exstatic",
				desc = "Let's party!",
				font = "FredokaOne",
				modestring = "Exstatic",
				wcol1 = Color3.fromRGB(0,RyansOST.PlaybackLoudness/5,RyansOST.PlaybackLoudness/5),
				wcol2 = Color3.fromRGB(0,0,RyansOST.PlaybackLoudness/5),
				wcorecol1 = Color3.fromRGB(0,0,RyansOST.PlaybackLoudness/5),
				wcorecol2 = Color3.fromRGB(0,RyansOST.PlaybackLoudness/5,RyansOST.PlaybackLoudness/5),
				wtr1 = 0,
				wtr2 = 0,
				wstyle = "Classic",
				txtg1 = ColorSequence.new(Color3.fromRGB(0,RyansOST.PlaybackLoudness/5,RyansOST.PlaybackLoudness/5),Color3.fromRGB(0,0,RyansOST.PlaybackLoudness/5)),
				txtg2 = ColorSequence.new(Color3.fromRGB(0,0,RyansOST.PlaybackLoudness/5),Color3.fromRGB(0,RyansOST.PlaybackLoudness/5,RyansOST.PlaybackLoudness/5)),
				txtg3 = ColorSequence.new(Color3.fromRGB(0,RyansOST.PlaybackLoudness/5,RyansOST.PlaybackLoudness/5),Color3.fromRGB(0,0,RyansOST.PlaybackLoudness/5)),
				musicid = 4862131378,
				musicname = "Geoxor & Canonblade - Sakura",
				musicpit = 1.05,
				musicvol = 1,
				musicpos = "DontChange",
				ws = 40,
				jp = 100,
				emotion = Happy(),
				ExtraOptions = false,
				--Extra options
				Unleashed = false,
				--Adds a DBZ-Like Effect to the character
				HealthCap = 100,
				--Maxes the health to a specific value, Could be used for OP modes to nerf them






			})
		elseif ModeOfCharacter == "That one rainbow mode" then
			ModeSwitchLoop({

				Name = "Prisim",
				desc = "I can't come up with a desc...sorry-",
				font = Enum.Font.GrenzeGotisch,
				modestring = "That one rainbow mode",
				wcol1 = Color3.new(0,0,0),
				wcol2 = Color3.fromHSV(boop(counter),1,1),
				wcorecol1 = Color3.fromHSV(boop(counter),1,1),
				wcorecol2 = Color3.fromHSV(boop(counter),1,1),
				wtr1 = 0,
				wtr2 = 0,
				wstyle = "Classic",
				txtg1 = ColorSequence.new(Color3.fromHSV(boop(counter),1,1),Color3.fromHSV(boop(counter),1,1)),
				txtg2 = ColorSequence.new(Color3.fromHSV(boop(counter),1,1),Color3.fromHSV(boop(counter),1,1)),
				txtg3 = ColorSequence.new(Color3.fromHSV(boop(counter),1,1),Color3.fromHSV(boop(counter),1,1)),
				musicid = 6187072944,
				musicname = "Geoplex - Prismatic",
				musicpit = 1,
				musicvol = 1,
				musicpos = "DontChange",
				ws = 40,
				jp = 100,
				emotion = Happy(),
				ExtraOptions = false,
				--Extra options
				Unleashed = false,
				--Adds a DBZ-Like Effect to the character
				HealthCap = 100,
				--Maxes the health to a specific value, Could be used for OP modes to nerf them






			})
		elseif ModeOfCharacter == "TENSION" then
			one = Color3.fromRGB(math.random(-255,255),math.random(-255,255),math.random(-255,255))
			two = Color3.fromRGB(0 + 255 * math.cos(sine/3),0,0)
			ModeSwitchLoop({

				Name = "TENSION",
				desc = "He's stressed. He's warned you to leave him alone, now look what you've done.",
				font = "SciFi",
				modestring = "TENSION",
				wcol1 = one,
				wcol2 = two,
				wcorecol1 = one,
				wcorecol2 = two,
				wtr1 = 0,
				wtr2 = math.random(4,5)/10,
				wstyle = "FlyingClassic",
				txtg1 = ColorSequence.new(one,two),
				txtg2 = ColorSequence.new(two,one),
				txtg3 = ColorSequence.new(one,two),
				ExtraOptions = false,
				--Extra options
				Unleashed = false,
				--Adds a DBZ-Like Effect to the character
				HealthCap = 100,
				--Maxes the health to a specific value, Could be used for OP modes to nerf them






			})
	else
		--not a mode
	end
	else
		--Can't loop
	end
	MainFrame.SongName.Text = "Music Name: " ..songnameboi
	 counter = counter + 0.005 --This is for the rainbow function thing! Example to be used: Color3.fromHSV(boop(counter),1,1)
	if youredead == false then
Humanoid.MaxHealth = math.huge
		Humanoid.Health = math.huge
	else
		
	end
swait()
 sine = sine + change
 

    --Footplanting code, no need to modify anything, variable is Vec.X,Y or Z
    local Walking = hum.MoveDirection.magnitude>0
    local FwdDir = (Walking and hum.MoveDirection*root.CFrame.lookVector or Vector3.new())
    local RigDir = (Walking and hum.MoveDirection*root.CFrame.rightVector or Vector3.new())
    local Vec = {
        X=RigDir.X+RigDir.Z,
        Z=FwdDir.X+FwdDir.Z
    };
    local Divide = 1
    if(Vec.Z<0)then
        Divide=math.clamp(-(1.25*Vec.Z),1,2)
    end
    Vec.Z = Vec.Z/Divide
    Vec.X = Vec.X/Divide




local torvel=(RootPart.Velocity*Vector3.new(1,0,1)).magnitude 
local velderp=RootPart.Velocity.y
hitfloor,posfloor=rayCast(RootPart.Position,(CFrame.new(RootPart.Position,RootPart.Position - Vector3.new(0,1,0))).lookVector,4,Character)
coroutine.resume(coroutine.create(function()
					--Eye Blink
	local randomblink = math.random(0,300)
	if randomblink == 0 and blinking == false then
		blinkfunction()
		else
	end
		--Tail Movement
		if MorphedInto == "Jake_D" then
			script.Eyes.LeftEye.Color = JakeD_EyeColor
			script.Eyes.RightEye.Color = JakeD_EyeColor
		elseif MorphedInto == "Derpz" then
			script.Eyes.LeftEye.Color = Derpz_EyeColor
			script.Eyes.RightEye.Color = Derpz_EyeColor
		end
	
	
if hitfloor ~= nil and youredead ~= true then
	local rval = 0 
			freefall = 0
			if ModeOfCharacter == "Exasperation" then
				local mult = (math.sin(sine/25) + 1)/2
				one = Color3.fromRGB(0, 150, 0):Lerp(Color3.fromRGB(0, 176, 255),mult)
							WACKYEFFECT({
								Time = 20, -- Time. Duh
								EffectType = "Box", -- Effect Type. Effect Types: "Box", "Wedge", "Sphere", "Ring", "Wave", "Slash", "Swirl", "Round Slash", "Skull", "Crystal"
								Size = VT(.1,.5,.3), -- Start Size
								Size2 = VT(1.3,.5,.3), -- End Size
								Transparency = 0,-- Start Transparency
								Transparency2 = 1, -- End Transparency
								CFrame = Head.CFrame*CFrame.new(0,.18,-.7)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0 + math.random(-5,5))), -- Start CFrame
								MoveToPos = nil, -- Move to position. You must add .p at the end of a cframe. Do not use angles
								RotationX = 0, -- Rotation X
								RotationY = 0, -- Rotation Y
								RotationZ = 0, -- Rotation Z
								Material = "Neon", -- Material
								Color = one, -- Color (NOT BRICKCOLOR)
								SoundID = nil, -- Sound that plays while effect is being done
								SoundPitch = 0, -- Pitch
								SoundVolume = 10, -- Vol
								UseBoomerangMath = false, -- Boomerang Enabled
								Boomerang = 0, -- Makes it come back to start position
								SizeBoomerang = 50 -- Makes it come back to start size
				})
			elseif ModeOfCharacter == "That one rainbow mode" then
				WACKYEFFECT({
					Time = 20, -- Time. Duh
					EffectType = "Box", -- Effect Type. Effect Types: "Box", "Wedge", "Sphere", "Ring", "Wave", "Slash", "Swirl", "Round Slash", "Skull", "Crystal"
					Size = VT(0.5,0.5,0.5), -- Start Size
					Size2 = VT(math.random(0.1,.5) + RyansOST.PlaybackLoudness/250, math.random(0.1,.5) +RyansOST.PlaybackLoudness/250,math.random(0.1,.5) + RyansOST.PlaybackLoudness/250), -- End Size
					Transparency = 0,-- Start Transparency
					Transparency2 = 1, -- End Transparency
					CFrame = larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(0 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))), -- Start CFrame
					MoveToPos = nil, -- Move to position. You must add .p at the end of a cframe. Do not use angles
					RotationX = 0, -- Rotation X
					RotationY = 0, -- Rotation Y
					RotationZ = 0, -- Rotation Z
					Material = "Neon", -- Material
					Color = Color3.fromHSV(boop(counter),1,1), -- Color (NOT BRICKCOLOR)
					SoundID = nil, -- Sound that plays while effect is being done
					SoundPitch = 0, -- Pitch
					SoundVolume = 10, -- Vol
					UseBoomerangMath = false, -- Boomerang Enabled
					Boomerang = 0, -- Makes it come back to start position
					SizeBoomerang = 50 -- Makes it come back to start size
				})
				WACKYEFFECT({
					Time = 20, -- Time. Duh
					EffectType = "Box", -- Effect Type. Effect Types: "Box", "Wedge", "Sphere", "Ring", "Wave", "Slash", "Swirl", "Round Slash", "Skull", "Crystal"
					Size = VT(0.5,0.5,0.5), -- Start Size
					Size2 = VT(math.random(0.1,.5) + RyansOST.PlaybackLoudness/250, math.random(0.1,.5) +RyansOST.PlaybackLoudness/250,math.random(0.1,.5) + RyansOST.PlaybackLoudness/250), -- End Size
					Transparency = 0,-- Start Transparency
					Transparency2 = 1, -- End Transparency
					CFrame = rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(0 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))), -- Start CFrame
					MoveToPos = nil, -- Move to position. You must add .p at the end of a cframe. Do not use angles
					RotationX = 0, -- Rotation X
					RotationY = 0, -- Rotation Y
					RotationZ = 0, -- Rotation Z
					Material = "Neon", -- Material
					Color = Color3.fromHSV(boop(counter),1,1), -- Color (NOT BRICKCOLOR)
					SoundID = nil, -- Sound that plays while effect is being done
					SoundPitch = 0, -- Pitch
					SoundVolume = 10, -- Vol
					UseBoomerangMath = false, -- Boomerang Enabled
					Boomerang = 0, -- Makes it come back to start position
					SizeBoomerang = 50 -- Makes it come back to start size
				})
			elseif ModeOfCharacter == "Theories" then
				sphere2(8,"Add",rarm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("New Yeller"))
				sphere2(8,"Add",larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))),vt(1,1,1),-0.01,0.05,-0.01,BrickColor.new("Cyan"))
				sphereMK(2,-0.5,"Add",root.CFrame*CFrame.new(math.random(-5,5),math.random(-5,5),8)*CFrame.Angles(math.rad(90),math.rad(0),math.rad(0)),0.5,0.5,20,-0.0075,BrickColor.new("New Yeller"),0)
			elseif ModeOfCharacter == "flying boi" then
				WACKYEFFECT({
					Time = 20, -- Time. Duh
					EffectType = "Box", -- Effect Type. Effect Types: "Box", "Wedge", "Sphere", "Ring", "Wave", "Slash", "Swirl", "Round Slash", "Skull", "Crystal"
					Size = VT(0.5,0.5,0.5), -- Start Size
					Size2 = VT(math.random(0.1,.5) + RyansOST.PlaybackLoudness/250, math.random(0.1,.5) +RyansOST.PlaybackLoudness/250,math.random(0.1,.5) + RyansOST.PlaybackLoudness/250), -- End Size
					Transparency = 0,-- Start Transparency
					Transparency2 = 1, -- End Transparency
					CFrame = larm.CFrame*CFrame.new(0,-1,0)*CFrame.Angles(math.rad(0 + math.random(-360,360)),math.rad(math.random(-360,360)),math.rad(math.random(-360,360))), -- Start CFrame
					MoveToPos = nil, -- Move to position. You must add .p at the end of a cframe. Do not use angles
					RotationX = 0, -- Rotation X
					RotationY = 0, -- Rotation Y
					RotationZ = 0, -- Rotation Z
					Material = "Neon", -- Material
					Color = Color3.fromRGB(0,0,150 + 190 * RyansOST.PlaybackLoudness/480), -- Color (NOT BRICKCOLOR)
					SoundID = nil, -- Sound that plays while effect is being done
					SoundPitch = 0, -- Pitch
					SoundVolume = 10, -- Vol
					UseBoomerangMath = false, -- Boomerang Enabled
					Boomerang = 0, -- Makes it come back to start position
					SizeBoomerang = 50 -- Makes it come back to start size
				})
			elseif ModeOfCharacter == "Serene" then
				WACKYEFFECT({
					Time = 30, -- Time. Duh
					EffectType = "Sphere", -- Effect Type. Effect Types: "Box", "Wedge", "Sphere", "Ring", "Wave", "Slash", "Swirl", "Round Slash", "Skull", "Crystal"
					Size = VT(0.01,0.01,0.01), -- Start Size
					Size2 = VT(0.3, math.random(3,6), 0.3), -- End Size
					Transparency = 0.4,-- Start Transparency
					Transparency2 = 1, -- End Transparency
					CFrame = root.CFrame*CFrame.new(math.random(-6,6),-3,math.random(-6,6))*CFrame.Angles(math.rad(0 + math.random(-3,3)),math.rad(math.random(-3,3)),math.rad(math.random(-3,3))), -- Start CFrame
					MoveToPos = nil, -- Move to position. You must add .p at the end of a cframe. Do not use angles
					RotationX = 0, -- Rotation X
					RotationY = 0, -- Rotation Y
					RotationZ = 0, -- Rotation Z
					Material = "Neon", -- Material
					Color = Color3.fromRGB(0,155+100*math.cos(sine/40),155+100*math.cos(sine/40)), -- Color (NOT BRICKCOLOR)
					SoundID = nil, -- Sound that plays while effect is being done
					SoundPitch = 0, -- Pitch
					SoundVolume = 10, -- Vol
					UseBoomerangMath = false, -- Boomerang Enabled
					Boomerang = 0, -- Makes it come back to start position
					SizeBoomerang = 50 -- Makes it come back to start size
				})
				
			end
--			WACKYEFFECT({
--				Time = 30, -- Time. Duh
--				EffectType = "Sphere", -- Effect Type. Effect Types: "Box", "Wedge", "Sphere", "Ring", "Wave", "Slash", "Swirl", "Round Slash", "Skull", "Crystal"
--				Size = VT(0.01,0.01,0.01), -- Start Size
--				Size2 = VT(0.3, math.random(3,6), 0.3), -- End Size
--				Transparency = 0.4,-- Start Transparency
--				Transparency2 = 1, -- End Transparency
--				CFrame = root.CFrame*CFrame.new(math.random(-6,6),-3,math.random(-6,6))*CFrame.Angles(math.rad(0 + math.random(-3,3)),math.rad(math.random(-3,3)),math.rad(math.random(-3,3))), -- Start CFrame
--				MoveToPos = nil, -- Move to position. You must add .p at the end of a cframe. Do not use angles
--				RotationX = 0, -- Rotation X
--				RotationY = 0, -- Rotation Y
--				RotationZ = 0, -- Rotation Z
--				Material = "Neon", -- Material
--				Color = Color3.fromRGB(0,155+100*math.cos(sine/40),155+100*math.cos(sine/40)), -- Color (NOT BRICKCOLOR)
--				SoundID = nil, -- Sound that plays while effect is being done
--				SoundPitch = 0, -- Pitch
--				SoundVolume = 10, -- Vol
--				UseBoomerangMath = false, -- Boomerang Enabled
--				Boomerang = 0, -- Makes it come back to start position
--				SizeBoomerang = 50 -- Makes it come back to start size
--})
end
end))
if tired == false then
particles.Enabled = false
--Happy()
RyansOST:Resume()
sleepymusic:Pause()
elseif tired == true then
particles.Enabled = true
--Sleeping()
sleepymusic:Resume()
RyansOST:Pause()
end
if equipped==true or equipped==false then
if attack==false and Anim == "Idle" then
idle=idle+1
else
idle=0
tired = false
end
if idle>=30000 then
if attack==false then
tired = true
end
end

		if hum:GetState() == Enum.HumanoidStateType.Swimming and torvel<1 and hum.Sit ~= true then
Anim="SwimIdle"
			if attack == false then
				youredead = false
  	local Alpha = .3
if SwimType ~= "ICANTSWIMIMUSEDTOFLYING" then
hum.WalkSpeed = storehumanoidWS
local rm = math.random(1,100)
if rm == 1 then
--soundeffect(357616080,0.95,hed,10,0,"HELP")
else end
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,-0.1)*angles(math.rad(0 + 20 * math.cos(sine/10)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.5,-0.6)*angles(math.rad(0- 20 * math.cos(sine/10)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.4,0.6,-0.1)*angles(math.rad(70.5),math.rad(-15.8),math.rad(-53.9 + 40 * math.cos(sine/30))),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.7,0.5,-0.1)*angles(math.rad(64.7),math.rad(19),math.rad(43.1 - 40 * math.cos(sine/30))),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*necko,.1)
elseif SwimType == "ICANTSWIMIMUSEDTOFLYING" then
	local rm = math.random(1,30)
if rm == 1 then
soundeffect(357616080,0.95,hed,10,0,"HELP")


else end
--Static1:Resume()
	hum.WalkSpeed = 0
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,-0.1)*angles(math.rad(11.2),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.5,-0.6)*angles(math.rad(-24.8),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.4,0.6,-0.1)*angles(math.rad(160),math.rad(-15.8),math.rad(-53.9 + 40 * math.cos(sine/9))),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.7,0.5,-0.1)*angles(math.rad(160),math.rad(19),math.rad(43.1 - 40 * math.cos(sine/11))),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,-0.7)*angles(math.rad(40),math.rad(0),math.rad(0))*necko,.1)
end
end
elseif hum:GetState() == Enum.HumanoidStateType.Swimming and torvel>1 and hum.Sit ~= true then
	Anim="Swim"
	local rm = math.random(1,150)
if rm == 1 then
soundeffect(357616080,0.95,hed,1,0,"HELP")
else end
	if attack == false then
		hum.WalkSpeed = 16
		local Alpha = .3
		if SwimType == 1 then
	--Front crawl
	aerrtee = aerrtee + 10
			hum.WalkSpeed = 16
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1.1,0.2)*angles(math.rad(-5 - 20 * math.cos(sine/7)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.8,-0.1)*angles(math.rad(5 + 20 * math.cos(sine/7)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.5,0.5,0)*angles(math.rad(180 + aerrtee),math.rad(0),math.rad(0)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.5,0)*angles(math.rad(0 + aerrtee),math.rad(0),math.rad(0)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.1,-0.5)*angles(math.rad(28.4),math.rad(0),math.rad(0))*necko,.1)
		elseif SwimType == 2 then
			--Back stroke
				aerrtee = aerrtee + 10
						hum.WalkSpeed = 16
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(0),math.rad(180),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1.1,0.2)*angles(math.rad(-5 + 20 * math.cos(sine/7)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.8,-0.1)*angles(math.rad(5 - 20 * math.cos(sine/7)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.5,0.5,0)*angles(math.rad(180 - aerrtee),math.rad(0),math.rad(0)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.5,0)*angles(math.rad(0 - aerrtee),math.rad(0),math.rad(0)),Alpha)
  	  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*necko,.1)
		elseif SwimType == 3 then
			--Butterfly
				aerrtee = aerrtee + 10
						hum.WalkSpeed = 16
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(0 - 5 * math.cos(sine/3.5)),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1.1,0.2)*angles(math.rad(-5 + 20 * math.cos(sine/7)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.8,-0.1)*angles(math.rad(5 + 20 * math.cos(sine/7)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.5,0.5,0)*angles(math.rad(180 - aerrtee),math.rad(0),math.rad(0)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.5,0)*angles(math.rad(180 - aerrtee),math.rad(0),math.rad(0)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.1,-0.5)*angles(math.rad(28.4),math.rad(0),math.rad(0))*necko,.1)
		elseif SwimType == 4 then
					--Breast Stroke (Don't mind the name, That's actually what it's called.)
					coroutine.resume(coroutine.create(function()
						if doinglol == false then
							doinglol = true
						
		  for i = 0, 1, 0.1 do
								  	swait()
								if Anim ~= "Swim" then
									else
  	local Alpha = .25
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(10),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1.4,-0.6,-0.7)*angles(math.rad(-19.8),math.rad(-5.8),math.rad(15.6))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1.5,-0.5,-0.4)*angles(math.rad(0),math.rad(0),math.rad(-22.8))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1,1.2,-1)*angles(math.rad(141),math.rad(-22.7),math.rad(23.8)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(0.6,0.8,-1.2)*angles(math.rad(133.9),math.rad(-15.4),math.rad(-15.2)),Alpha)
									  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,-0.2)*angles(math.rad(5.9),math.rad(0),math.rad(0))*necko,Alpha)
																	end
		  end
		  for i = 0, 1, 0.1 do
								  	swait()
																if Anim ~= "Swim" then
									else
  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(-10),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-0.6,-0.5,0.1)*angles(math.rad(-0.3),math.rad(-8.5),math.rad(-51))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(0.9,-0.7,0)*angles(math.rad(0),math.rad(0),math.rad(40))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.8,1.1,-0.5)*angles(math.rad(141),math.rad(-22.7),math.rad(-45.6)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.4,0.5,-0.2)*angles(math.rad(139.1),math.rad(-4.1),math.rad(66)),Alpha)
									  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.2,-0.7)*angles(math.rad(28),math.rad(0),math.rad(0))*necko,Alpha)
									end
		  end
		  for i = 0, 1, 0.1 do
  	swait()
								  	local Alpha = .1
																if Anim ~= "Swim" then
									else
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,0)*angles(math.rad(-0.3),math.rad(-8.5),math.rad(-8.2))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-1,0)*angles(math.rad(0),math.rad(0),math.rad(-1.4))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-0.8,0.8,-0.8)*angles(math.rad(141),math.rad(-22.7),math.rad(76.2)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.3,0.6,-0.6)*angles(math.rad(107.2),math.rad(5),math.rad(-49.4)),Alpha)
									  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.2,-0.7)*angles(math.rad(28),math.rad(0),math.rad(0))*necko,Alpha)
									end
						  end
											doinglol = false
					else
					end
						end))
					
			end
	end
				elseif Humanoid:GetState() == Enum.HumanoidStateType.Climbing and Humanoid.MoveDirection ~= Vector3.new(0,0,0) and hum.Sit ~= true then
					Anim = "Climbing"
			Humanoid.WalkSpeed = 16
			coroutine.resume(coroutine.create(function()
				if doinglol == false then
					
				doinglol = true
					  for i = 0, 2, 0.1 do
						  	swait()
						if Anim == "Climbing" then
  	local Alpha = .2
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0.5,-0.2)*angles(math.rad(-5.1),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-0.5,-0.6)*angles(math.rad(9),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.3,-0.7)*angles(math.rad(11.9),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.4,0.5,0.2)*angles(math.rad(69.8),math.rad(8.4),math.rad(-27.9)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.4,0.2,0.1)*angles(math.rad(104.6),math.rad(-29),math.rad(19.6)),Alpha)
							  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.1,-0.4)*angles(math.rad(25.5),math.rad(0.6),math.rad(0))*necko,Alpha)
							else end
					  end
					Humanoid.WalkSpeed = 25
					  for i = 0, 3, 0.1 do
						if Anim == "Climbing" then
  	swait()
  	local Alpha = .25
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,3.3,0)*angles(math.rad(-21.5),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1.2,-0.3)*angles(math.rad(-21.2),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-1.1,-0.4)*angles(math.rad(-17.6),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.5,1.5,0.1)*angles(math.rad(168),math.rad(-28.8),math.rad(-3.5)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,1.2,-0.1)*angles(math.rad(179.6),math.rad(-11.2),math.rad(10.4)),Alpha)
							  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.2,-0.6)*angles(math.rad(34.4),math.rad(0.6),math.rad(-0.1))*necko,Alpha)
							else end
					  end
					Humanoid.WalkSpeed = 20
					  for i = 0, 2, 0.1 do
						if Anim == "Climbing" then
  	swait()
  	local Alpha = .15
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,2.4,-0.2)*angles(math.rad(-3.7),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1.2,-0.3)*angles(math.rad(-21.8),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-1.1,-0.4)*angles(math.rad(-49.4),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.6,1.1,-0.1)*angles(math.rad(142.3),math.rad(-25),math.rad(-15.3)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,1,-0.1)*angles(math.rad(170.9),math.rad(32.9),math.rad(-10.5)),Alpha)
							  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0.1)*angles(math.rad(-4.4),math.rad(0.6),math.rad(0.3))*necko,Alpha)
							else end
					  end
										Humanoid.WalkSpeed = 16
					 for i = 0, 2, 0.1 do
						if Anim == "Climbing" then
  	swait()
  	local Alpha = .3
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0.8,-0.2)*angles(math.rad(5.3),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-0.3,-0.3)*angles(math.rad(15.3),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.6,-0.6)*angles(math.rad(3.8),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.6,0.8,0)*angles(math.rad(87.6),math.rad(-1.3),math.rad(-29)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.4,0.5,0.1)*angles(math.rad(104.3),math.rad(-2.7),math.rad(15.3)),Alpha)
							  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.1,0.5)*angles(math.rad(-32.9),math.rad(0.3),math.rad(0.5))*necko,Alpha)
							else end
					  end
					doinglol = false
					else
					end
				end))
	if attack == false then
end
	elseif Humanoid.MoveDirection == Vector3.new(0,0,0) and Humanoid:GetState() == Enum.HumanoidStateType.Climbing and  attack == false and hum.Sit ~= true then
		Anim="ClimbingIdle"
		Humanoid.WalkSpeed = storehumanoidWS
		  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0.5,-0.2)*angles(math.rad(-5.1),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-0.5,-0.6)*angles(math.rad(9),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.3,-0.7)*angles(math.rad(11.9),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.4,0.5,0.2)*angles(math.rad(69.8),math.rad(8.4),math.rad(-27.9)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.4,0.2,0.1)*angles(math.rad(104.6),math.rad(-29),math.rad(19.6)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.1,-0.4)*angles(math.rad(25.5),math.rad(0.6),math.rad(0))*necko,Alpha)

		elseif hum.Sit == true then
			Anim="Sitting"
			hum.WalkSpeed = storehumanoidWS
			if sittingstyle == 1 then
				--Sitting on a chair
  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0 -   0.1 * math.cos(sine/50),0.1)*angles(math.rad(10.7),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-0.9,-1+   0.1 * math.cos(sine/50),-0.2)*angles(math.rad(89.5),math.rad(0),math.rad(20.7))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.8+   0.1 * math.cos(sine/50),-0.4)*angles(math.rad(39.5),math.rad(0),math.rad(-23.6))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1,0.2 +  0.1 * math.cos(sine/40),-0.4)*angles(math.rad(54.7),math.rad(0),math.rad(91)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.1,0.1 +  0.1 * math.cos(sine/40),-0.2)*angles(math.rad(32.1),math.rad(-19.9),math.rad(-83)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0.1,0,0.3)*angles(math.rad(-16.7),math.rad(0),math.rad(4.6))*necko,Alpha)

				elseif sittingstyle == 2 then
				--Sitting on a stool
				  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0 + 0.1 * math.cos(sine/50),0)*angles(math.rad(-10.3),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1.1-   0.1 * math.cos(sine/50),-0.4)*angles(math.rad(54.4),math.rad(5.6),math.rad(-7))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(0.9,-0.7-   0.1 * math.cos(sine/50),-0.2)*angles(math.rad(44.3),math.rad(2.5),math.rad(10.8))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-0.7,0 - 0.1 * math.cos(sine/40),-0.6)*angles(math.rad(48.3),math.rad(8.4),math.rad(90.5)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(0.8,0.2 - 0.1 * math.cos(sine/40),-0.4)*angles(math.rad(54.2),math.rad(-19),math.rad(-77.1)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,0)*angles(math.rad(0.1),math.rad(-4.3 - 2 * math.cos(sine/60)),math.rad(2.9))*necko,Alpha)
			elseif sittingstyle == 3 then
				--Sitting on the floor
				  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0 + 0.05 * math.cos(sine/50),0)*angles(math.rad(-8.1),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1.1,-1-   0.1 * math.cos(sine/50),-0.3)*angles(math.rad(89.3),math.rad(0),math.rad(-19.7))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-1-   0.1 * math.cos(sine/50),-0.3)*angles(math.rad(93.4),math.rad(0),math.rad(15.4))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.5,0.1,0.3)*angles(math.rad(-14.4),math.rad(0),math.rad(0)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.4,0.3,-0.3)*angles(math.rad(38.6),math.rad(0),math.rad(-21.8)),Alpha)
				  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(-0.1,0,-0.1)*angles(math.rad(3.4),math.rad(-0.2),math.rad(-3.7))*necko,.02)
			elseif sittingstyle == 4 then
				--chill sit
				  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(28.8),math.rad(0),math.rad(3.8))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-0.9,-1.2,-0.1)*angles(math.rad(24.9),math.rad(19.4),math.rad(27.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-1,0)*angles(math.rad(19.1),math.rad(1.5),math.rad(-13.4))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.2,1.1,0.5)*angles(math.rad(-148),math.rad(11.5),math.rad(51.6)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.1,1,0.8)*angles(math.rad(-148.7),math.rad(9.6),math.rad(-43.7)),Alpha)
				  	Torso.Neck.C0 = Torso.Neck.C0:lerp(necko*angles(math.rad(-14.3),math.rad(-4.9),math.rad(8)),Alpha)
			elseif sittingstyle == 5 then
				--roblox sit
				  	local Alpha = .15
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(0),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,0)*angles(math.rad(90),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-1,0)*angles(math.rad(90),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.5,0.5,0)*angles(math.rad(90),math.rad(0),math.rad(0)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.5,0)*angles(math.rad(90),math.rad(0),math.rad(0)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(necko*angles(math.rad(0),math.rad(0),math.rad(0)),1)
			end

		elseif RootPart.Velocity.y > 1 and hitfloor == nil and hum:GetState() ~= Enum.HumanoidStateType.Swimming and hum:GetState() ~= Enum.HumanoidStateType.Climbing and hum.Sit ~= true then
Anim="Jump"
if attack == false then
				if youredead == true then
					freefalldeathragdoll()
				end
	hum.WalkSpeed = storehumanoidWS
 	local Alpha = .05
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0 + 0.1 * math.cos(sine/29),0.4 - 0.1 * math.cos(sine/30),0 + 0.1 * math.cos(sine/31))*angles(math.rad(17.8 + 3 * math.cos(sine/40)),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,0)*angles(math.rad(-19.7),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.1,-1)*angles(math.rad(-34.2),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.4,0.5,0.4)*angles(math.rad(-17.1 -3 * math.cos(sine/40)),math.rad(29.5),math.rad(-13.8 - 3 * math.cos(sine/30))),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.4,0.5,0.4)*angles(math.rad(-19.4 - 3 * math.cos(sine/40)),math.rad(-22.3),math.rad(11.3 + 3 * math.cos(sine/30))),Alpha)
Torso.Neck.C0=Torso.Neck.C0:lerp(necko*angles(math.rad(-20 - 5 * math.cos(sine/60)),math.rad(0),math.rad(0)),.05)
end
elseif RootPart.Velocity.y < -1  and freefall < 252 and hitfloor==nil and hum:GetState() ~= Enum.HumanoidStateType.Swimming and hum:GetState() ~= Enum.HumanoidStateType.Climbing and hum.Sit ~= true then 
Anim="Fall"
			if attack==false then
								if youredead == true then
					freefalldeathragdoll()
				end
	freefall = freefall + 1
	--print(freefall)
	hum.WalkSpeed = storehumanoidWS
  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0.4 + tors.Velocity.Y/300,0)*angles(math.rad(-17.4),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,0)*angles(math.rad(22.7),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,0.1,-0.5)*angles(math.rad(11.8),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.5,0.6,0.3)*angles(math.rad(104.4 +tors.Velocity.Y/8),math.rad(20.1 +tors.Velocity.Y/8),math.rad(-81.2)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.3,0.4,0.4)*angles(math.rad(89 +tors.Velocity.Y/8),math.rad(-26.7 -tors.Velocity.Y/8),math.rad(90.7)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.1,0.3)*angles(math.rad(-18.4),math.rad(0),math.rad(0))*necko,Alpha)
end
			elseif RootPart.Velocity.y < -1 and freefall > 350 and hitfloor==nil and hum:GetState() ~= Enum.HumanoidStateType.Swimming and hum:GetState() ~= Enum.HumanoidStateType.Climbing and hum.Sit ~= true then
Anim="FreeFall2"
chaeng = 1
			if attack==false then

				if heckfallnum == 1 then
  	local Alpha = .02
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(-123.8 + 5 * math.cos(sine/70)),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-0.3,-0.7)*angles(math.rad(-14.3 - 5 * math.cos(sine/80)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-1.1,0.1)*angles(math.rad(-32 - 5 * math.cos(sine/80)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.4,0.3,0.4)*angles(math.rad(-28.5 - 10 * math.cos(sine/51)),math.rad(28.3),math.rad(-11.5)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.3,0.4)*angles(math.rad(-35.2 - 10 * math.cos(sine/50)),math.rad(-23.3),math.rad(0)),Alpha)
					  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,-0.3)*angles(math.rad(14.8),math.rad(-4.7),math.rad(0.1))*necko,Alpha)
				elseif heckfallnum == 2 then
					youredead = true
					  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(100.1 - 30 * math.cos(sine/34)),math.rad(17 - 30 * math.cos(sine/52)),math.rad(18.7- 30 * math.cos(sine/83)))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,0)*angles(math.rad(42.1 + 10 * math.cos(sine/10)),math.rad(22.4),math.rad(-24.5))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-1,0)*angles(math.rad(63- 10 * math.cos(sine/11)),math.rad(29.1),math.rad(32))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.8,1,-0.5)*angles(math.rad(46.2+ 20 * math.cos(sine/22)),math.rad(-48.4),math.rad(-62.3+ 20 * math.cos(sine/57))),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.7,0.1,-0.4)*angles(math.rad(90.9- 20 * math.cos(sine/36)),math.rad(-31.6),math.rad(32.7- 20 * math.cos(sine/59))),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(necko*angles(math.rad(22.8),math.rad(-10),math.rad(-10.1)),Alpha)
				end
end
elseif RootPart.Velocity.y < -1 and freefall > 250 and freefall <355 and hitfloor==nil and hum:GetState() ~= Enum.HumanoidStateType.Swimming and hum:GetState() ~= Enum.HumanoidStateType.Climbing and hum.Sit ~= true then
Anim="FreeFall1"
chaeng = 1
freefall = freefall + 0.1
--print(freefall)
if attack == false then
  	local Alpha = .1
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,0)*angles(math.rad(-78.1 + 10 * math.cos(sine/50)),math.rad(0),math.rad(0))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-1,0.2)*angles(math.rad(-33.5 - 10 * math.cos(sine/81)),math.rad(6.2),math.rad(-20.6))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-1.3,0.1)*angles(math.rad(-34.1 + 10 * math.cos(sine/80)),math.rad(-4),math.rad(24.4))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.6,1.1,-0.2)*angles(math.rad(102.3 + 10 * math.cos(sine/30)),math.rad(-41.2),math.rad(-68.5)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.4,0.8,0)*angles(math.rad(95.2 - 10 * math.cos(sine/70)),math.rad(38),math.rad(72)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0,-0.2)*angles(math.rad(13.8),math.rad(-4.7),math.rad(0))*necko,Alpha)
end
		elseif torvel < 1 and hitfloor ~= nil and hum:GetState() ~= Enum.HumanoidStateType.Swimming and hum:GetState() ~= Enum.HumanoidStateType.Climbing and hum.Sit ~= true then
			Anim = "Idle"
			if attack == false then
				if youredead == true then
					freefalldeathragdoll()
				end
				if tired == false then
					hum.WalkSpeed = storehumanoidWS
					if ModeOfCharacter == "Exasperation" then
						local Alpha = .1
						RootJoint.C0 = RootJoint.C0:lerp(cf(0,0 + 0.1 * math.cos(sine/70),0)*angles(math.rad(1.5),math.rad(0),math.rad(0))*RootCF,Alpha)
						LH.C0 = LH.C0:lerp(cf(-1,-1 - 0.1 * math.cos(sine/70),0)*angles(math.rad(-0.4),math.rad(5.5),math.rad(-10.4))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
						RH.C0 = RH.C0:lerp(cf(1,-1 - 0.1 * math.cos(sine/70),0)*angles(math.rad(-3.8),math.rad(-15.3),math.rad(6.8))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
						LW.C0 = LW.C0:lerp(cf(-0.8,0.3 -  0.1 * math.cos(sine/35),-0.8)*angles(math.rad(92.8),math.rad(-20.5),math.rad(89.2)),Alpha)
						RW.C0 = RW.C0:lerp(cf(0.5,0.3 -  0.1 * math.cos(sine/35),-0.9)*angles(math.rad(109.3),math.rad(-8.5),math.rad(-95.6)),Alpha)
						Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(-0.1 * math.cos(sine/100),0,0.2)*angles(math.rad(-13.8),math.rad(0.1),math.rad(-5.5 * math.cos(sine/100)))*necko,Alpha)						
					elseif ModeOfCharacter == "Serene" then
						local Alpha = .15
						RootJoint.C0 = RootJoint.C0:lerp(cf(0,0 + .1 * math.cos(sine/30),0)*angles(math.rad(6.6 +3 * math.sin(sine/30)),math.rad(3.2),math.rad(2.1))*RootCF,Alpha)
						LH.C0 = LH.C0:lerp(cf(-1.1,-1.1-.1 * math.cos(sine/30),-0.5)*angles(math.rad(-6.2-3 * math.sin(sine/30)),math.rad(8),math.rad(-10.3))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
						RH.C0 = RH.C0:lerp(cf(1,-1-.1 * math.cos(sine/30),0)*angles(math.rad(-15.6-3 * math.sin(sine/30)),math.rad(-33.9),math.rad(6.3))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
						LW.C0 = LW.C0:lerp(cf(-0.7,0+.1 * math.sin(sine/30),-0.5)*angles(math.rad(89.8 +5 * math.sin(sine/40)),math.rad(-0.3 -4 * math.sin(sine/42)),math.rad(90.1)),Alpha)
						RW.C0 = RW.C0:lerp(cf(0.6,0.2+.1 * math.sin(sine/30),-0.7)*angles(math.rad(89.6 +5 * math.sin(sine/40)),math.rad(-12.2 +4 * math.sin(sine/41)),math.rad(-72.7)),Alpha)
						Torso.Neck.C0 = Torso.Neck.C0:lerp(necko*angles(math.rad(14.1 +4 * math.cos(sine/31)),math.rad(-5),math.rad(-2)),Alpha)
					elseif ModeOfCharacter == "Hostility" then
						local Alpha = .25
						RootJoint.C0 = RootJoint.C0:lerp(cf(0,-0.2 +.05 * math.cos(sine/12.5),-0.1)*angles(math.rad(-23.1 + 5 * math.sin(sine/12.5)),math.rad(-5.9),math.rad(-2.5))*RootCF,Alpha)
						LH.C0 = LH.C0:lerp(cf(-1,-0.7-.05 * math.cos(sine/12.5),-0.5)*angles(math.rad(34.6 - 5 * math.sin(sine/12.5)),math.rad(6.1),math.rad(-1.9))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
						RH.C0 = RH.C0:lerp(cf(1,-1-.05 * math.cos(sine/12.5),-0.4)*angles(math.rad(-13.9 - 5 * math.sin(sine/12.5)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
						LW.C0 = LW.C0:lerp(cf(-1,1,-1)*angles(math.rad(150.7+math.random(-6,6)),math.rad(60.7+math.random(-6,6)),math.rad(41.9+math.random(-6,6))),Alpha)
						RW.C0 = RW.C0:lerp(cf(1.1,0.1,0.6)*angles(math.rad(-55.3+math.random(-6,6)),math.rad(-55.5+math.random(-6,6)),math.rad(-40.8+math.random(-6,6))),Alpha)
						Torso.Neck.C0 = Torso.Neck.C0:lerp(necko*angles(math.rad(-14.8+5 * math.cos(sine/25)+1*math.cos(sine/0.1)),math.rad(-6+1*math.cos(sine/0.2)),math.rad(6.3+1*math.cos(sine/0.3))),.5)
					elseif ModeOfCharacter == "Unrestrained" then

						local Alpha = 0.1	
						RootJoint.C0 = RootJoint.C0:lerp(CFrame.new(0,4+-2*math.cos(sine/45),0)*CFrame.Angles(math.rad(90+19*math.sin(sine/45)),math.rad(22+-22*math.sin(sine/44)),math.rad(9+-10*math.sin(sine/44)))*RootCF,Alpha)	
						LH.C0 = LH.C0:lerp(CFrame.new(-1.2+0.2*math.cos(sine/44),-1,0)*CFrame.Angles(math.rad(33+-22*math.cos(sine/44)),math.rad(3),math.rad(33+-9*math.cos(sine/44)))*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)	
						RH.C0 = RH.C0:lerp(CFrame.new(1,-1,0)*CFrame.Angles(math.rad(3+-22*math.cos(sine/44)),math.rad(0),math.rad(0))*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)	
						LW.C0 = LW.C0:lerp(CFrame.new(-1,0.7+-0.2*math.cos(sine/44),0.7)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(150))*LeftShoulderC0,Alpha)	
						RW.C0 = RW.C0:lerp(CFrame.new(1,0.7+-0.2*math.cos(sine/44),0.7)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(-150))*RightShoulderC0,Alpha)	
						Neck.C0 = Neck.C0:lerp(necko*CFrame.new(0,0,0.08+-0.08*math.cos(sine/44))*CFrame.Angles(math.rad(23+-9*math.cos(sine/44)),math.rad(0),math.rad(0)),Alpha)
					elseif ModeOfCharacter == "Exstatic" then
						local Alpha = .1+RyansOST.PlaybackLoudness/1000
						RootJoint.C0 = RootJoint.C0:lerp(cf(0,0 + .1*math.cos(sine/20),0)*angles(math.rad(-6.1 - 2 * math.sin(sine/20)),math.rad(-40.4),math.rad(-4))*RootCF,Alpha)
						LH.C0 = LH.C0:lerp(cf(-1.2,-1 - .1*math.cos(sine/20),0)*angles(math.rad(10.3 + 2 * math.sin(sine/20)),math.rad(27.4),math.rad(-4.8))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
						RH.C0 = RH.C0:lerp(cf(1,-1 - .1*math.cos(sine/20),0)*angles(math.rad(1.7 + 2 * math.sin(sine/20)),math.rad(-16.4),math.rad(11.3))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
						LW.C0 = LW.C0:lerp(cf(-1.6,0.3,0)*angles(math.rad(-0.7),math.rad(-23.7 - 3 * math.cos(sine/40)),math.rad(-10.1+ 3 * math.cos(sine/40))),Alpha)
						RW.C0 = RW.C0:lerp(cf(1.6,0.3,-0.1)*angles(math.rad(-3.8),math.rad(14.8 + 3 * math.sin(sine/40)),math.rad(14.5 - 3 * math.cos(sine/40))),Alpha)
						Torso.Neck.C0 = Torso.Neck.C0:lerp(necko*angles(math.rad(9.4 - 4 * math.cos(sine/42)+RyansOST.PlaybackLoudness/100),math.rad(8.4),math.rad(43.5)),.4)
					elseif ModeOfCharacter == "Theories" then
						RH.C0=clerp(RH.C0,cf(1,-0.4,-0.65)*angles(math.rad(-15),math.rad(84),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(-10 - 2 * math.cos(sine / 39))),.1)
						LH.C0=clerp(LH.C0,cf(-1,-1,-0.2)*angles(math.rad(-10),math.rad(-84),math.rad(0))*angles(math.rad(-3),math.rad(0 - 1 * math.cos(sine / 56)),math.rad(10 + 6 * math.cos(sine / 31))),.1)
						RootJoint.C0=clerp(RootJoint.C0,RootCF*cf(0,0 + 0.02 * math.cos(sine / 32),2 + 0.15 * math.cos(sine / 32))*angles(math.rad(-5 - 2 * math.cos(sine / 32)),math.rad(0),math.rad(0)),.1)
						Torso.Neck.C0=clerp(Torso.Neck.C0,necko*angles(math.rad(-13 - 2 * math.cos(sine / 37)),math.rad(0 + 1 * math.cos(sine / 58)),math.rad(0 + 2 * math.cos(sine / 53))),.1)
						RW.C0=clerp(RW.C0,cf(1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(-15 + 6 * math.cos(sine / 72)),math.rad(3 - 2 * math.cos(sine / 58)),math.rad(20 + 2 * math.cos(sine / 45))),.1)
						LW.C0=clerp(LW.C0,cf(-1.5,0.5 + 0.025 * math.cos(sine / 45),0)*angles(math.rad(-15 - 7 * math.cos(sine / 66)),math.rad(4 - 3 * math.cos(sine / 59)),math.rad(-24.5 - 4 * math.cos(sine / 45))),.1)
					elseif ModeOfCharacter == "Crim" then

						local Alpha = 0.1	
						RootJoint.C0 = RootJoint.C0:lerp(CFrame.new(0,0+0.09*math.cos(sine/25),0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(9))*RootCF,Alpha)	
						LH.C0 = LH.C0:lerp(CFrame.new(-1,-1+-0.09*math.cos(sine/25),0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(-9))*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)	
						RH.C0 = RH.C0:lerp(CFrame.new(1,-1.3+-0.09*math.cos(sine/25),0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(-9))*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)	
						LW.C0 = LW.C0:lerp(CFrame.new(-1.5,0.59+-0.1*math.sin(sine/25),0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(-9 + 3 * math.cos(sine/25)))*LeftShoulderC0,Alpha)	
						RW.C0 = RW.C0:lerp(CFrame.new(0.9,0.5,-0.6)*CFrame.Angles(math.rad(3 - 3 * math.sin(sine/25)),math.rad(33),math.rad(-160))*RightShoulderC0,Alpha)	
						Neck.C0 = Neck.C0:lerp(necko*CFrame.new(0,0,0)*CFrame.Angles(math.rad(0),math.rad(-9),math.rad(-9)),Alpha)
					elseif ModeOfCharacter == "flying boi" then

						local Alpha = 0.1 + RyansOST.PlaybackLoudness/1000
						RootJoint.C0 = RootJoint.C0:lerp(CFrame.new(-0.09+1*math.sin(sine/25),3+-1*math.cos(sine/25),0.09+-1*math.cos(sine/25))*CFrame.Angles(math.rad(9+-3*math.cos(sine/25)),math.rad(0),math.rad(3+-6*math.cos(sine/25)))*RootCF,Alpha)	
						LH.C0 = LH.C0:lerp(CFrame.new(-1,-0.7+-0.2*math.cos(sine/25),-1)*CFrame.Angles(math.rad(-60+-9*math.cos(sine/25)),math.rad(33),math.rad(0))*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)	
						RH.C0 = RH.C0:lerp(CFrame.new(1,-1+-0.01*math.cos(sine/25),0)*CFrame.Angles(math.rad(-9),math.rad(0),math.rad(9+-10*math.cos(sine/25)))*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)	
						LW.C0 = LW.C0:lerp(CFrame.new(-1.2,-0.4+0.3*math.sin(sine/25),-0.5)*CFrame.Angles(math.rad(-33+9*math.cos(sine/25)),math.rad(33),math.rad(160))*LeftShoulderC0,Alpha)	
						RW.C0 = RW.C0:lerp(CFrame.new(1.5,0.7+-0.2*math.cos(sine/25),0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(20+-20*math.cos(sine/25)))*RightShoulderC0,Alpha)	
						Neck.C0 = Neck.C0:lerp(necko*CFrame.new(0,0,0)*CFrame.Angles(math.rad(9+-3*math.sin(sine/25)),math.rad(0),math.rad(3+-6*math.sin(sine/25))),Alpha)
					elseif ModeOfCharacter == "That one rainbow mode" then
						local Alpha = 0.1	
						RootJoint.C0 = RootJoint.C0:lerp(CFrame.new(0,-0.3+0.1*math.cos(sine/15),0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(9+-3*math.cos(sine/25)))*RootCF,Alpha)	
						LH.C0 = LH.C0:lerp(CFrame.new(-1,-1+-0.1*math.cos(sine/15),-1)*CFrame.Angles(math.rad(-40),math.rad(0),math.rad(-9+3*math.cos(sine/25)))*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)	
						RH.C0 = RH.C0:lerp(CFrame.new(1,-1+-0.1*math.cos(sine/15),-1)*CFrame.Angles(math.rad(-40),math.rad(0),math.rad(-9+3*math.cos(sine/25)))*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)	
						LW.C0 = LW.C0:lerp(CFrame.new(-1,-0.4,-0.9)*CFrame.Angles(math.rad(9+-9*math.cos(sine/25)),math.rad(66+3*math.cos(sine/25)),math.rad(160+-10*math.cos(sine/25)))*LeftShoulderC0,Alpha)	
						RW.C0 = RW.C0:lerp(CFrame.new(1,-0.4,-0.9)*CFrame.Angles(math.rad(-9+9*math.cos(sine/25)),math.rad(-66+-3*math.cos(sine/25)),math.rad(-160+10*math.sin(sine/25)))*RightShoulderC0,Alpha)	
						Neck.C0 = Neck.C0:lerp(necko*CFrame.new(0,0,0)*CFrame.Angles(math.rad(9+-10*math.cos(sine/25)),math.rad(9),math.rad(-9)),Alpha)
					elseif ModeOfCharacter == "HELP IM STUCK FLYING HELP HELP HELP HELP" then

						local Alpha = 0.1	
						RootJoint.C0 = RootJoint.C0:lerp(CFrame.new(0,3+-3*math.cos(sine/15),-3+6*math.cos(sine/25))*CFrame.Angles(math.rad(180+-180*math.cos(sine/15)),math.rad(180+-180*math.cos(sine/15)),math.rad(180+-180*math.cos(sine/15)))*RootCF,Alpha)	
						LH.C0 = LH.C0:lerp(CFrame.new(-1,-1,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)	
						RH.C0 = RH.C0:lerp(CFrame.new(1,-1,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)	
						LW.C0 = LW.C0:lerp(CFrame.new(-1.5,0.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(-90))*LeftShoulderC0,Alpha)	
						RW.C0 = RW.C0:lerp(CFrame.new(1.5,0.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(90))*RightShoulderC0,Alpha)	
						Neck.C0 = Neck.C0:lerp(necko*CFrame.new(0,0,0)*CFrame.Angles(math.rad(180+-180*math.sin(sine/15)),math.rad(180+-180*math.sin(sine/15)),math.rad(180+-180*math.sin(sine/15))),Alpha)
					elseif ModeOfCharacter == "PESSIMISTIC" then


						local Alpha = 0.1	
						RootJoint.C0 = RootJoint.C0:lerp(CFrame.new(0,0+0.09*math.cos(sine/25),0.09)*CFrame.Angles(math.rad(-20),math.rad(0),math.rad(0))*RootCF,Alpha)	
						LH.C0 = LH.C0:lerp(CFrame.new(-1,-1+-0.09*math.cos(sine/25),-0.09)*CFrame.Angles(math.rad(10),math.rad(33),math.rad(-4))*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)	
						RH.C0 = RH.C0:lerp(CFrame.new(1,-1+-0.09*math.cos(sine/25),-0.09)*CFrame.Angles(math.rad(10),math.rad(0),math.rad(9))*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)	
						LW.C0 = LW.C0:lerp(CFrame.new(-1,-0.2+0.2*math.cos(sine/35),-1)*CFrame.Angles(math.rad(19+-9*math.cos(sine/35)),math.rad(0),math.rad(109+-9*math.cos(sine/35)))*LeftShoulderC0,Alpha)	
						RW.C0 = RW.C0:lerp(CFrame.new(1.5,0.59+-0.09*math.cos(sine/25),0)*CFrame.Angles(math.rad(15+-5*math.cos(sine/25)),math.rad(0),math.rad(9+-9*math.cos(sine/35)))*RightShoulderC0,Alpha)	
						Neck.C0 = Neck.C0:lerp(necko*CFrame.new(0,0,0)*CFrame.Angles(math.rad(9+3*math.cos(sine/25)),math.rad(0),math.rad(9+-10*math.cos(sine/25))),Alpha)
					elseif ModeOfCharacter == "SunRise" then

						local Alpha = 0.1	
						RootJoint.C0 = RootJoint.C0:lerp(CFrame.new(0,0+-0.03*math.cos(sine/25),0.2+-0.2*math.sin(sine/25))*CFrame.Angles(math.rad(0),math.rad(9),math.rad(-3))*RootCF,Alpha)	
						LH.C0 = LH.C0:lerp(CFrame.new(-1,-1+0.03*math.cos(sine/25),-0.2+0.2*math.sin(sine/25))*CFrame.Angles(math.rad(0),math.rad(33),math.rad(-9))*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)	
						RH.C0 = RH.C0:lerp(CFrame.new(1,-1+0.03*math.cos(sine/25),-0.2+0.2*math.sin(sine/25))*CFrame.Angles(math.rad(-9),math.rad(-33),math.rad(9))*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)	
						LW.C0 = LW.C0:lerp(CFrame.new(-1.46+-0.04*math.cos(sine/25),0.5,0)*CFrame.Angles(math.rad(-9+9*math.cos(sine/25)),math.rad(9),math.rad(-9+9*math.cos(sine/25)))*LeftShoulderC0,Alpha)	
						RW.C0 = RW.C0:lerp(CFrame.new(1.5,0.5,0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(9+-9*math.cos(sine/25)))*RightShoulderC0,Alpha)	
						Neck.C0 = Neck.C0:lerp(necko*CFrame.new(0.03+-0.06*math.cos(sine/25),0,0)*CFrame.Angles(math.rad(9+-10*math.cos(sine/25)),math.rad(0),math.rad(7+-17*math.cos(sine/25))),Alpha)
					elseif ModeOfCharacter == "DISTURBED" then

						local Alpha = 0.1	
						RootJoint.C0 = RootJoint.C0:lerp(CFrame.new(0,0+0.05*math.cos(sine/15),0)*CFrame.Angles(math.rad(0),math.rad(0),math.rad(0))*RootCF,Alpha)	
						LH.C0 = LH.C0:lerp(CFrame.new(-1,-1+-0.05*math.cos(sine/15),0)*CFrame.Angles(math.rad(-9),math.rad(0),math.rad(-9))*CFrame.Angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)	
						RH.C0 = RH.C0:lerp(CFrame.new(1,-1+-0.05*math.cos(sine/15),0)*CFrame.Angles(math.rad(0),math.rad(-33),math.rad(9))*CFrame.Angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)	
						LW.C0 = LW.C0:lerp(CFrame.new(-1.1,0.2+0.03*math.sin(sine/15),-0.5)*CFrame.Angles(math.rad(45),math.rad(9),math.rad(90+-7*math.cos(sine/15)))*LeftShoulderC0,Alpha)	
						RW.C0 = RW.C0:lerp(CFrame.new(0.6,0.2+0.03*math.sin(sine/15),-1)*CFrame.Angles(math.rad(-45),math.rad(9),math.rad(-90+7*math.cos(sine/15)))*RightShoulderC0,Alpha)	
						Neck.C0 = Neck.C0:lerp(necko*CFrame.new(0,0,0)*CFrame.Angles(math.rad(9+-9*math.cos(sine/15)),math.rad(0),math.rad(0)),Alpha)
					elseif ModeOfCharacter == "TENSION" then
						local Alpha = .1
						TweenAnimate2(RootJoint,{C0=cf(0,-0.9 + .1 * math.cos(sine/34),-0.2)*angles(math.rad(-36.3 + 2 * math.cos(sine/34)),math.rad(0),math.rad(0))*RootCF},Alpha,'Linear','Out',0,false,0)
						TweenAnimate2(LH,{C0=cf(-1,-1 - .1 * math.cos(sine/34),0)*angles(math.rad(-27 - 2 * math.cos(sine/34)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0))},Alpha,'Linear','Out',0,false,0)
						TweenAnimate2(RH,{C0=cf(1,-0.3 - .1 * math.cos(sine/34),-0.1)*angles(math.rad(47.3 - 2 * math.cos(sine/34)),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0))},Alpha,'Linear','Out',0,false,0)
						TweenAnimate2(LW,{C0=cf(-1.4,0.6 - .1 * math.cos(sine/30),0.2)*angles(math.rad(0 + 4 * math.cos(sine/34)),math.rad(24.1),math.rad(-12.3))},Alpha,'Linear','Out',0,false,0)
						TweenAnimate2(RW,{C0=cf(1.3,0.3 - .1 * math.cos(sine/30),-0.6)*angles(math.rad(43.7),math.rad(49.9),math.rad(-9.9))},Alpha,'Linear','Out',0,false,0)
						TweenAnimate2(Torso.Neck,{C0 =cf(0,0,0)*angles(math.rad(1.6),math.rad(1.4),math.rad(-1))*necko},Alpha,'Linear','Out',0,false,0)

					else	
						local Alpha = .1
						RootJoint.C0 = RootJoint.C0:lerp(cf(0,0 - .1 * math.cos(sine/52),0)*angles(math.rad(0 + 3 * math.cos(sine/51)),math.rad(13.3),math.rad(-3.8))*RootCF,Alpha)
						LH.C0 = LH.C0:lerp(cf(-1,-1.1+.1 * math.cos(sine/52),0)*angles(math.rad(-8.3-4 * math.cos(sine/51)),math.rad(14.4),math.rad(1.3))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
						RH.C0 = RH.C0:lerp(cf(1,-1+.1 * math.cos(sine/52),-0.1)*angles(math.rad(5-4 * math.cos(sine/51)),math.rad(-20.6),math.rad(7.6))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
						LW.C0 = LW.C0:lerp(cf(-1.5,0.4- .1 * math.cos(sine/50),0.1)*angles(math.rad(-7.6),math.rad(10.1 + 4 * math.cos(sine/50)),math.rad(-5.8- 2 * math.cos(sine/25))),Alpha)
						RW.C0 = RW.C0:lerp(cf(1.4,0.4 - .1 * math.cos(sine/50),0.3)*angles(math.rad(3.7),math.rad(-24.4- 4 * math.cos(sine/50)),math.rad(8.5+ 2 * math.cos(sine/25))),Alpha)
						Torso.Neck.C0 = Torso.Neck.C0:lerp(necko*angles(math.rad(5.7 - 5 * math.cos(sine/67)),math.rad(1.2 - 4 * math.cos(sine/63)),math.rad(-14.8)),.05)

					end
				
			elseif tired == true then
				  	local Alpha = .05
  	RootJoint.C0 = RootJoint.C0:lerp(cf(0,0,-0.2)*angles(math.rad(-22.2),math.rad(0.3),math.rad(0.1))*RootCF,Alpha)
  	LH.C0 = LH.C0:lerp(cf(-1,-0.9,-0.1)*angles(math.rad(22.7),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
  	RH.C0 = RH.C0:lerp(cf(1,-0.9,-0.2)*angles(math.rad(16.4),math.rad(0),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
  	LW.C0 = LW.C0:lerp(cf(-1.5,0.1,-0.3)*angles(math.rad(24.5),math.rad(0),math.rad(0)),Alpha)
  	RW.C0 = RW.C0:lerp(cf(1.5,0.2,-0.1)*angles(math.rad(19.1),math.rad(0),math.rad(0)),Alpha)
  	Torso.Neck.C0 = Torso.Neck.C0:lerp(cf(0,0.3,0.4)*angles(math.rad(-32.8),math.rad(0),math.rad(0))*necko,1)
				end
			end
		elseif torvel > 2 and torvel < 22 and hitfloor ~= nil and hum:GetState() ~= Enum.HumanoidStateType.Swimming and hum:GetState() ~= Enum.HumanoidStateType.Climbing and hum.Sit ~= true then
			Anim = "Walk"
			if attack == false then
								if youredead == true then
					freefalldeathragdoll()
				end
				if ModeOfCharacter ~= "Exasperation" then
				      local Alpha = .15
local wsv = 3.5
local wsv2 = 7
     RootJoint.C0 = RootJoint.C0:lerp(cf(0,0+0.1*math.cos(sine/wsv),0)*angles(math.rad(0-10*Vec.Z+3*math.cos(sine/wsv)),math.rad(0 + 5 * math.cos(sine/wsv2)),math.rad(0-10*Vec.X))*RootCF,Alpha)
				LH.C0 = LH.C0:lerp(cf(-1+0.2*math.sin(sine/wsv2)*Vec.X,-1+0.3*math.cos(sine/wsv2),-0.4*math.sin(sine/wsv2)*Vec.Z)*angles(math.rad(1+40*math.sin(sine/wsv2)*Vec.Z),math.rad(0-5 * math.cos(sine/wsv2)),math.rad(0+20*Vec.X*math.sin(sine/wsv2)))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
				RH.C0 = RH.C0:lerp(cf(1-0.2*math.sin(sine/wsv2)*Vec.X,-1-0.3*math.cos(sine/wsv2),0.4*math.sin(sine/wsv2)*Vec.Z)*angles(math.rad(-1-40*math.sin(sine/wsv2)*Vec.Z),math.rad(0-5 * math.cos(sine/wsv2)),math.rad(0-20*Vec.X*math.sin(sine/wsv2)))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
				LW.C0 = LW.C0:lerp(cf(-1.5,0.5,0+0.2*math.sin(sine/wsv2)*Vec.Z)*angles(math.rad(0-50*math.sin(sine/wsv2)*Vec.Z-10*math.cos(sine/wsv2)*Vec.X),math.rad(0 - 7 * math.cos(sine/wsv2)),math.rad(-4 + 6 * math.sin(sine/wsv2)*Vec.X)),Alpha)
      RW.C0 = RW.C0:lerp(cf(1.5,0.5,0-0.2*math.sin(sine/wsv2)*Vec.Z)*angles(math.rad(0+50*math.sin(sine/wsv2)*Vec.Z+10*math.cos(sine/wsv2)*Vec.X),math.rad(0 - 7 * math.cos(sine/wsv2)),math.rad(4 - 6 * math.sin(sine/wsv2)*Vec.X)),Alpha)
				Neck.C0 = Neck.C0:lerp(necko*angles(math.rad(0-10*Vec.Z-4*math.sin(sine/wsv)),math.rad(0),math.rad(0-6 * math.cos(sine/wsv2))),.1)
				elseif ModeOfCharacter == "Exasperation" then
					local Alpha = .15
					local wsv = 3.5
					local wsv2 = 7
					RootJoint.C0 = RootJoint.C0:lerp(cf(0,0+0.1*math.cos(sine/wsv),0)*angles(math.rad(0-10*Vec.Z+3*math.cos(sine/wsv)),math.rad(0 + 5 * math.cos(sine/wsv2)),math.rad(0-10*Vec.X))*RootCF,Alpha)
					LH.C0 = LH.C0:lerp(cf(-1+0.2*math.sin(sine/wsv2)*Vec.X,-1+0.3*math.cos(sine/wsv2),-0.4*math.sin(sine/wsv2)*Vec.Z)*angles(math.rad(1+40*math.sin(sine/wsv2)*Vec.Z),math.rad(0-5 * math.cos(sine/wsv2)),math.rad(0+20*Vec.X*math.sin(sine/wsv2)))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
					RH.C0 = RH.C0:lerp(cf(1-0.2*math.sin(sine/wsv2)*Vec.X,-1-0.3*math.cos(sine/wsv2),0.4*math.sin(sine/wsv2)*Vec.Z)*angles(math.rad(-1-40*math.sin(sine/wsv2)*Vec.Z),math.rad(0-5 * math.cos(sine/wsv2)),math.rad(0-20*Vec.X*math.sin(sine/wsv2)))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
					LW.C0 = LW.C0:lerp(cf(-0.8,0.3 -  0.1 * math.cos(sine/35),-0.8)*angles(math.rad(92.8),math.rad(-20.5),math.rad(89.2)),.1)
					RW.C0 = RW.C0:lerp(cf(0.5,0.3 -  0.1 * math.cos(sine/35),-0.9)*angles(math.rad(109.3),math.rad(-8.5),math.rad(-95.6)),.1)
					Neck.C0 = Neck.C0:lerp(necko*angles(math.rad(0-10*Vec.Z-4*math.sin(sine/wsv)),math.rad(0),math.rad(0-6 * math.cos(sine/wsv2))),.1)


				end
			end   
		elseif torvel >= 22 and torvel < 170 and hitfloor ~= nil and hum:GetState() ~= Enum.HumanoidStateType.Swimming and hum:GetState() ~= Enum.HumanoidStateType.Climbing and hum.Sit ~= true then
			Anim = "Run"
			if attack == false then
								if youredead == true then
					freefalldeathragdoll()
				end
				if ModeOfCharacter ~= "Theories" then
      local Alpha = .15
local wsv = 2.5
local wsv2 = 5
     RootJoint.C0 = RootJoint.C0:lerp(cf(0,0+0.15*math.cos(sine/wsv),0)*angles(math.rad(0-25*Vec.Z+3*math.cos(sine/wsv)),math.rad(0),math.rad(0-20*Vec.X))*RootCF,Alpha)
      LH.C0 = LH.C0:lerp(cf(-1+0.4*math.sin(sine/wsv2)*Vec.X,-1+0.5*math.cos(sine/wsv2),-0.4*math.sin(sine/wsv2)*Vec.Z)*angles(math.rad(1+70*math.sin(sine/wsv2)*Vec.Z),math.rad(0),math.rad(0+20*Vec.X*math.sin(sine/wsv2)))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
      RH.C0 = RH.C0:lerp(cf(1-0.4*math.sin(sine/wsv2)*Vec.X,-1-0.5*math.cos(sine/wsv2),0.4*math.sin(sine/wsv2)*Vec.Z)*angles(math.rad(-1-70*math.sin(sine/wsv2)*Vec.Z),math.rad(0),math.rad(0-20*Vec.X*math.sin(sine/wsv2)))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
      LW.C0 = LW.C0:lerp(cf(-1.5,0.5,0+0.2*math.sin(sine/wsv2)*Vec.Z)*angles(math.rad(0-80*math.sin(sine/wsv2)*Vec.Z-10*math.cos(sine/wsv2)*Vec.X),math.rad(0),math.rad(0 + 6 * math.sin(sine/wsv2)*Vec.X)),Alpha)
      RW.C0 = RW.C0:lerp(cf(1.5,0.5,0-0.2*math.sin(sine/wsv2)*Vec.Z)*angles(math.rad(0+80*math.sin(sine/wsv2)*Vec.Z+10*math.cos(sine/wsv2)*Vec.X),math.rad(0),math.rad(0 - 6 * math.sin(sine/wsv2)*Vec.X)),Alpha)
      Neck.C0 = Neck.C0:lerp(necko*angles(math.rad(0-10*Vec.Z-7*math.sin(sine/wsv)),math.rad(0),math.rad(0)),.1)
				elseif ModeOfCharacter == "Theories" then
					local Alpha = 0.2	
					RootJoint.C0 = RootJoint.C0:lerp(cf(0+0.05*math.cos(sine/16),0.7+0.1*math.cos(sine/8),-0.3+0.1*math.sin(sine/16))*angles(math.rad(-60*Vec.Z),math.rad(3*math.cos(sine/30)),math.rad(-20*Vec.X))*RootCF,Alpha)	
					LH.C0 = LH.C0:lerp(cf(-1,-1,-0.1)*angles(math.rad(-25+-5*math.cos(sine/40)),math.rad(10+5*math.cos(sine/60)),math.rad(0))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)	
					RH.C0 = RH.C0:lerp(cf(1,-0.1,-1)*angles(math.rad(-30+5*math.sin(sine/30)),math.rad(-5),math.rad(0))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)	
					LW.C0 = LW.C0:lerp(cf(-1.4+-0.1*math.sin(sine/16),0.1,0.3)*angles(math.rad(-40*Vec.Z),math.rad(-3*math.cos(sine/30)),math.rad(-10+-5*math.sin(sine/16)))*LeftShoulderC0,Alpha)	
					RW.C0 = RW.C0:lerp(cf(1.4+0.1*math.sin(sine/16),0.1,0.3)*angles(math.rad(-40*Vec.Z),math.rad(-3*math.cos(sine/30)),math.rad(10+5*math.sin(sine/16)))*RightShoulderC0,Alpha)	
					Neck.C0 = Neck.C0:lerp(necko*cf(0,-0.1,0)*angles(math.rad(-40*Vec.Z+-4*math.cos(sine/8)),math.rad(0*math.cos(sine/30)),math.rad(0)),Alpha)	


				end	
				end

		elseif torvel > 170 and hitfloor ~= nil and hum:GetState() ~= Enum.HumanoidStateType.Swimming and hum:GetState() ~= Enum.HumanoidStateType.Climbing and hum.Sit ~= true then
			Anim = "FasterRun"
			if attack == false then

      local Alpha = .15
local wsv = 1.5
local wsv2 = 3
     RootJoint.C0 = RootJoint.C0:lerp(cf(0,0+0.15*math.cos(sine/wsv),0)*angles(math.rad(0-35*Vec.Z+3*math.cos(sine/wsv)),math.rad(0),math.rad(0-20*Vec.X))*RootCF,Alpha)
      LH.C0 = LH.C0:lerp(cf(-1+0.5*math.sin(sine/wsv2)*Vec.X,-1+0.6*math.cos(sine/wsv2),-0.4*math.sin(sine/wsv2)*Vec.Z)*angles(math.rad(1+80*math.sin(sine/wsv2)*Vec.Z),math.rad(0),math.rad(0+20*Vec.X*math.sin(sine/wsv2)))*angles(math.rad(0),math.rad(-90),math.rad(0)),Alpha)
      RH.C0 = RH.C0:lerp(cf(1-0.5*math.sin(sine/wsv2)*Vec.X,-1-0.6*math.cos(sine/wsv2),0.4*math.sin(sine/wsv2)*Vec.Z)*angles(math.rad(-1-80*math.sin(sine/wsv2)*Vec.Z),math.rad(0),math.rad(0-20*Vec.X*math.sin(sine/wsv2)))*angles(math.rad(0),math.rad(90),math.rad(0)),Alpha)
      LW.C0 = LW.C0:lerp(cf(-1.5,0.5,0+0.2*math.sin(sine/wsv)*Vec.Z)*angles(math.rad(-50*Vec.Z-10*math.cos(sine/wsv2)*Vec.X),math.rad(0),math.rad(0 + 6 * math.sin(sine/wsv2)*Vec.X)),Alpha)
      RW.C0 = RW.C0:lerp(cf(1.5,0.5,0+0.2*math.sin(sine/wsv)*Vec.Z)*angles(math.rad(-50*Vec.Z+10*math.cos(sine/wsv2)*Vec.X),math.rad(0),math.rad(0 - 6 * math.sin(sine/wsv2)*Vec.X)),Alpha)
      Neck.C0 = Neck.C0:lerp(necko*angles(math.rad(0-10*Vec.Z-5*math.sin(sine/wsv)),math.rad(0),math.rad(0)),.1)

										end
			end
		end
	end
end
 
 
