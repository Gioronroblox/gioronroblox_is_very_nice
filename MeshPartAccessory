game.Players.LocalPlayer.Character["SeeMonkey"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["Pink Hair"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["Kate Hair"].Handle.Mesh:Destroy() --LavanderHair
game.Players.LocalPlayer.Character["LavanderHair"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["Robloxclassicred"].Handle.Mesh:Destroy()
 --VarietyShades02
 --TennisBall

local c = game.Players.LocalPlayer.Character
for i, v in pairs({"Right Arm", "Left Arm"}) do
    local arm = c[v]
    arm.Parent = nil
    arm.Transparency = 1
    arm.Parent = c
end

local c = game.Players.LocalPlayer.Character
for i, v in pairs({"Right Leg", "Left Leg"}) do
    local Leg = c[v]
    Leg.Parent = nil
    Leg.Transparency = 1
    Leg.Parent = c
end

local v3_net, v3_808 = Vector3.new(0, 25.1, 0), Vector3.new(-8, 0, -8)
		local function getNetlessVelocity(realPartVelocity)
			local mag = realPartVelocity.Magnitude
			if mag > -1 then
				local unit = realPartVelocity.Unit
				if (unit.Y > 0.25) or (unit.Y < -0.75) then
					return unit * (25.1 / unit.Y)
				end
			end 
			return v3_net + realPartVelocity * v3_808
		end
		local simradius = "shp" --simulation radius (net bypass) method
--simulation radius (net bypass) method
--"shp" - sethiddenproperty
--"ssr" - setsimulationradius
--false - disable
local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
local newanimate = false --disables the animate script and enables after reanimation
local discharscripts = true --disables all localScripts parented to your character before reanimation
local R15toR6 = true --tries to convert your character to r6 if its r15
local hatcollide = true --makes hats cancollide (only method 0)
local humState16 = true --enables collisions for limbs before the humanoid dies (using hum:ChangeState)
local addtools = false --puts all tools from backpack to character and lets you hold them after reanimation
local hedafterneck = false --disable aligns for head and enable after neck is removed
local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
local method = 0 --reanimation method
--methods:
--0 - breakJoints (takes [loadtime] seconds to laod)
--1 - limbs
--2 - limbs + anti respawn
--3 - limbs + breakJoints after [loadtime] seconds
--4 - remove humanoid + breakJoints
--5 - remove humanoid + limbs
local alignmode = 3 --AlignPosition mode
--modes:
--1 - AlignPosition rigidity enabled true
--2 - 2 AlignPositions rigidity enabled both true and false
--3 - AlignPosition rigidity enabled false

healthHide = healthHide and ((method == 0) or (method == 2) or (method == 000)) and gp(c, "Head", "BasePart")

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = v3(0, 0, 0)
local inf = math.huge

local c = lp.Character

if not (c and c.Parent) then
	return
end

c.Destroying:Connect(function()
	c = nil
end)

local function gp(parent, name, className)
	if typeof(parent) == "Instance" then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end

local function align(Part0, Part1)
	Part0.CustomPhysicalProperties = PhysicalProperties.new(0.0001, 0.0001, 0.0001, 0.0001, 0.0001)

	local att0 = Instance.new("Attachment", Part0)
	att0.Orientation = v3_0
	att0.Position = v3_0
	att0.Name = "att0_" .. Part0.Name
	local att1 = Instance.new("Attachment", Part1)
	att1.Orientation = v3_0
	att1.Position = v3_0
	att1.Name = "att1_" .. Part1.Name

	if (alignmode == 1) or (alignmode == 2) then
		local ape = Instance.new("AlignPosition", att0)
		ape.ApplyAtCenterOfMass = false
		ape.MaxForce = inf
		ape.MaxVelocity = inf
		ape.ReactionForceEnabled = false
		ape.Responsiveness = 200
		ape.Attachment1 = att1
		ape.Attachment0 = att0
		ape.Name = "AlignPositionRtrue"
		ape.RigidityEnabled = true
	end

	if (alignmode == 2) or (alignmode == 3) then
		local apd = Instance.new("AlignPosition", att0)
		apd.ApplyAtCenterOfMass = false
		apd.MaxForce = inf
		apd.MaxVelocity = inf
		apd.ReactionForceEnabled = false
		apd.Responsiveness = 200
		apd.Attachment1 = att1
		apd.Attachment0 = att0
		apd.Name = "AlignPositionRfalse"
		apd.RigidityEnabled = false
	end

	local ao = Instance.new("AlignOrientation", att0)
	ao.MaxAngularVelocity = inf
	ao.MaxTorque = inf
	ao.PrimaryAxisOnly = false
	ao.ReactionTorqueEnabled = false
	ao.Responsiveness = 200
	ao.Attachment1 = att1
	ao.Attachment0 = att0
	ao.RigidityEnabled = false

	if type(getNetlessVelocity) == "function" then
	    local realVelocity = v3_0
        local steppedcon = stepped:Connect(function()
            Part0.Velocity = realVelocity
        end)
        local heartbeatcon = heartbeat:Connect(function()
            realVelocity = Part0.Velocity
            Part0.Velocity = getNetlessVelocity(realVelocity)
        end)
        Part0.Destroying:Connect(function()
            Part0 = nil
            steppedcon:Disconnect()
            heartbeatcon:Disconnect()
        end)
    end
end

local function respawnrequest()
	local ccfr = ws.CurrentCamera.CFrame
	local c = lp.Character
	lp.Character = nil
	lp.Character = c
	local con = nil
	con = ws.CurrentCamera.Changed:Connect(function(prop)
	    if (prop ~= "Parent") and (prop ~= "CFrame") then
	        return
	    end
	    ws.CurrentCamera.CFrame = ccfr
	    con:Disconnect()
    end)
end

local destroyhum = (method == 4) or (method == 5)
local breakjoints = (method == 0) or (method == 4)
local antirespawn = (method == 0) or (method == 2) or (method == 3)

hatcollide = hatcollide and (method == 0)

addtools = addtools and gp(lp, "Backpack", "Backpack")

local fenv = getfenv()
local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.set_simulation_rad or fenv.setsimulationrad

if shp and (simradius == "shp") then
	spawn(function()
		while c and heartbeat:Wait() do
			shp(lp, "SimulationRadius", inf)
		end
	end)
elseif ssr and (simradius == "ssr") then
	spawn(function()
		while c and heartbeat:Wait() do
			ssr(inf)
		end
	end)
end

antiragdoll = antiragdoll and function(v)
	if v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
		v.Parent = nil
	end
end

if antiragdoll then
	for i, v in pairs(c:GetDescendants()) do
		antiragdoll(v)
	end
	c.DescendantAdded:Connect(antiragdoll)
end

if antirespawn then
	respawnrequest()
end

if method == 0 then
	wait(loadtime)
	if not c then
		return
	end
end

if discharscripts then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("LocalScript") then
			v.Disabled = true
		end
	end
elseif newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate and (not animate.Disabled) then
		animate.Disabled = true
	else
		newanimate = false
	end
end

if addtools then
	for i, v in pairs(addtools:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = c
		end
	end
end

pcall(function()
	settings().Physics.AllowSleep = false
	settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
end)

local OLDscripts = {}

for i, v in pairs(c:GetDescendants()) do
	if v.ClassName == "Script" then
		table.insert(OLDscripts, v)
	end
end

local scriptNames = {}

for i, v in pairs(c:GetDescendants()) do
	if v:IsA("BasePart") then
		local newName = tostring(i)
		local exists = true
		while exists do
			exists = false
			for i, v in pairs(OLDscripts) do
				if v.Name == newName then
					exists = true
				end
			end
			if exists then
				newName = newName .. "_"    
			end
		end
		table.insert(scriptNames, newName)
		Instance.new("Script", v).Name = newName
	end
end

c.Archivable = true
local hum = c:FindFirstChildOfClass("Humanoid")
if hum then
	for i, v in pairs(hum:GetPlayingAnimationTracks()) do
		v:Stop()
	end
end
local cl = c:Clone()
if hum and humState16 then
    hum:ChangeState(Enum.HumanoidStateType.Physics)
    if destroyhum then
        wait(1.6)
    end
end
if hum and hum.Parent and destroyhum then
    hum:Destroy()
end

if not c then
    return
end

local head = gp(c, "Head", "BasePart")
local torso = gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")
if hatcollide and c:FindFirstChildOfClass("Accessory") then
    local anything = c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script")
    if not (torso and root and anything) then
        return
    end
    torso:Destroy()
    root:Destroy()
    if shp then
        for i,v in pairs(c:GetChildren()) do
            if v:IsA("Accessory") then
                shp(v, "BackendAccoutrementState", 0)
            end 
        end
    end
    anything:Destroy()
    if head then
       head:Destroy()
    end
end

for i, v in pairs(cl:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
		v.Anchored = false
	end
end

local model = Instance.new("Model", c)
model.Name = model.ClassName

model.Destroying:Connect(function()
	model = nil
end)

for i, v in pairs(c:GetChildren()) do
	if v ~= model then
		if addtools and v:IsA("Tool") then
			for i1, v1 in pairs(v:GetDescendants()) do
				if v1 and v1.Parent and v1:IsA("BasePart") then
					local bv = Instance.new("BodyVelocity", v1)
					bv.Velocity = v3_0
					bv.MaxForce = v3(1000, 1000, 1000)
					bv.P = 1250
					bv.Name = "bv_" .. v.Name
				end
			end
		end
		v.Parent = model
	end
end

if breakjoints then
	model:BreakJoints()
else
	if head and torso then
		for i, v in pairs(model:GetDescendants()) do
			if v:IsA("Weld") or v:IsA("Snap") or v:IsA("Glue") or v:IsA("Motor") or v:IsA("Motor6D") then
				local save = false
				if (v.Part0 == torso) and (v.Part1 == head) then
					save = true
				end
				if (v.Part0 == head) and (v.Part1 == torso) then
					save = true
				end
				if save then
					if hedafterneck then
						hedafterneck = v
					end
				else
					v:Destroy()
				end
			end
		end
	end
	if method == 3 then
		spawn(function()
			wait(loadtime)
			if model then
				model:BreakJoints()
			end
		end)
	end
end

cl.Parent = c
for i, v in pairs(cl:GetChildren()) do
	v.Parent = c
end
cl:Destroy()

local modelDes = {}
for i, v in pairs(model:GetDescendants()) do
	if v:IsA("BasePart") then
		i = tostring(i)
		v.Destroying:Connect(function()
			modelDes[i] = nil
		end)
		modelDes[i] = v
	end
end
local modelcolcon = nil
local function modelcolf()
	if model then
		for i, v in pairs(modelDes) do
			v.CanCollide = false
		end
	else
		modelcolcon:Disconnect()
	end
end
modelcolcon = stepped:Connect(modelcolf)
modelcolf()

for i, scr in pairs(model:GetDescendants()) do
	if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
		local Part0 = scr.Parent
		if Part0:IsA("BasePart") then
			for i1, scr1 in pairs(c:GetDescendants()) do
				if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
					local Part1 = scr1.Parent
					if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
						align(Part0, Part1)
						break
					end
				end
			end
		end
	end
end

if (typeof(hedafterneck) == "Instance") and head then
	local aligns = {}
	local con = nil
	con = hedafterneck.Changed:Connect(function(prop)
	    if (prop == "Parent") and not hedafterneck.Parent then
	        con:Disconnect()
    		for i, v in pairs(aligns) do
    			v.Enabled = true
    		end
		end
	end)
	for i, v in pairs(head:GetDescendants()) do
		if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
			i = tostring(i)
			aligns[i] = v
			v.Destroying:Connect(function()
			    aligns[i] = nil
			end)
			v.Enabled = false
		end
	end
end

for i, v in pairs(c:GetDescendants()) do
	if v and v.Parent then
		if v.ClassName == "Script" then
			if table.find(scriptNames, v.Name) then
				v:Destroy()
			end
		elseif not v:IsDescendantOf(model) then
			if v:IsA("Decal") then
				v.Transparency = 1
			elseif v:IsA("ForceField") then
				v.Visible = false
			elseif v:IsA("Sound") then
				v.Playing = false
			elseif v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") then
				v.Enabled = false
			end
		end
	end
end

if newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate then
		animate.Disabled = false
	end
end

if addtools then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = addtools
		end
	end
end

local hum0 = model:FindFirstChildOfClass("Humanoid")
if hum0 then
    hum0.Destroying:Connect(function()
        hum0 = nil
    end)
end

local hum1 = c:FindFirstChildOfClass("Humanoid")
if hum1 then
    hum1.Destroying:Connect(function()
        hum1 = nil
    end)
end

if hum1 then
	ws.CurrentCamera.CameraSubject = hum1
	local camSubCon = nil
	local function camSubFunc()
		camSubCon:Disconnect()
		if c and hum1 then
			ws.CurrentCamera.CameraSubject = hum1
		end
	end
	camSubCon = renderstepped:Connect(camSubFunc)
	if hum0 then
		hum0.Changed:Connect(function(prop)
			if hum1 and (prop == "Jump") then
				hum1.Jump = hum0.Jump
			end
		end)
	else
		respawnrequest()
	end
end

local rb = Instance.new("BindableEvent", c)
rb.Event:Connect(function()
	rb:Destroy()
	sg:SetCore("ResetButtonCallback", true)
	if destroyhum then
		c:BreakJoints()
		return
	end
	if hum0 and (hum0.Health > 0) then
		model:BreakJoints()
		hum0.Health = 0
	end
	if antirespawn then
	    respawnrequest()
	end
end)
sg:SetCore("ResetButtonCallback", rb)

spawn(function()
	while c do
		if hum0 and hum1 then
			hum1.Jump = hum0.Jump
		end
		wait()
	end
	sg:SetCore("ResetButtonCallback", true)
end)

R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
if R15toR6 then
    local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
	if part then
	    local cfr = part.CFrame
		local R6parts = { 
			head = {
				Name = "Head",
				Size = v3(2, 1, 1),
				R15 = {
					Head = 0
				}
			},
			torso = {
				Name = "Torso",
				Size = v3(2, 2, 1),
				R15 = {
					UpperTorso = 0.2,
					LowerTorso = -100
				}
			},
			root = {
				Name = "HumanoidRootPart",
				Size = v3(2, 2, 1),
				R15 = {
					HumanoidRootPart = 0
				}
			},
			leftArm = {
				Name = "Left Arm",
				Size = v3(1, 2, 1),
				R15 = {
					LeftHand = -0.73,
					LeftLowerArm = -0.2,
					LeftUpperArm = 0.4
				}
			},
			rightArm = {
				Name = "Right Arm",
				Size = v3(1, 2, 1),
				R15 = {
					RightHand = -0.73,
					RightLowerArm = -0.2,
					RightUpperArm = 0.4
				}
			},
			leftLeg = {
				Name = "Left Leg",
				Size = v3(1, 2, 1),
				R15 = {
					LeftFoot = -0.73,
					LeftLowerLeg = -0.15,
					LeftUpperLeg = 0.6
				}
			},
			rightLeg = {
				Name = "Right Leg",
				Size = v3(1, 2, 1),
				R15 = {
					RightFoot = -0.73,
					RightLowerLeg = -0.15,
					RightUpperLeg = 0.6
				}
			}
		}
		for i, v in pairs(c:GetChildren()) do
			if v:IsA("BasePart") then
				for i1, v1 in pairs(v:GetChildren()) do
					if v1:IsA("Motor6D") then
						v1.Part0 = nil
					end
				end
			end
		end
		part.Archivable = true
		for i, v in pairs(R6parts) do
			local part = part:Clone()
			part:ClearAllChildren()
			part.Name = v.Name
			part.Size = v.Size
			part.CFrame = cfr
			part.Anchored = false
			part.Transparency = 1
			part.CanCollide = false
			for i1, v1 in pairs(v.R15) do
				local R15part = gp(c, i1, "BasePart")
				local att = gp(R15part, "att1_" .. i1, "Attachment")
				if R15part then
					local weld = Instance.new("Weld", R15part)
					weld.Name = "Weld_" .. i1
					weld.Part0 = part
					weld.Part1 = R15part
					weld.C0 = cf(0, v1, 0)
					weld.C1 = cf(0, 0, 0)
					R15part.Massless = true
					R15part.Name = "R15_" .. i1
					R15part.Parent = part
					if att then
						att.Parent = part
						att.Position = v3(0, v1, 0)
					end
				end
			end
			part.Parent = c
			R6parts[i] = part
		end
		local R6joints = {
			neck = {
				Parent = R6parts.torso,
				Name = "Neck",
				Part0 = R6parts.torso,
				Part1 = R6parts.head,
				C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rootJoint = {
				Parent = R6parts.root,
				Name = "RootJoint" ,
				Part0 = R6parts.root,
				Part1 = R6parts.torso,
				C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rightShoulder = {
				Parent = R6parts.torso,
				Name = "Right Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightArm,
				C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftShoulder = {
				Parent = R6parts.torso,
				Name = "Left Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.leftArm,
				C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			},
			rightHip = {
				Parent = R6parts.torso,
				Name = "Right Hip",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightLeg,
				C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftHip = {
				Parent = R6parts.torso,
				Name = "Left Hip" ,
				Part0 = R6parts.torso,
				Part1 = R6parts.leftLeg,
				C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			}
		}
		for i, v in pairs(R6joints) do
			local joint = Instance.new("Motor6D")
			for prop, val in pairs(v) do
				joint[prop] = val
			end
			R6joints[i] = joint
		end
		hum1.RigType = Enum.HumanoidRigType.R6
		hum1.HipHeight = 0
	end
end



--find rig joints

local function fakemotor()
    return {C0=cf(), C1=cf()}
end

local torso = gp(c, "Torso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")

local neck = gp(torso, "Neck", "Motor6D")
neck = neck or fakemotor()

local rootJoint = gp(root, "RootJoint", "Motor6D")
rootJoint = rootJoint or fakemotor()

local leftShoulder = gp(torso, "Left Shoulder", "Motor6D")
leftShoulder = leftShoulder or fakemotor()

local rightShoulder = gp(torso, "Right Shoulder", "Motor6D")
rightShoulder = rightShoulder or fakemotor()

local leftHip = gp(torso, "Left Hip", "Motor6D")
leftHip = leftHip or fakemotor()

local rightHip = gp(torso, "Right Hip", "Motor6D")
rightHip = rightHip or fakemotor()

--120 fps

local fps = 0
local event = Instance.new("BindableEvent", c)
event.Name = "120 fps"
local floor = math.floor
fps = 1 / fps
local tf = 0
local con = nil
con = game:GetService("RunService").RenderStepped:Connect(function(s)
	if not c then
		con:Disconnect()
		return
	end
    --tf += s
	if tf >= fps then
		for i=1, floor(tf / fps) do
			event:Fire(c)
		end
		tf = 0
	end
end)
local event = event.Event

local hedrot = v3(0, 5, 0)

local uis = game:GetService("UserInputService")
local function isPressed(key)
    return (not uis:GetFocusedTextBox()) and uis:IsKeyDown(Enum.KeyCode[key])
end

local biggesthandle = nil
for i, v in pairs(c:GetChildren()) do
    if v:IsA("Accessory") then
        local handle = gp(v, "Handle", "BasePart")
        if biggesthandle then
            if biggesthandle.Size.Magnitude < handle.Size.Magnitude then
                biggesthandle = handle
            end
       else
            biggesthandle = gp(v, "Handle", "BasePart")
        end
    end
end

if not biggesthandle then
    return
end

local handle1 = gp(gp(model, biggesthandle.Parent.Name, "Accessory"), "Handle", "BasePart")
if not handle1 then
    return
end

handle1.Destroying:Connect(function()
    handle1 = nil
end)
biggesthandle.Destroying:Connect(function()
    biggesthandle = nil
end)

biggesthandle:BreakJoints()
biggesthandle.Anchored = true

for i, v in pairs(handle1:GetDescendants()) do
    if v:IsA("AlignOrientation") then
        v.Enabled = false
   end
end

local mouse = lp:GetMouse()
local fling = false
mouse.Button1Down:Connect(function()
    fling = true
end)
mouse.Button1Up:Connect(function()
    fling = false
end)
local function doForSignal(signal, vel)
    spawn(function()
        while signal:Wait() and c and handle1 and biggesthandle do
            if fling and mouse.Target then
                biggesthandle.Position = mouse.Hit.Position
            end
            handle1.RotVelocity = vel
        end
    end)
end
doForSignal(stepped, v3(100, 100, 100))
doForSignal(renderstepped, v3(100, 100, 100))
doForSignal(heartbeat, v3(20000, 20000, 20000)) --https://web.roblox.com/catalog/63690008/Pal-Hair

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = Vector3.zero
local inf = math.huge

local cplayer = lp.Character

local v3 = Vector3.new

local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
        for i, v in pairs(parent:GetChildren()) do
            if (v.Name == name) and v:IsA(className) then
                return v
            end
        end
    end
    return nil
end

local hat2 = gp(cplayer, "SeeMonkey", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Torso"]
att2.Position = Vector3.new(0, -0, 0)
att2.Rotation = Vector3.new(90, 0, 0)

local hat2 = gp(cplayer, "Pink Hair", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Left Arm"]
att2.Position = Vector3.new(0, -0, 0)
att2.Rotation = Vector3.new(90, 0, 0)

local hat2 = gp(cplayer, "Kate Hair", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Arm"]
att2.Position = Vector3.new(-0, -0, 0)
att2.Rotation = Vector3.new(90, 0, 0) --LavanderHair

local hat2 = gp(cplayer, "LavanderHair", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Leg"]
att2.Position = Vector3.new(0, 0, 0) --Robloxclassicred
att2.Rotation = Vector3.new(90, 0, 0)

local hat2 = gp(cplayer, "Robloxclassicred", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Left Leg"]
att2.Position = Vector3.new(-0, 0, 0) 
att2.Rotation = Vector3.new(90, 0, 0) 



--[[
	Originally written by TsarMac
	Modified by foodman54
	Rewritten (:soulless:) by GizmoTjaz
]]

-- Services
local runService = game:GetService("RunService")
local playerService = game:GetService("Players")

-- Variables
local headHorFactor = 1
local headVerFactor = .6
local bodyHorFactor = .5
local bodyVerFactor = .4
local updateSpeed = .5 / 2

local plr = playerService.LocalPlayer
local cam = workspace.CurrentCamera
local mouse = plr:GetMouse()

local char = plr.Character or plr.CharacterAdded:wait()
local hum = char:WaitForChild("Humanoid")
local isR6 = hum.RigType == Enum.HumanoidRigType.R6
local head = char.Head
local root = char.HumanoidRootPart
local torso = isR6 and char.Torso or char.UpperTorso
local neck = isR6 and torso.Neck or head.Neck
local waist = not isR6 and torso.Waist

local neckC0 = neck.C0
local waistC0 = not isR6 and waist.C0

neck.MaxVelocity = 1/3

runService.RenderStepped:Connect(function ()

	-- Check if every required body part exists and whether the CurrentCamera's CameraSubject is the Humanoid
	if torso and head and ((isR6 and neck) or (neck and waist)) and cam.CameraSubject == hum then

		local camCF = cam.CFrame
		local headCF = head.CFrame

		local torsoLV = torso.CFrame.lookVector

		local dist = (headCF.p - camCF.p).magnitude
		local diff = headCF.Y - camCF.Y

		local asinDiffDist = math.asin(diff / dist)
		local whateverThisDoes = ((headCF.p - camCF.p).Unit:Cross(torsoLV)).Y

		if isR6 then
			neck.C0 = neck.C0:lerp(neckC0 * CFrame.Angles(-1 * asinDiffDist * headVerFactor, 0, -1 * whateverThisDoes * headHorFactor), updateSpeed)
		else
			neck.C0 = neck.C0:lerp(neckC0 * CFrame.Angles(asinDiffDist * headVerFactor, -1 * whateverThisDoes * headHorFactor, 0), updateSpeed)
			waist.C0 = waist.C0:lerp(waistC0 * CFrame.Angles(asinDiffDist * bodyVerFactor, -1 * whateverThisDoes * bodyHorFactor, 0), updateSpeed)
		end

	end
end)

local scrip1t = game:GetObjects("rbxassetid://6438169891")[1]
scrip1t.Parent = game.Players.LocalPlayer.Character

local script = scrip1t.GUTS

local Mouse = game.Players.LocalPlayer:GetMouse()

wait()


-------------------||
--------------------\\
--||||||||||]]]]]]]]]\\
---------------------\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
--CREATED BY INFINITEONEWITHDANK NAME OF SCRIPT: GUTS, FROM BERSERK                                                                                                       							]]>                                                                                                                                                       |]]>>
---------------------//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
--||||||||||]]]]]]]]]//
--------------------//
-------------------||
--//THIS WAS NOT FULLY CREATED BY ME:
--\\SOME SOURCES MAY HAVE BEEN TAKEN FROM OTHER SCRIPTS

print("Created By InfiniteOneWithdank, Shackluster/PityPolygon Made The Original Base Of This Script")

wait(2)
Player = game:GetService("Players").LocalPlayer
PlayerGui = Player.PlayerGui
Cam = workspace.CurrentCamera
Backpack = Player.Backpack
Character = Player.Character
RealChar = workspace[Player.Name]
Humanoid = Character.Humanoid
RootPart = Character.HumanoidRootPart
Torso = Character.Torso
Head = Character.Head
Mouse = Player:GetMouse()
RightArm = Character["Right Arm"]
LeftArm = Character["Left Arm"]
RightLeg = Character["Right Leg"]
LeftLeg = Character["Left Leg"]
RootJoint = RootPart.RootJoint
Neck = Torso.Neck
RightShoulder = Torso["Right Shoulder"]
LeftShoulder = Torso["Left Shoulder"]
RightHip = Torso["Right Hip"]
LeftHip = Torso["Left Hip"]
local TWEENSERVICE = game:GetService("TweenService")
local debris = game:GetService("Debris")
local run = game:GetService("RunService")
local rs = run.RenderStepped
local cam = workspace.CurrentCamera
local HUM = Character.Humanoid
local ROOT = HUM.Torso
local MOUSEPOS = ROOT.Position
local DAMAGEMULTIPLIER = 0
local TERRIBLE = {}  

IT = Instance.new
CF = CFrame.new
VT = Vector3.new
RAD = math.rad
C3 = Color3.new
UD2 = UDim2.new
BRICKC = BrickColor.new
ANGLES = CFrame.Angles
EULER = CFrame.fromEulerAnglesXYZ
COS = math.cos
ACOS = math.acos
SIN = math.sin
ASIN = math.asin
ABS = math.abs
MRANDOM = math.random
FLOOR = math.floor

-----------------------------------
--||///////============\\\\\\\\||--
--><Values	
Animation_Speed = 3
Animation_Speed2 = 5
Frame_Speed = 1 / 60 -- (1 / 30) OR (1 / 60)
local ROOTC0 = CF(0, 0, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local NECKC0 = CF(0, 1, 0) * ANGLES(RAD(-90), RAD(0), RAD(180))
local RIGHTSHOULDERC0 = CF(-0.5, 0, 0) * ANGLES(RAD(0), RAD(90), RAD(0))
local LEFTSHOULDERC0 = CF(0.5, 0, 0) * ANGLES(RAD(0), RAD(-90), RAD(0))
local DAMAGEMULTIPLIER = 0
local ANIM = "Idle"
local ATTACK = false
local EQUIPPED = false
local HOLD = false
local COMBO = 0
local Rooted = false
local SINE = 0
local KEYHOLD = false
local CHANGE = 2 / Animation_Speed
local WALKINGANIM = false
local VALUE1 = false
local VALUE2 = false
local ROBLOXIDLEANIMATION = IT("Animation")
ROBLOXIDLEANIMATION.Name = "Roblox Idle Animation"
ROBLOXIDLEANIMATION.AnimationId = "http://www.roblox.com/asset/?id=180435571"
ROBLOXIDLEANIMATION.Parent = Humanoid
local WEAPONGUI = IT("ScreenGui", PlayerGui)
WEAPONGUI.Name = "DSCRIPT"
local Effects = IT("Folder", Character)
Effects.Name = "Effects"
local ANIMATOR = Humanoid.Animator
local ANIMATE = Character.Animate
local UNANCHOR = true
local SHOTS = 0

local STUFF = Instance.new("Folder",Character)

local Musika = IT("Sound", RootPart)
local Volu = 5
local Pitch = 1
local Song = 2809513162
local TSPT, TVY, TSTP

local Musika2 = IT("Sound", RootPart)
local Volu2 = 3
local Pitch2 = 1
local Song2 = 0
local TSPT2, TVY2, TSTP2

local Player_Size = 1
local WALKINGANIM = false
local SCALE = 2

local Decal = IT("Decal")

local HITPLAYERSOUNDS = {"263032172", "263032182", "263032200", "263032221", "263032252", "263033191"}
local HITARMORSOUNDS = {"199149321", "199149338", "199149367", "199149409", "199149452"}
local HITWEAPONSOUNDS = {"199148971", "199149025", "199149072", "199149109", "199149119"}
local HITBLOCKSOUNDS = {"199148933", "199148947"}

local GHOST = false
local GUTS = true

-----------------------------------


-----------------------------------
--------------------------------->
-----------------------------------

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"
script:WaitForChild("ArtificialHB")
frame = Frame_Speed
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
			lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)

-----------------------------------

--><Some Functions
function Raycast(POSITION, DIRECTION, RANGE, IGNOREDECENDANTS)
	return workspace:FindPartOnRay(Ray.new(POSITION, DIRECTION.unit * RANGE), IGNOREDECENDANTS)
end
function PositiveAngle(NUMBER)
	if NUMBER >= 0 then
		NUMBER = 0
	end
	return NUMBER
end
function NegativeAngle(NUMBER)
	if NUMBER <= 0 then
		NUMBER = 0
	end
	return NUMBER
end
function Swait(NUMBER)
	if NUMBER == 0 or NUMBER == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, NUMBER do
			ArtificialHB.Event:wait()
		end
	end
end
function CreateMesh(MESH, PARENT, MESHTYPE, MESHID, TEXTUREID, SCALE, OFFSET)
	local NEWMESH = IT(MESH)
	if MESH == "SpecialMesh" then
		NEWMESH.MeshType = MESHTYPE
		if MESHID ~= "nil" and MESHID ~= "" then
			NEWMESH.MeshId = "http://www.roblox.com/asset/?id=" .. MESHID
		end
		if TEXTUREID ~= "nil" and TEXTUREID ~= "" then
			NEWMESH.TextureId = "http://www.roblox.com/asset/?id=" .. TEXTUREID
		end
	end
	NEWMESH.Offset = OFFSET or VT(0, 0, 0)
	NEWMESH.Scale = SCALE
	NEWMESH.Parent = PARENT
	return NEWMESH
end
function CreatePart(FORMFACTOR, PARENT, MATERIAL, REFLECTANCE, TRANSPARENCY, BRICKCOLOR, NAME, SIZE, ANCHOR)
	local NEWPART = IT("Part")
	NEWPART.formFactor = FORMFACTOR
	NEWPART.Reflectance = REFLECTANCE
	NEWPART.Transparency = TRANSPARENCY
	NEWPART.CanCollide = false
	NEWPART.Locked = true
	NEWPART.Anchored = true
	if ANCHOR == false then
		NEWPART.Anchored = false
	end
	NEWPART.BrickColor = BRICKC(tostring(BRICKCOLOR))
	NEWPART.Name = NAME
	NEWPART.Size = SIZE
	NEWPART.Position = Torso.Position
	NEWPART.Material = MATERIAL
	NEWPART:BreakJoints()
	NEWPART.Parent = PARENT
	return NEWPART
end
local weldBetween = function(a, b)
	local weldd = Instance.new("ManualWeld")
	weldd.Part0 = a
	weldd.Part1 = b
	weldd.C0 = CFrame.new()
	weldd.C1 = b.CFrame:inverse() * a.CFrame
	weldd.Parent = a
	return weldd
end
function weldSomethings(a, b, acf)
    local we = Instance.new("Weld", a)
    we.Part0 = a
    we.Part1 = b
if acf ~= nil then
    we.C0 = acf
end
end
function QuaternionFromCFrame(cf)
	local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
	local trace = m00 + m11 + m22
	if trace > 0 then
		local s = math.sqrt(1 + trace)
		local recip = 0.5 / s
		return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
	else
		local i = 0
		if m00 < m11 then
			i = 1
		end
		if m22 > (i == 0 and m00 or m11) then
			i = 2
		end
		if i == 0 then
			local s = math.sqrt(m00 - m11 - m22 + 1)
			local recip = 0.5 / s
			return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
		elseif i == 1 then
			local s = math.sqrt(m11 - m22 - m00 + 1)
			local recip = 0.5 / s
			return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
		elseif i == 2 then
			local s = math.sqrt(m22 - m00 - m11 + 1)
			local recip = 0.5 / s
			return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
		end
	end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
	local xs, ys, zs = x + x, y + y, z + z
	local wx, wy, wz = w * xs, w * ys, w * zs
	local xx = x * xs
	local xy = x * ys
	local xz = x * zs
	local yy = y * ys
	local yz = y * zs
	local zz = z * zs
	return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
	local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
	local startInterp, finishInterp
	if cosTheta >= 1.0E-4 then
		if 1 - cosTheta > 1.0E-4 then
			local theta = ACOS(cosTheta)
			local invSinTheta = 1 / SIN(theta)
			startInterp = SIN((1 - t) * theta) * invSinTheta
			finishInterp = SIN(t * theta) * invSinTheta
		else
			startInterp = 1 - t
			finishInterp = t
		end
	elseif 1 + cosTheta > 1.0E-4 then
		local theta = ACOS(-cosTheta)
		local invSinTheta = 1 / SIN(theta)
		startInterp = SIN((t - 1) * theta) * invSinTheta
		finishInterp = SIN(t * theta) * invSinTheta
	else
		startInterp = t - 1
		finishInterp = t
	end
	return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function Clerp(a, b, t)
	local qa = {
		QuaternionFromCFrame(a)
	}
	local qb = {
		QuaternionFromCFrame(b)
	}
	local ax, ay, az = a.x, a.y, a.z
	local bx, by, bz = b.x, b.y, b.z
	local _t = 1 - t
	return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function CreateFrame(PARENT, TRANSPARENCY, BORDERSIZEPIXEL, POSITION, SIZE, COLOR, BORDERCOLOR, NAME)
	local frame = IT("Frame")
	frame.BackgroundTransparency = TRANSPARENCY
	frame.BorderSizePixel = BORDERSIZEPIXEL
	frame.Position = POSITION
	frame.Size = SIZE
	frame.BackgroundColor3 = COLOR
	frame.BorderColor3 = BORDERCOLOR
	frame.Name = NAME
	frame.Parent = PARENT
	return frame
end
function CreateLabel(PARENT, TEXT, TEXTCOLOR, TEXTFONTSIZE, TEXTFONT, TRANSPARENCY, BORDERSIZEPIXEL, STROKETRANSPARENCY, NAME)
	local label = IT("TextLabel")
	label.BackgroundTransparency = 1
	label.Size = UD2(1, 0, 1, 0)
	label.Position = UD2(0, 0, 0, 0)
	label.TextColor3 = TEXTCOLOR
	label.TextStrokeTransparency = STROKETRANSPARENCY
	label.TextTransparency = TRANSPARENCY
	label.FontSize = TEXTFONTSIZE
	label.Font = TEXTFONT
	label.BorderSizePixel = BORDERSIZEPIXEL
	label.TextScaled = false
	label.Text = TEXT
	label.Name = NAME
	label.Parent = PARENT
	return label
end
function NoOutlines(PART)
	PART.TopSurface, PART.BottomSurface, PART.LeftSurface, PART.RightSurface, PART.FrontSurface, PART.BackSurface = 10, 10, 10, 10, 10, 10
end
function CreateWeldOrSnapOrMotor(TYPE, PARENT, PART0, PART1, C0, C1)
	local NEWWELD = IT(TYPE)
	NEWWELD.Part0 = PART0
	NEWWELD.Part1 = PART1
	NEWWELD.C0 = C0
	NEWWELD.C1 = C1
	NEWWELD.Parent = PARENT
	return NEWWELD
end
local S = IT("Sound")
function CreateSound(ID, PARENT, VOLUME, PITCH, DOESLOOP)
	local NEWSOUND
	coroutine.resume(coroutine.create(function()
		NEWSOUND = S:Clone()
		NEWSOUND.Parent = PARENT
		NEWSOUND.Volume = VOLUME
		NEWSOUND.Pitch = PITCH
		NEWSOUND.EmitterSize = VOLUME * 3
		NEWSOUND.SoundId = "http://www.roblox.com/asset/?id=" .. ID
		NEWSOUND:play()
		if DOESLOOP == true then
			NEWSOUND.Looped = true
		else
			repeat
				wait(1)
			until NEWSOUND.Playing == false
			NEWSOUND:remove()
		end
	end))
	return NEWSOUND
end
function NewSound(TABLE)
	local ID = "rbxassetid://"..(TABLE.ID or 0)
	local PARENT = (TABLE.PARENT or ROOT)
	local VOLUME = (TABLE.VOLUME or 0.5)
	local PITCH = (TABLE.PITCH or 1)
	local LOOP = (TABLE.LOOP or false)
	local MAXDISTANCE = (TABLE.MAXDISTANCE or 100)
	local EMITTERSIZE = (TABLE.EMITTERSIZE or 10)
	local PLAYING = (TABLE.PLAYING or true)
	local PLAYONREMOVE = (TABLE.PLAYONREMOVE or false)
	local DOESDEBRIS = (TABLE.DOESDEBRIS or true)
	if ID ~= "rbxassetid://0" then
		local SOUND = IT("Sound",PARENT)
		SOUND.SoundId = ID
		SOUND.Volume = VOLUME
		SOUND.Pitch = PITCH
		SOUND.Looped = LOOP
		SOUND.MaxDistance = MAXDISTANCE
		SOUND.EmitterSize = EMITTERSIZE
		SOUND.PlayOnRemove = PLAYONREMOVE
		if DOESDEBRIS == true and PLAYING == true and LOOP == false then
			Debris:AddItem(SOUND,SOUND.TimeLength+5)
		end
		if PLAYING == true then
			SOUND:Play()
		end
		return SOUND
	end
end 
function CFrameFromTopBack(at, top, back)
	local right = top:Cross(back)
	return CF(at.x, at.y, at.z, right.x, top.x, back.x, right.y, top.y, back.y, right.z, top.z, back.z)
end
function MagicRing()
	local O1 = CreatePart(3, Effects, "Neon", 0, 1, "Really black", "Warphole", VT(0, 0, 0))
	O1.CFrame = RootPart.CFrame * CF(0, 0, -3) * ANGLES(RAD(90), RAD(0), RAD(0))
	local decal = Decal:Clone()
	decal.Parent = O1
	decal.Face = "Top"
	decal.Texture = "http://www.roblox.com/asset/?id=0"
	local decal2 = Decal:Clone()
	decal2.Parent = O1
	decal2.Face = "Bottom"
	decal2.Texture = "http://www.roblox.com/asset/?id=0"
	return O1
end
function MagicRing2(PART,CFRAME)
	local RING = CreatePart(3, Effects, "Neon", 0, 1, "Royal purple", "MagicRing", VT(0,0,0),false)
	local WELD = CreateWeldOrSnapOrMotor("Weld", PART, PART, RING, CFRAME, CF(0, 0, 0))
	local MESH = IT("BlockMesh",RING)
	local BOTTOMTEXTURE = Decal:Clone()
	BOTTOMTEXTURE.Parent = RING
	BOTTOMTEXTURE.Face = "Bottom"
	BOTTOMTEXTURE.Name = "BottomTexture"
	local TOPTEXTURE = Decal:Clone()
	TOPTEXTURE.Parent = RING
	TOPTEXTURE.Face = "Top"
	TOPTEXTURE.Name = "TopTexture"
	local LIGHT = IT("PointLight",RING)
	BOTTOMTEXTURE.Texture = "http://www.roblox.com/asset/?id=2829906887"
	TOPTEXTURE.Texture = "http://www.roblox.com/asset/?id=2829906887"
	return RING,WELD,MESH
end
local DECAL = IT("Decal")
function MagicRing3()
	local RING = CreatePart(3, Effects, "Neon", 0, 1, BRICKC("Pearl"), "MagicRing", VT(0, 0, 0), true)
	local MSH = IT("BlockMesh", RING)
	local TOP = DECAL:Clone()
	local BOTTOM = DECAL:Clone()
	TOP.Parent = RING
	BOTTOM.Parent = RING
	TOP.Face = "Top"
	BOTTOM.Face = "Bottom"
	TOP.Texture = "http://www.roblox.com/asset/?id=0"
	BOTTOM.Texture = "http://www.roblox.com/asset/?id=0"
	local function REMOVE()
		coroutine.resume(coroutine.create(function()
			local SIZE = MSH.Scale.X
			for i = 1, 35 do
				Swait()
				MSH.Scale = MSH.Scale - VT(SIZE, 0, SIZE) / 60
				TOP.Transparency = TOP.Transparency + 0.02857142857142857
				BOTTOM.Transparency = BOTTOM.Transparency + 0.02857142857142857
				RING.CFrame = RING.CFrame * ANGLES(RAD(0), RAD(-5), RAD(0))
			end
			RING:remove()
		end))
	end
	return RING, MSH, REMOVE
end
function CreateWave(SIZE, WAIT, CFRAME, DOESROT, ROT, COLOR, GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0.5, BRICKC(COLOR), "Effect", VT(0, 0, 0))
	local mesh = CreateMesh("SpecialMesh", wave, "FileMesh", "20329976", "", SIZE, VT(0, 0, -SIZE.X / 8))
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			mesh.Offset = VT(0, 0, -(mesh.Scale.X / 8))
			if DOESROT == true then
				wave.CFrame = wave.CFrame * CFrame.fromEulerAnglesXYZ(0, ROT, 0)
			end
			wave.Transparency = wave.Transparency + 0.5 / WAIT
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end
function SpecialSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
    local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Eye", VT(1,1,1), true)
    wave.Color = COLOR
    local mesh = CreateMesh("SpecialMesh", wave, "Sphere", "", "", SIZE, VT(0,0,0))
    wave.CFrame = CFRAME
    coroutine.resume(coroutine.create(function(PART)
        for i = 1, WAIT do
            Swait()
            mesh.Scale = mesh.Scale + GROW
            wave.Transparency = wave.Transparency + (1/WAIT)
            if wave.Transparency > 0.99 then
                wave:remove()
            end
        end
    end))
end
function MagicSphere(SIZE,WAIT,CFRAME,COLOR,GROW)
	local wave = CreatePart(3, Effects, "Neon", 0, 0, BRICKC(COLOR), "Effect", VT(1,1,1), true)
	local mesh = IT("SpecialMesh",wave)
	mesh.MeshType = "Sphere"
	mesh.Scale = SIZE
	mesh.Offset = VT(0,0,0)
	wave.CFrame = CFRAME
	coroutine.resume(coroutine.create(function(PART)
		for i = 1, WAIT do
			Swait()
			mesh.Scale = mesh.Scale + GROW
			wave.Transparency = wave.Transparency + (1/WAIT)
			if wave.Transparency > 0.99 then
				wave:remove()
			end
		end
	end))
end
function WACKYEFFECT(Table)
	local TYPE = (Table.EffectType or "Sphere")
	local SIZE = (Table.Size or VT(1,1,1))
	local ENDSIZE = (Table.Size2 or VT(0,0,0))
	local TRANSPARENCY = (Table.Transparency or 0)
	local ENDTRANSPARENCY = (Table.Transparency2 or 1)
	local CFRAME = (Table.CFrame or Torso.CFrame)
	local MOVEDIRECTION = (Table.MoveToPos or nil)
	local ROTATION1 = (Table.RotationX or 0)
	local ROTATION2 = (Table.RotationY or 0)
	local ROTATION3 = (Table.RotationZ or 0)
	local MATERIAL = (Table.Material or "Neon")
	local COLORLOOP = (Table.ColorLoop or false)
	local COLOR = (Table.Color or C3(1,1,1))
	local TIME = (Table.Time or 45)
	local SOUNDID = (Table.SoundID or nil)
	local SOUNDPITCH = (Table.SoundPitch or nil)
	local SOUNDVOLUME = (Table.SoundVolume or nil)
	local USEBOOMERANGMATH = (Table.UseBoomerangMath or false)
	local BOOMERANG = (Table.Boomerang or 0)
	local SIZEBOOMERANG = (Table.SizeBoomerang or 0)
	coroutine.resume(coroutine.create(function()
		local PLAYSSOUND = false
		local SOUND = nil
		local EFFECT = CreatePart(3, Effects, MATERIAL, 0, TRANSPARENCY, BRICKC("Pearl"), "Effect", VT(1,1,1), true)
		if SOUNDID ~= nil and SOUNDPITCH ~= nil and SOUNDVOLUME ~= nil then
			PLAYSSOUND = true
			SOUND = CreateSound(SOUNDID, EFFECT, SOUNDVOLUME, SOUNDPITCH, false)
		end
		EFFECT.Color = COLOR
		local MSH = nil
		if TYPE == "Sphere" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "Sphere", "", "", SIZE, VT(0,0,0))
		elseif TYPE == "Block" or TYPE == "Box" then
			MSH = IT("BlockMesh",EFFECT)
			MSH.Scale = SIZE
		elseif TYPE == "Wave" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "20329976", "", SIZE, VT(0,0,-SIZE.X/8))
		elseif TYPE == "Ring" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "559831844", "", VT(SIZE.X,SIZE.X,0.1), VT(0,0,0))
		elseif TYPE == "Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662586858", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Round Slash" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "662585058", "", VT(SIZE.X/10,0,SIZE.X/10), VT(0,0,0))
		elseif TYPE == "Swirl" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "168892432", "", SIZE, VT(0,0,0))
		elseif TYPE == "Skull" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "4770583", "", SIZE, VT(0,0,0))
		elseif TYPE == "Crystal" then
			MSH = CreateMesh("SpecialMesh", EFFECT, "FileMesh", "9756362", "", SIZE, VT(0,0,0))
		end
		if MSH ~= nil then
			local BOOMR1 = 1+BOOMERANG/50
			local BOOMR2 = 1+SIZEBOOMERANG/50
			local MOVESPEED = nil
			if MOVEDIRECTION ~= nil then
				if USEBOOMERANGMATH == true then
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)*BOOMR1
				else
					MOVESPEED = ((CFRAME.p - MOVEDIRECTION).Magnitude/TIME)
				end
			end
			local GROWTH = nil
			if USEBOOMERANGMATH == true then
				GROWTH = (SIZE - ENDSIZE)*(BOOMR2+1)
			else
				GROWTH = (SIZE - ENDSIZE)
			end
			local TRANS = TRANSPARENCY - ENDTRANSPARENCY
			if TYPE == "Block" then
				EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
			else
				EFFECT.CFrame = CFRAME
			end
			if USEBOOMERANGMATH == true then
				for LOOP = 1, TIME+1 do
					Swait()
					if COLORLOOP == true then
					EFFECT.Color = COLOR
					end
					MSH.Scale = MSH.Scale - (VT((GROWTH.X)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Y)*((1 - (LOOP/TIME)*BOOMR2)),(GROWTH.Z)*((1 - (LOOP/TIME)*BOOMR2)))*BOOMR2)/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-(MOVESPEED)*((1 - (LOOP/TIME)*BOOMR1)))
						EFFECT.Orientation = ORI
					end
				end
			else
				for LOOP = 1, TIME+1 do
					Swait()
					if COLORLOOP == true then
						EFFECT.Color = COLOR
					end
					MSH.Scale = MSH.Scale - GROWTH/TIME
					if TYPE == "Wave" then
						MSH.Offset = VT(0,0,-MSH.Scale.Z/8)
					end
					EFFECT.Transparency = EFFECT.Transparency - TRANS/TIME
					if TYPE == "Block" then
						EFFECT.CFrame = CFRAME*ANGLES(RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)),RAD(MRANDOM(0,360)))
					else
						EFFECT.CFrame = EFFECT.CFrame*ANGLES(RAD(ROTATION1),RAD(ROTATION2),RAD(ROTATION3))
					end
					if MOVEDIRECTION ~= nil then
						local ORI = EFFECT.Orientation
						EFFECT.CFrame = CF(EFFECT.Position,MOVEDIRECTION)*CF(0,0,-MOVESPEED)
						EFFECT.Orientation = ORI
					end
				end
			end
			EFFECT.Transparency = 1
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		else
			if PLAYSSOUND == false then
				EFFECT:remove()
			else
				repeat Swait() until EFFECT:FindFirstChildOfClass("Sound") == nil
				EFFECT:remove()
			end
		end
	end))
end 
function CharacterFade(COLOR,TIMER)
	coroutine.resume(coroutine.create(function()
		local FADE = IT("Model",Effects)
		FADE.Name = "FadingEffect"
		for _, c in pairs(Character:GetChildren()) do
			if c.ClassName == "Part" and c ~= RootPart then
				local FADER = c:Clone()
				FADER.Color = COLOR
				FADER.CFrame = c.CFrame
				FADER.Parent = FADE
				FADER.Anchored = true
				FADER.Transparency = 0.25+c.Transparency
				FADER:BreakJoints()
				FADER.Material = "Neon"
				if FADER.Name == "Head" then
					FADER:ClearAllChildren()
					FADER.Size = VT(1,1,1)
				end
				if c and c.Parent and c.ClassName == "ShirtGraphic" then
					c:Destroy()
				end	
				FADER.CanCollide = false
			end
		end
		local TRANS = 0.75/TIMER
		for i = 1, TIMER do
			Swait()
			for _, c in pairs(FADE:GetChildren()) do
				if c.ClassName == "Part" then
					c.Transparency = c.Transparency + TRANS
				end
			end
		end
		FADE:remove()
	end))
end   
function Lightning(Table)
	local Color = Table.Color or C3(1, 1, 1)
	local StartPos = Table.Start or Torso.Position
	local EndPos = Table.End or Mouse.Hit.p
	local SegmentLength = Table.SegmentL or 2
	local Thickness = Table.Thickness or 0.1
	local Dissapear = Table.DoesFade or false
	local Parent = Table.Ignore or Character
	local MaxDist = Table.MaxDist or 400
	local Branches = Table.Branches or false
	local Thicken = Table.Thicken or false
	local FadeTime = Table.FadeTime or 15
	local FadeIn = Table.FadeIn or false
	local Material = Table.Material or "Neon"
	local HIT, HITPOS = CastProperRay(StartPos, EndPos, MaxDist, Parent)
	local DISTANCE = math.ceil((StartPos - HITPOS).Magnitude / (SegmentLength / SegmentLength / 1.5))
	local LIGHTNINGMODEL = IT("Model", Effects)
	LIGHTNINGMODEL.Name = "Lightning"
	local LastBolt
	for E = 1, DISTANCE do
		local ExtraSize = 0
		if Thicken == true then
			ExtraSize = (DISTANCE - E) / 15
		end
		local TRANSPARENCY = 0
		if FadeIn == true then
			TRANSPARENCY = 1 - E / (DISTANCE / 1.5)
			if TRANSPARENCY < 0 then
				TRANSPARENCY = 0
			end
		end
		local PART = CreatePart(3, LIGHTNINGMODEL, Material, 0, TRANSPARENCY, BRICKC("Pearl"), "LightningPart" .. E, VT(Thickness + ExtraSize, SegmentLength, Thickness + ExtraSize))
		PART.Color = Color
		MakeForm(PART, "Cyl")
		if LastBolt == nil then
			PART.CFrame = CF(StartPos, HITPOS) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -PART.Size.Y / 2, 0)
		else
			PART.CFrame = CF(LastBolt.CFrame * CF(0, -LastBolt.Size.Y / 2, 0).p, CF(HITPOS) * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))) * CF(0, 0, DISTANCE - E).p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -PART.Size.Y / 2, 0)
		end
		LastBolt = PART
		if Branches == true and E < DISTANCE - 5 then
			local CHOICE = MRANDOM(1, 7 + (DISTANCE - E) * 2)
			if CHOICE == 1 then
				local LASTBRANCH
				for i = 1, MRANDOM(2, 5) do
					local ExtraSize2 = 0
					if Thicken == true then
						ExtraSize = (DISTANCE - E) / 25 / i
					end
					local PART = CreatePart(3, LIGHTNINGMODEL, Material, 0, TRANSPARENCY, BRICKC("Pearl"), "Branch" .. E .. "-" .. i, VT(Thickness + ExtraSize2, SegmentLength, Thickness + ExtraSize2))
					PART.Color = Color
					MakeForm(PART, "Cyl")
					if LASTBRANCH == nil then
						PART.CFrame = CF(LastBolt.CFrame * CF(0, -LastBolt.Size.Y / 2, 0).p, LastBolt.CFrame * CF(0, -LastBolt.Size.Y / 2, 0) * ANGLES(RAD(0), RAD(0), RAD(MRANDOM(0, 360))) * CF(0, Thickness * 7, 0) * CF(0, 0, -1).p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -PART.Size.Y / 2, 0)
					else
						PART.CFrame = CF(LASTBRANCH.CFrame * CF(0, -LASTBRANCH.Size.Y / 2, 0).p, LASTBRANCH.CFrame * CF(0, -LASTBRANCH.Size.Y / 2, 0) * ANGLES(RAD(0), RAD(0), RAD(MRANDOM(0, 360))) * CF(0, Thickness * 3, 0) * CF(0, 0, -1).p) * ANGLES(RAD(90), RAD(0), RAD(0)) * CF(0, -PART.Size.Y / 2, 0)
					end
					LASTBRANCH = PART
				end
			end
		end
	end
	if Dissapear == true then
		coroutine.resume(coroutine.create(function()
			for i = 1, FadeTime do
				Swait()
				for _, c in pairs(LIGHTNINGMODEL:GetChildren()) do
					if c.ClassName == "Part" then
						c.Transparency = c.Transparency + 1 / FadeTime
					end
				end
			end
			LIGHTNINGMODEL:remove()
		end))
	elseif Dissapear == false then
		Debris:AddItem(LIGHTNINGMODEL, 0.1)
	end
	return {
		Hit = HIT,
		Pos = HITPOS,
		End = LastBolt.CFrame * CF(0, 0, -LastBolt.Size.Z).p,
		LastBolt = LastBolt,
		Model = LIGHTNINGMODEL
	}
end
function GetRoot(MODEL, ROOT)
	if ROOT == true then
		return MODEL:FindFirstChild("adf") or MODEL:FindFirstChild("adsf") or MODEL:FindFirstChild("adf")
	else
		return MODEL:FindFirstChild("Torso") or MODEL:FindFirstChild("adf")
	end
end
function MakeForm(PART, TYPE)
	if TYPE == "Cyl" then
		local MSH = IT("CylinderMesh", PART)
	elseif TYPE == "Ball" then
		local MSH = IT("SpecialMesh", PART)
		MSH.MeshType = "Sphere"
	elseif TYPE == "Wedge" then
		local MSH = IT("SpecialMesh", PART)
		MSH.MeshType = "Wedge"
	end
end
Debris = game:GetService("Debris")
local Particle = IT("ParticleEmitter",nil)
Particle.Enabled = false
Particle.LightEmission = 0.8
Particle.Rate = 150
Particle.ZOffset = 1
Particle.Rotation = NumberRange.new(-180, 180)

--ParticleEmitter({Speed = 5, RotSpeed = NumberRange.new(-15, 15), Drag = 0, Size1 = 1, Size2 = 5, Lifetime1 = 1, Lifetime2 = 1.5, Parent = Torso, Emit = 100, Offset = 360, Enabled = false, Color1 = C3(1,1,1), Color2 = C3(1,1,1), Texture = ""})
function ParticleEmitter(Table)
	local PRTCL = Particle:Clone()
	local Color1 = Table.Color1 or C3(1,1,1)
	local Color2 = Table.Color2 or C3(1,1,1)
	local Speed = Table.Speed or 5
	local Drag = Table.Drag or 0
	local Size1 = Table.Size1 or 1
	local Size2 = Table.Size2 or 5
	local Lifetime1 = Table.Lifetime1 or 1
	local Lifetime2 = Table.Lifetime2 or 1.5
	local Parent = Table.Parent or Torso
	local Emit = Table.Emit or 100
	local Offset = Table.Offset or 360
	local Acel = Table.Acel or VT(0,0,0)
	local Enabled = Table.Enabled or false
	local Texture = Table.Texture or "281983280"
	local RotS = Table.RotSpeed or NumberRange.new(-15, 15)
	local Trans1 = Table.Transparency1 or 0
	local Trans2 = Table.Transparency2 or 0
	PRTCL.Parent = Parent
	PRTCL.RotSpeed = RotS
	PRTCL.Transparency = NumberSequence.new({NumberSequenceKeypoint.new(0,Trans1),NumberSequenceKeypoint.new(1,Trans2)})
	PRTCL.Texture = "http://www.roblox.com/asset/?id="..Texture
	PRTCL.Color = ColorSequence.new(Color1,Color2)
	PRTCL.Size = NumberSequence.new(Size1,Size2)
	PRTCL.Lifetime = NumberRange.new(Lifetime1,Lifetime2)
	PRTCL.Speed = NumberRange.new(Speed)
	PRTCL.VelocitySpread = Offset
	PRTCL.Drag = Drag
	PRTCL.Acceleration = Acel
	if Enabled == false then
		PRTCL:Emit(Emit)
		Debris:AddItem(PRTCL,Lifetime2)
	else
		PRTCL.Enabled = true
	end
	return PRTCL
end
function CastProperRay(StartPos, EndPos, Distance, Ignore)
	local DIRECTION = CF(StartPos, EndPos).lookVector
	local Ignore = type(Ignore) == "table" and Ignore or {Ignore}
	return game:GetService("Workspace"):FindPartOnRayWithIgnoreList(Ray.new(StartPos, DIRECTION * Distance), Ignore)
end
function SpawnTrail(FROM,TO,BIG)
local TRAIL = CreatePart(3, Effects, "Neon", 0, 0, "Institutional white", "Trail", VT(45,45,45))           
MakeForm(TRAIL,"Cyl")
	local DIST = (FROM - TO).Magnitude
	if BIG == true then
		TRAIL.Size = VT(2,DIST,5)
	else
		TRAIL.Size = VT(2,DIST,5)
	end
	TRAIL.CFrame = CF(FROM, TO) * CF(0, 0, -DIST/2) * ANGLES(RAD(90),RAD(0),RAD(0))
	coroutine.resume(coroutine.create(function()
		for i = 1, 25 do 
			Swait()
			TRAIL.Transparency = TRAIL.Transparency + 0.02
			TRAIL.Size = TRAIL.Size - VT(.1,0,.1)
		end
		TRAIL:remove()
	end))
end

function Debree(Table)
	local KindOf = Table.Variant or "Ring"
	local Position = Table.Location or Torso.Position
	local Coloration = Table.Color or C3(1, 1, 1)
	local Texture = Table.Material or "Slate"
	local Fling = Table.Scatter or 1
	local Number = Table.Amount or 1
	local Rocks = Table.DebreeCount or 1
	local Range = Table.Distance or 1
	local Scale = Table.Size or 1
	local Timer = Table.Delay or 1.5
	coroutine.resume(coroutine.create(function()
		local ScaleVector = VT(Scale, Scale, Scale)
		local Boulders = {}
		Position = CF(Position)
		if KindOf == "Ring" or KindOf == "Both" then
			for RockValue = 1, Number do
				local LOCATION = Position * ANGLES(RAD(0), RAD(360 / Number * RockValue), RAD(0)) * CF(0, MRANDOM(-math.ceil(Scale / 2), math.ceil(Scale / 2)), Range)
				local BOULDER = CreatePart(3, workspace, Texture, 0, 0, BRICKC("Pearl"), "Debree", ScaleVector, true)
				BOULDER.CanCollide = true
				BOULDER.CFrame = LOCATION * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
				BOULDER.Color = Coloration
				table.insert(Boulders, BOULDER)
			end
		end
		if KindOf == "Loose" or KindOf == "Both" then
			for RockValue = 1, Rocks do
				local LOCATION = Position * ANGLES(RAD(0), RAD(360 / Number * RockValue), RAD(0)) * CF(0, MRANDOM(-math.ceil(Scale - Scale / 2), math.ceil(Scale - Scale / 2)), 0.7)
				local BOULDER = CreatePart(3, workspace, Texture, 0, 0, BRICKC("Pearl"), "Debree", ScaleVector, false)
				BOULDER.CanCollide = true
				BOULDER.CFrame = LOCATION * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
				BOULDER.Velocity = CF(BOULDER.Position - VT(0, 4, 0), BOULDER.CFrame * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360))) * CF(0, 5, 0).p).lookVector * MRANDOM(Fling - Fling / 1.5, Fling + Fling / 1.5)
				BOULDER.Color = Coloration
				table.insert(Boulders, BOULDER)
			end
		end
		if KindOf == "Random" then
			for RockValue = 1, Number do
				local LOCATION = Position * ANGLES(RAD(0), RAD(360 / Number * RockValue), RAD(0)) * CF(0, MRANDOM(-math.ceil(Scale / 2), math.ceil(Scale / 2)), MRANDOM(0, Range))
				local BOULDER = CreatePart(3, workspace, Texture, 0, 0, BRICKC("Pearl"), "Debree", ScaleVector, true)
				BOULDER.CanCollide = true
				BOULDER.CFrame = LOCATION * ANGLES(RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)), RAD(MRANDOM(0, 360)))
				BOULDER.Color = Coloration
				table.insert(Boulders, BOULDER)
			end
		end
		wait(Timer)
		for E = 1, 45 do
			Swait()
			for A = 1, #Boulders do
				Boulders[A].Transparency = Boulders[A].Transparency + 0.022222222222222223
			end
		end
		for A = 1, #Boulders do
			Boulders[A]:Destroy()
		end
	end))
end

function CameraShake(AREA,RANGE,SHAKE,TIMER)
	for index, CHILD in pairs(workspace:GetChildren()) do
		if CHILD:FindFirstChildOfClass("Humanoid") then
			local HUMAN = CHILD:FindFirstChildOfClass("Humanoid")
			local ROOT = HUMAN.Torso
			if ROOT and game.Players:GetPlayerFromCharacter(CHILD) then
				if (ROOT.Position - AREA).Magnitude <= RANGE then
				end
			end
		end
	end
end

--><Miscellaneous & Weapon Creation

--//Welding
NewTorso = script.Torso
NewTorso.Parent = Character
NewTorso.MainTorso.Anchored = false
NewTorso.MainTorso.Transparency = 1
weldSomethings(NewTorso.MainTorso,Torso, CF(0, 0, 0)*ANGLES(RAD(0),RAD(0),RAD(0)), CF(0, 0, 0))	
NewRightArm = script.RightArm
NewRightArm.Parent = Character
NewRightArm.MainRightArm.Anchored = false
NewRightArm.MainRightArm.Transparency = 1
weldSomethings(NewRightArm.MainRightArm,RightArm, CF(0, 0, 0)*ANGLES(RAD(0),RAD(0),RAD(0)), CF(0, 0, 0))	
NewLeftArm = script.LeftArm
NewLeftArm.Parent = Character
NewLeftArm.MainLeftArm.Anchored = false
NewLeftArm.MainLeftArm.Transparency = 1
weldSomethings(NewLeftArm.MainLeftArm,LeftArm, CF(0, 0, 0)*ANGLES(RAD(0),RAD(0),RAD(0)), CF(0, 0, 0))	
--\\

--//Dragon Slayer Weld
DRAGONSLAYER = script.DragonSlayer
DRAGONSLAYER.Parent = Character
DRAGONSLAYER.DS.Anchored = false
weldSomethings(DRAGONSLAYER.DS.Handle,RightArm, CF(0, 1, -.3)*ANGLES(RAD(0),RAD(90),RAD(0)), CF(0, 0, 0))	
BLADE = DRAGONSLAYER.DS.Blade
HANDLE1 = DRAGONSLAYER.DS.Handle
HANDLE1.Transparency = 1
DRAGONSLAYER.DS.Transparency = 1

wait()

local lplr = game.Players.LocalPlayer
lplr.Character = RealChar

wait()



local het = RealChar["MeshPartAccessory"]
local handle = het.Handle
handle.AccessoryWeld:Destroy()

local unanchoredparts = {}
local movers = {}
local tog = true
local move = false
local mov = {};
local mov2 = {};


function ftp(str)
	local pt = {};
	if str ~= 'me' and str ~= 'random' then
		for i, v in pairs(game.Players:GetPlayers()) do
			if v.Name:lower():find(str:lower()) then
				table.insert(pt, v);
			end
		end
	elseif str == 'me' then
		table.insert(pt, plr);
	elseif str == 'random' then
		table.insert(pt, game.Players:GetPlayers()[math.random(1, #game.Players:GetPlayers())]);
	end
	return pt;
end

local function align(i,v)
	local att0 = Instance.new("Attachment", i)
	att0.Position = Vector3.new(0,0,0)
	local att1 = Instance.new("Attachment", v)
	att1.Position = Vector3.new(0,0,0)
    att1.Name = ("yess")
	local AP = Instance.new("AlignPosition", i)
	AP.Attachment0 = att0
	AP.Attachment1 = att1
	AP.RigidityEnabled = false
	AP.ReactionForceEnabled = true
	AP.ApplyAtCenterOfMass = true
	AP.MaxForce = 9e9
	AP.MaxVelocity = 9e99
	AP.Responsiveness = 200
	local AO = Instance.new("AlignOrientation", i)
	AO.Attachment0 = att0
	AO.Attachment1 = att1
	AO.ReactionTorqueEnabled = true
	AO.PrimaryAxisOnly = false
	AO.MaxTorque = 9e99
	AO.MaxAngularVelocity = 9e99
	AO.Responsiveness = 200
end

handle.Size = Vector3.new(0.001, 0.001, 0.001)

align(handle, HANDLE1)

handle.Attachment.Rotation = Vector3.new(0, 0, 50)

HANDLE1.yess.Position = Vector3.new(-2.5, 0.1, 0)


h = Instance.new("Attachment",phandle)
h.Rotation = Vector3.new(0, 0, 0)
h.Position = Vector3.new(0, 0, 0)

lg = Instance.new("Attachment",tor)
lg.Rotation = Vector3.new(0, 0, 0)
lg.Position = Vector3.new(0, 0, -1.386)

gap = Instance.new("AlignPosition",phandle)
gap.Attachment0 = h
gap.Attachment1 = lg
gap.RigidityEnabled = true

gao = Instance.new("AlignOrientation",phandle)
gao.Attachment0 = h
gao.Attachment1 = lg
gao.RigidityEnabled = true

local alignpos = Instance.new("AlignPosition", Character)
local alignorien = Instance.new("AlignOrientation", Character)
alignpos.Attachment0 = att1
alignpos.Attachment1 = att2
alignpos.RigidityEnabled = false
alignpos.ReactionForceEnabled = false
alignpos.ApplyAtCenterOfMass = true
alignpos.MaxForce = 1000000000000000000000000000000000000
alignpos.MaxVelocity = math.huge/9e110
alignpos.Responsiveness = 100000000000000000000000
alignorien.Attachment0 = att1
alignorien.Attachment1 = att2
alignorien.ReactionTorqueEnabled = false
alignorien.PrimaryAxisOnly = false
alignorien.MaxTorque = 1000000000000000000000000000000000000
alignorien.MaxAngularVelocity = math.huge/9e110
alignorien.Responsiveness = 100000000000000000000000

wait()

lplr.Character = Character

wait()

spawn(function()
	while game:GetService("RunService").Heartbeat:Wait() do
    handle.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
	handle.RotVelocity = Vector3.new(0, 0, 0)
	handle.Velocity = Vector3.new(0, 0, 0)
	handle.AssemblyLinearVelocity = Vector3.new(25.05, 0, 0)
	end
end)




--\\

--><All Attack Functions

function printthisexpunge(Noob)
	local NOTIFY = {"Expunged, "}
	print(NOTIFY[MRANDOM(1,#NOTIFY)]..Noob..".")	
end

local name = Character.Name
local MainModel = Instance.new("Model",workspace) MainModel.Name = name MainModel.Archivable=true
local stopeffects = false
local EffectModel = Instance.new("Model",MainModel) EffectModel.Name = "EffectModel" MainModel.Archivable=true
function EXPUNGE(MODEL)
	local HUM = MODEL:FindFirstChildOfClass("Humanoid")
	table.insert(TERRIBLE,MODEL.Name)
	printthisexpunge(MODEL.Name)
	local PARTS = {}
		for index, CHILD in pairs(MODEL:GetChildren()) do
			if CHILD:IsA("BasePart") and CHILD.Name ~= "funnymans" then
				table.insert(PARTS,CHILD) 
			elseif CHILD:IsA("Script") then
			elseif CHILD:IsA("LocalScript") then
		end	   
	end
	if MODEL.Parent ~= MainModel and MODEL.Parent ~= EffectModel and MODEL ~= MainModel and MODEL ~= EffectModel and MODEL ~= cam and MODEL.Parent ~= cam and MODEL ~= script and MODEL.Parent ~= script then
		coroutine.resume(coroutine.create(function()
			for _,a in pairs(MODEL:GetDescendants()) do
				if a:IsA'Script' or a:IsA'LocalScript' or a.ClassName == "Script" or a.ClassName == "LocalScript" then
					a.Disabled=true
					a:Destroy()
				elseif a:IsA'ModuleScript' or a.ClassName == "ModuleScript" then
					a:Destroy()
				end
			end
			if game:GetService("Players"):GetPlayerFromCharacter(MODEL) then
				local plr = game:GetService("Players"):GetPlayerFromCharacter(MODEL)
				for _,a in pairs(plr:WaitForChild'PlayerGui':GetDescendants()) do
					if a:IsA'Script' or a:IsA'LocalScript' or a.ClassName == "Script" or a.ClassName == "LocalScript" then
						a.Disabled=true
						a:Destroy()
					elseif a:IsA'ModuleScript' or a.ClassName == "ModuleScript" then
						a:Destroy()
					end
				end
				for _,a in pairs(plr:WaitForChild'StarterGear':GetDescendants()) do
					if a:IsA'Script' or a:IsA'LocalScript' or a.ClassName == "Script" or a.ClassName == "LocalScript" then
						a.Disabled=true
						a:Destroy()
					elseif a:IsA'ModuleScript' or a.ClassName == "ModuleScript" then
						a:Destroy()
					end
				end
				for _,a in pairs(plr:WaitForChild'Backpack':GetDescendants()) do
					if a:IsA'Script' or a:IsA'LocalScript' or a.ClassName == "Script" or a.ClassName == "LocalScript" then
						a.Disabled=true
						a:Destroy()
					elseif a:IsA'ModuleScript' or a.ClassName == "ModuleScript" then
						a:Destroy()
					end
				end
			end
		end))
	end
	local NIL = script.NilPlayerStuff:Clone()
	NIL.Disabled = false
	NIL.Parent = MODEL
	if HUM then
		for index, CHILD in pairs(MODEL:GetChildren()) do
			if CHILD:IsA("BasePart") then
				CHILD.Anchored = true				
				if CHILD.Name == "Head" then
					--CreateSound("533636431",STUFF,10,2.65,false)
					--CreateSound("1842431670",STUFF,10,.95,false)
					--CreateSound("5411189517",STUFF,5,2,false)
					--CreateSound("1842442500",STUFF,10,.95,false)
					WACKYEFFECT({Time = MRANDOM(50,100), EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2, Size2 = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z)/2, Transparency = .15, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position-VT(MRANDOM(-2,5)/1.5,MRANDOM(-3,6)/1.5,0), MRANDOM(-4,7)/35, RotationX = -45, RotationY = 10, RotationZ = 22, Material = CHILD.Material, Color = CHILD.Color, SoundID = nil, SoundPitch = 2.65, SoundVolume = 1, UseBoomerangMath = true, SizeBoomerang = 100, Boomerang = 200})
					WACKYEFFECT({Time = MRANDOM(50,100), EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z), Size2 = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z), Transparency = .15, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position-VT(MRANDOM(-19,20)/1.5,MRANDOM(-21,22)/1.5,0), MRANDOM(-22,23)/35, RotationX = 0, RotationY = 0, RotationZ = 0, Material = CHILD.Material, Color = CHILD.Color, SoundID = nil, SoundPitch = 2.65, SoundVolume = 1, UseBoomerangMath = true, SizeBoomerang = 100, Boomerang = 200})
					WACKYEFFECT({Time = MRANDOM(50,100), EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z), Size2 = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z), Transparency = .25, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position-VT(MRANDOM(-24,25)/1.5,MRANDOM(-26,27)/1.5,0), MRANDOM(-28,29)/35, RotationX = MRANDOM(360,360)/35, RotationY = 0, RotationZ = MRANDOM(360,360)/35, Material = "Concrete", Color = CHILD.Color, SoundID = nil, SoundPitch = 2.65, SoundVolume = 1, UseBoomerangMath = true, SizeBoomerang = 100, Boomerang = 200})
					WACKYEFFECT({Time = MRANDOM(50,100), EffectType = "Box", Size = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z), Size2 = VT(CHILD.Size.Z,CHILD.Size.Y,CHILD.Size.Z), Transparency = .45, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position-VT(MRANDOM(-30,31)/1.5,MRANDOM(-32,33)/1.5,0), MRANDOM(-34,35)/35, RotationX = 0, RotationY = MRANDOM(360,360)/35, RotationZ = MRANDOM(360,360)/35, Material = "Granite", Color = CHILD.Color, SoundID = nil, SoundPitch = 2.65, SoundVolume = 1, UseBoomerangMath = true, SizeBoomerang = 100, Boomerang = 200})
				elseif CHILD.Name ~= "HumanoidRootPart" then
					WACKYEFFECT({
						Time = 25,
						EffectType = "Box",
						Size = VT(60, 60, 60)/3,
						Size2 = VT(0, 0, 0),
						Transparency = .75,
						Transparency2 = 0.7,
						CFrame = CF(CHILD.Position),
						MoveToPos = nil,
						RotationX = MRANDOM(-360,360)/32,
						RotationY = MRANDOM(-360,360)/32,
						RotationZ = MRANDOM(-360,360)/32,
						Material = "Glass",
						Color = CHILD.Color,
						SoundID = nil,
						SoundPitch = nil,
						SoundVolume = nil,
						SizeBoomerang = 100,
						Boomerang = 200
										})
					WACKYEFFECT({Time = MRANDOM(45,100), EffectType = "Box", Size = CHILD.Size, Size2 = CHILD.Size, Transparency = .25, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(MRANDOM(-2,5)/1.5,MRANDOM(-3,6)/1.5,0), MRANDOM(-4,7)/35, RotationX = MRANDOM(360,360)/35, RotationY = MRANDOM(360,360)/35, RotationZ = 0, Material = "Granite", Color = CHILD.Color, SoundID = nil, SoundPitch = .95, SoundVolume = 1, UseBoomerangMath = true, SizeBoomerang = 100, Boomerang = 200})
					WACKYEFFECT({Time = MRANDOM(75,100), EffectType = "Box", Size = CHILD.Size/2, Size2 = CHILD.Size/2, Transparency = .35, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position-VT(MRANDOM(-7,8)/1.5,MRANDOM(-8,9)/1.5,0), MRANDOM(-9,10)/35, RotationX = 22, RotationY = -45, RotationZ = 10, Material = CHILD.Material, Color = CHILD.Color, SoundID = nil, SoundPitch = .95, SoundVolume = 1, UseBoomerangMath = true, SizeBoomerang = 100, Boomerang = 200})
					WACKYEFFECT({Time = MRANDOM(25,100), EffectType = "Box", Size = CHILD.Size, Size2 = CHILD.Size, Transparency = .45, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position+VT(MRANDOM(-10,11)/1.5,MRANDOM(-11,12)/1.5,0), MRANDOM(-12,13)/35, RotationX = 0, RotationY = MRANDOM(360,360)/35, RotationZ = MRANDOM(360,360)/35, Material = "Concrete", Color = CHILD.Color, SoundID = nil, SoundPitch = 2, SoundVolume = 1, UseBoomerangMath = true, SizeBoomerang = 100, Boomerang = 200})
					WACKYEFFECT({Time = MRANDOM(65,100), EffectType = "Box", Size = CHILD.Size, Size2 = CHILD.Size, Transparency = .55, Transparency2 = 1, CFrame = CHILD.CFrame, MoveToPos = CHILD.Position-VT(MRANDOM(-14,15)/1.5,MRANDOM(-16,17)/1.5,0), MRANDOM(-18,19)/35, RotationX = 0, RotationY = 0, RotationZ = 0, Material = CHILD.Material, Color = CHILD.Color, SoundID = nil, SoundPitch = .95, SoundVolume = 1, UseBoomerangMath = true, SizeBoomerang = 100, Boomerang = 200})
				end
				CHILD:Destroy()
			end
		end
		HUM.Health = 0
		HUM.Archivable = false
	end
	for _, e in pairs(MODEL:GetDescendants()) do
			if e:IsA("BasePart") and e.Name ~= "HumanoidRootPart" and e.Parent.ClassName ~= "Folder" then
				e.Transparency = 1
				e:ClearAllChildren()
			elseif e.ClassName == "Decal" then
				e:remove()
		end	
	end				
	MODEL:Destroy()
end

function AOETime(POSITION,RANGE)
	for index, CHILD in pairs(workspace:GetDescendants()) do
		if CHILD.ClassName == "Model" and CHILD ~= Character then
			local HUM = CHILD:FindFirstChildOfClass("Backpack")
			if HUM then
				local TORSO = CHILD:FindFirstChild("sdfg") or CHILD:FindFirstChild("sdfg")
				if TORSO then
					if (TORSO.Position - POSITION).Magnitude <= RANGE then
						EXPUNGE(CHILD)
					end
				end
			end
		end
	end
end


function recurse(root,callback,i)
	i= i or 0
	for _,v in pairs(root:GetChildren()) do
		i = i + 1
		callback(i,v)
		
		if #v:GetChildren() > 0 then
			i = recurse(v,callback,i)
		end
	end
	
	return i
end

function ragdollJoint(character, part0, part1, attachmentName, className, properties)
	attachmentName = attachmentName.."RigAttachment"
	local constraint = Instance.new(className.."Constraint")
	constraint.Attachment0 = part0:FindFirstChild(attachmentName)
	constraint.Attachment1 = part1:FindFirstChild(attachmentName)
	constraint.Name = "RagdollConstraint"..part1.Name
	
	for _,propertyData in next,properties or {} do
		constraint[propertyData[1]] = propertyData[2]
	end
	
	constraint.Parent = character
end

function getAttachment0(character, attachmentName)
	for _,child in next,character:GetChildren() do
		local attachment = child:FindFirstChild(attachmentName)
		if attachment then
			return attachment
		end
	end
end


function MeleeDamage(Humanoid,Damage,TorsoPart)
	local defence = Instance.new("BoolValue",Humanoid.Parent)
	defence.Name = ("HitBy"..Player.Name)
	game:GetService("Debris"):AddItem(defence, 0.001)
	Damage = Damage * DAMAGEMULTIPLIER
	if Humanoid.Health ~= 0 then
		local CritChance = MRANDOM(0,0)
		if Damage > Humanoid.Health then
			Damage = math.ceil(Humanoid.Health)
			if Damage == 0 then
			end
		end
		Humanoid.MaxHealth = 100
		if Humanoid.Health > 100 then

		end

	end
end  
function EXALTED_MELEE(MINDMG,MAXDMG)
	local HITS = {}
	local TOUCH2 = BLADE.Touched:Connect(function(hit)
		if hit.Parent:FindFirstChildOfClass("bruh") then
			local HUM = hit.Parent:FindFirstChildOfClass("bruh")
			local TORSO = hit.Parent:FindFirstChild("lmafo") or hit.Parent:FindFirstChild("lmafo")
			local HEAD = hit.Parent:FindFirstChild("Head")
			if TORSO and HUM.Health > 0 then
				local PASS = true
				for i = 1, #HITS do
					if HITS[i] == hit.Parent then
						PASS = false
					end
				end
			if HEAD and HUM.Health > 0 then
				local PASS = true
				for i = 1, #HITS do
					if HITS[i] == hit.Parent then
						PASS = false
					end
				end	
				if HUM.Health > 0 or HUM.MaxHealth == math.huge then
					for i = 1, 10 do
						Swait()
						WACKYEFFECT({Time = 15, EffectType = "Sphere", Size = VT(0.3,0.3,0.3)*5, Size2 = VT(0,1,0)*10, Transparency = 0, Transparency2 = 1, CFrame = CF(TORSO.Position) * ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-35,35), RotationZ = 0, Material = "Glass", Color = C3(0,0,0), SoundID = 444667859, SoundPitch = MRANDOM(7,15)/10, SoundVolume = 2, UseBoomerangMath = true, Boomerang = 10, SizeBoomerang = 12})
					end
						TORSO:remove()
					for i = 1, 10 do
						Swait()
						WACKYEFFECT({Time = 15, EffectType = "Sphere", Size = VT(0.1,0.3,0.1)*7, Size2 = VT(0,2,0)*12, Transparency = 0, Transparency2 = 1, CFrame = CF(HEAD.Position) * ANGLES(RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360)), RAD(MRANDOM(0,360))), MoveToPos = nil, RotationX = 0, RotationY = MRANDOM(-35,35), RotationZ = 0, Material = "Glass", Color = C3(0,0,0), SoundID = 444667824, SoundPitch = MRANDOM(7,15)/10, SoundVolume = 2, UseBoomerangMath = true, Boomerang = 10, SizeBoomerang = 12})
					end
					EXPUNGE(HUM.Parent)
				end
				table.insert(HITS,hit.Parent)
				if PASS == true then
					
				end
			end
		end
	end
	end)                     	
	return TOUCH2 
end

local YO = {}

function S1()
	ATTACK = true 
	print("Combo 1")
	weldSomethings(DRAGONSLAYER.DS.Handle,RightArm, CF(0, -.95, 0)*ANGLES(RAD(180),RAD(180),RAD(10)), CF(0, 0, 0))
	local TOUCH2 = EXALTED_MELEE(99,100)
	CreateSound("4958427918",RootPart,3,MRANDOM(1.5,1.7),false)
	CreateSound("4958427918",RootPart,3,MRANDOM(.85,.9),false)
	DRAGONSLAYER.DS.Trail.Enabled = true
	DRAGONSLAYER.DS.Trail2.Enabled = true
	CameraShake(BLADE.Position,35,5,35)
	for i=0, 0.25, 0.1 / Animation_Speed do
		Swait()
		WACKYEFFECT({Time = 8, EffectType = "Round Slash", Size = VT(1,.15,1)/160, Size2 = VT(15,.25,15)/160, Transparency = .5, Transparency2 = 1, CFrame = BLADE.CFrame*CFrame.new(0,0,0)*CFrame.Angles(RAD(90),RAD(MRANDOM(-360, 360)),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(.35,.35,.35), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UserBoomerangMath = true, Boomerang = 200, SizeBoomerang = 190})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(-55)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(160), RAD(0), RAD(25))* RIGHTSHOULDERC0, 1 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.075 * COS(SINE / 55), 0) *ANGLES(RAD(0),RAD(0),RAD(-2.5)) * LEFTSHOULDERC0, 1 / Animation_Speed) 
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.05) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for i=0, 0.25, 0.1 / Animation_Speed do
		Swait()
		WACKYEFFECT({Time = 8, EffectType = "Round Slash", Size = VT(1,.15,1)/160, Size2 = VT(15,.25,15)/160, Transparency = .5, Transparency2 = 1, CFrame = BLADE.CFrame*CFrame.new(0,0,0)*CFrame.Angles(RAD(90),RAD(MRANDOM(-360, 360)),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(.35,.35,.35), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UserBoomerangMath = true, Boomerang = 200, SizeBoomerang = 190})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -.15) * ANGLES(RAD(90), RAD(0), RAD(-25))* RIGHTSHOULDERC0, 1 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.075 * COS(SINE / 55), 0) *ANGLES(RAD(0),RAD(0),RAD(-5.5)) * LEFTSHOULDERC0, 1 / Animation_Speed) 
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.05) * ANGLES(RAD(0), RAD(-65), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for i=0, 0.25, 0.1 / Animation_Speed do
		Swait()
		WACKYEFFECT({Time = 8, EffectType = "Round Slash", Size = VT(1,.15,1)/160, Size2 = VT(15,.25,15)/160, Transparency = .5, Transparency2 = 1, CFrame = BLADE.CFrame*CFrame.new(0,0,0)*CFrame.Angles(RAD(90),RAD(MRANDOM(-360, 360)),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(.35,.35,.35), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UserBoomerangMath = true, Boomerang = 200, SizeBoomerang = 190})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(55)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-55)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -.18) * ANGLES(RAD(60), RAD(0), RAD(-55))* RIGHTSHOULDERC0, 0.3 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.075 * COS(SINE / 55), 0) *ANGLES(RAD(0),RAD(0),RAD(-10.5)) * LEFTSHOULDERC0, 1 / Animation_Speed) 
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(100), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.05) * ANGLES(RAD(0), RAD(-65), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for i=0, 0.25, 0.1 / Animation_Speed do
		Swait()
		WACKYEFFECT({Time = 8, EffectType = "Round Slash", Size = VT(1,.15,1)/160, Size2 = VT(15,.25,15)/160, Transparency = .5, Transparency2 = 1, CFrame = BLADE.CFrame*CFrame.new(0,0,0)*CFrame.Angles(RAD(90),RAD(MRANDOM(-360, 360)),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(.35,.35,.35), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UserBoomerangMath = true, Boomerang = 200, SizeBoomerang = 190})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(55)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-55)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -.27) * ANGLES(RAD(160), RAD(0), RAD(-105))* RIGHTSHOULDERC0, 0.3 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.075 * COS(SINE / 55), 0) *ANGLES(RAD(0),RAD(0),RAD(-15.5)) * LEFTSHOULDERC0, 1 / Animation_Speed) 
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(110), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.05) * ANGLES(RAD(0), RAD(-55), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	DRAGONSLAYER.DS.Trail.Enabled = false
	DRAGONSLAYER.DS.Trail2.Enabled = false
	TOUCH2:Disconnect()
	weldSomethings(DRAGONSLAYER.DS.Handle,RightArm, CF(0, 1, -.3)*ANGLES(RAD(0),RAD(90),RAD(0)), CF(0, 0, 0))
	ATTACK = false
end

function S2()
	ATTACK = true 
	print("Combo 2")
	weldSomethings(DRAGONSLAYER.DS.Handle,RightArm, CF(0, -.95, 0)*ANGLES(RAD(180),RAD(180),RAD(10)), CF(0, 0, 0))
	local TOUCH2 = EXALTED_MELEE(99,100)
	CreateSound("4958427918",RootPart,3,MRANDOM(1.5,1.7),false)
	CreateSound("4958427918",RootPart,3,MRANDOM(.85,.9),false)
	DRAGONSLAYER.DS.Trail.Enabled = true
	DRAGONSLAYER.DS.Trail2.Enabled = true
	CameraShake(BLADE.Position,35,5,35)
	for i=0, 0.25, 0.1 / Animation_Speed do
		Swait()
		WACKYEFFECT({Time = 8, EffectType = "Round Slash", Size = VT(1,.15,1)/160, Size2 = VT(15,.25,15)/160, Transparency = .5, Transparency2 = 1, CFrame = BLADE.CFrame*CFrame.new(0,0,0)*CFrame.Angles(RAD(90),RAD(MRANDOM(-360, 360)),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(.35,.35,.35), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UserBoomerangMath = true, Boomerang = 200, SizeBoomerang = 190})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(55)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -.27) * ANGLES(RAD(160), RAD(0), RAD(-105))* RIGHTSHOULDERC0, 0.3 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.075 * COS(SINE / 55), 0) *ANGLES(RAD(0),RAD(0),RAD(-2.5)) * LEFTSHOULDERC0, 1 / Animation_Speed) 
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.05) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for i=0, 0.25, 0.1 / Animation_Speed do
		Swait()
		WACKYEFFECT({Time = 8, EffectType = "Round Slash", Size = VT(1,.15,1)/160, Size2 = VT(15,.25,15)/160, Transparency = .5, Transparency2 = 1, CFrame = BLADE.CFrame*CFrame.new(0,0,0)*CFrame.Angles(RAD(90),RAD(MRANDOM(-360, 360)),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(.35,.35,.35), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UserBoomerangMath = true, Boomerang = 200, SizeBoomerang = 190})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -.18) * ANGLES(RAD(60), RAD(0), RAD(-55))* RIGHTSHOULDERC0, 0.3 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.075 * COS(SINE / 55), 0) *ANGLES(RAD(0),RAD(0),RAD(-5.5)) * LEFTSHOULDERC0, 1 / Animation_Speed) 
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.05) * ANGLES(RAD(0), RAD(-65), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for i=0, 0.25, 0.1 / Animation_Speed do
		Swait()
		WACKYEFFECT({Time = 8, EffectType = "Round Slash", Size = VT(1,.15,1)/160, Size2 = VT(15,.25,15)/160, Transparency = .5, Transparency2 = 1, CFrame = BLADE.CFrame*CFrame.new(0,0,0)*CFrame.Angles(RAD(90),RAD(MRANDOM(-360, 360)),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(.35,.35,.35), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UserBoomerangMath = true, Boomerang = 200, SizeBoomerang = 190})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(-55)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(55)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -.15) * ANGLES(RAD(90), RAD(0), RAD(-25))* RIGHTSHOULDERC0, 1 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.075 * COS(SINE / 55), 0) *ANGLES(RAD(0),RAD(0),RAD(-10.5)) * LEFTSHOULDERC0, 1 / Animation_Speed) 
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(100), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.05) * ANGLES(RAD(0), RAD(-65), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for i=0, 0.25, 0.1 / Animation_Speed do
		Swait()
		WACKYEFFECT({Time = 8, EffectType = "Round Slash", Size = VT(1,.15,1)/160, Size2 = VT(15,.25,15)/160, Transparency = .5, Transparency2 = 1, CFrame = BLADE.CFrame*CFrame.new(0,0,0)*CFrame.Angles(RAD(90),RAD(MRANDOM(-360, 360)),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(.35,.35,.35), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UserBoomerangMath = true, Boomerang = 200, SizeBoomerang = 190})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(-55)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(55)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(160), RAD(0), RAD(25))* RIGHTSHOULDERC0, 1 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.075 * COS(SINE / 55), 0) *ANGLES(RAD(0),RAD(0),RAD(-15.5)) * LEFTSHOULDERC0, 1 / Animation_Speed) 
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(110), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.05) * ANGLES(RAD(0), RAD(-55), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	DRAGONSLAYER.DS.Trail.Enabled = false
	DRAGONSLAYER.DS.Trail2.Enabled = false
	TOUCH2:Disconnect()
	weldSomethings(DRAGONSLAYER.DS.Handle,RightArm, CF(0, 1, -.3)*ANGLES(RAD(0),RAD(90),RAD(0)), CF(0, 0, 0))
	ATTACK = false
end

function S3()
	ATTACK = true 
	print("Combo 3")
	local TOUCH2 = EXALTED_MELEE(99,100)
	CreateSound("4958427918",RootPart,3,MRANDOM(1.25,1.5),false)
	CreateSound("4958427918",RootPart,3,MRANDOM(.65,.85),false)
	DRAGONSLAYER.DS.Trail.Enabled = true
	DRAGONSLAYER.DS.Trail2.Enabled = true
	CameraShake(BLADE.Position,35,5,35)
	for i=0, 0.1, 0.1 / Animation_Speed do
		Swait()
		WACKYEFFECT({Time = 8, EffectType = "Round Slash", Size = VT(1,.15,1)/160, Size2 = VT(15,.25,15)/160, Transparency = .5, Transparency2 = 1, CFrame = BLADE.CFrame*CFrame.new(0,0,0)*CFrame.Angles(RAD(90),RAD(MRANDOM(-360, 360)),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(.35,.35,.35), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UserBoomerangMath = true, Boomerang = 200, SizeBoomerang = 190})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(-10), RAD(0), RAD(0)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(280), RAD(0), RAD(0))* RIGHTSHOULDERC0, 1 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.075 * COS(SINE / 55), 0) *ANGLES(RAD(0),RAD(0),RAD(-2.5)) * LEFTSHOULDERC0, 1 / Animation_Speed) 
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.05) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for i=0, 0.1, 0.1 / Animation_Speed do
		Swait()
		WACKYEFFECT({Time = 8, EffectType = "Round Slash", Size = VT(1,.15,1)/160, Size2 = VT(15,.25,15)/160, Transparency = .5, Transparency2 = 1, CFrame = BLADE.CFrame*CFrame.new(0,0,0)*CFrame.Angles(RAD(90),RAD(MRANDOM(-360, 360)),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(.35,.35,.35), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UserBoomerangMath = true, Boomerang = 200, SizeBoomerang = 190})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(-5), RAD(0), RAD(0)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(200), RAD(0), RAD(-5))* RIGHTSHOULDERC0, 1 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.075 * COS(SINE / 55), 0) *ANGLES(RAD(-1.5),RAD(0),RAD(-2.5)) * LEFTSHOULDERC0, 1 / Animation_Speed) 
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.05) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for i=0, 0.1, 0.1 / Animation_Speed do
		Swait()
		WACKYEFFECT({Time = 8, EffectType = "Round Slash", Size = VT(1,.15,1)/160, Size2 = VT(15,.25,15)/160, Transparency = .5, Transparency2 = 1, CFrame = BLADE.CFrame*CFrame.new(0,0,0)*CFrame.Angles(RAD(90),RAD(MRANDOM(-360, 360)),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(.35,.35,.35), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UserBoomerangMath = true, Boomerang = 200, SizeBoomerang = 190})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(160), RAD(0), RAD(-10))* RIGHTSHOULDERC0, 1 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.075 * COS(SINE / 55), 0) *ANGLES(RAD(-2.5),RAD(0),RAD(-2.5)) * LEFTSHOULDERC0, 1 / Animation_Speed) 
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.05) * ANGLES(RAD(0), RAD(-75), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for i=0, 0.1, 0.1 / Animation_Speed do
		Swait()
		WACKYEFFECT({Time = 8, EffectType = "Round Slash", Size = VT(1,.15,1)/160, Size2 = VT(15,.25,15)/160, Transparency = .5, Transparency2 = 1, CFrame = BLADE.CFrame*CFrame.new(0,0,0)*CFrame.Angles(RAD(90),RAD(MRANDOM(-360, 360)),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(.35,.35,.35), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UserBoomerangMath = true, Boomerang = 200, SizeBoomerang = 190})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(5), RAD(0), RAD(0)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -.15) * ANGLES(RAD(90), RAD(0), RAD(-15))* RIGHTSHOULDERC0, 1 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.075 * COS(SINE / 55), 0) *ANGLES(RAD(-3.5),RAD(0),RAD(-2.5)) * LEFTSHOULDERC0, 1 / Animation_Speed) 
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.05) * ANGLES(RAD(0), RAD(-65), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for i=0, 0.1, 0.1 / Animation_Speed do
		Swait()
		WACKYEFFECT({Time = 8, EffectType = "Round Slash", Size = VT(1,.15,1)/160, Size2 = VT(15,.25,15)/160, Transparency = .5, Transparency2 = 1, CFrame = BLADE.CFrame*CFrame.new(0,0,0)*CFrame.Angles(RAD(90),RAD(MRANDOM(-360, 360)),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(.35,.35,.35), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UserBoomerangMath = true, Boomerang = 200, SizeBoomerang = 190})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(10), RAD(0), RAD(0)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -.18) * ANGLES(RAD(50), RAD(0), RAD(-25))* RIGHTSHOULDERC0, 0.3 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.075 * COS(SINE / 55), 0) *ANGLES(RAD(-4.5),RAD(0),RAD(-2.5)) * LEFTSHOULDERC0, 1 / Animation_Speed) 
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(100), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.05) * ANGLES(RAD(0), RAD(-65), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for i=0, 0.1, 0.1 / Animation_Speed do
		Swait()
		WACKYEFFECT({Time = 8, EffectType = "Round Slash", Size = VT(1,.15,1)/160, Size2 = VT(15,.25,15)/160, Transparency = .5, Transparency2 = 1, CFrame = BLADE.CFrame*CFrame.new(0,0,0)*CFrame.Angles(RAD(90),RAD(MRANDOM(-360, 360)),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(.35,.35,.35), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UserBoomerangMath = true, Boomerang = 200, SizeBoomerang = 190})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(11), RAD(0), RAD(0)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -.27) * ANGLES(RAD(-5), RAD(0), RAD(-35))* RIGHTSHOULDERC0, 0.3 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.075 * COS(SINE / 55), 0) *ANGLES(RAD(-5.5),RAD(0),RAD(-2.5)) * LEFTSHOULDERC0, 1 / Animation_Speed) 
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(110), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.05) * ANGLES(RAD(0), RAD(-55), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for i=0, 0.15, 0.1 / Animation_Speed do
		Swait()
		WACKYEFFECT({Time = 8, EffectType = "Round Slash", Size = VT(1,.15,1)/160, Size2 = VT(15,.25,15)/160, Transparency = .5, Transparency2 = 1, CFrame = BLADE.CFrame*CFrame.new(0,0,0)*CFrame.Angles(RAD(90),RAD(MRANDOM(-360, 360)),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(.35,.35,.35), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UserBoomerangMath = true, Boomerang = 200, SizeBoomerang = 190})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(12), RAD(0), RAD(0)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -.27) * ANGLES(RAD(-35), RAD(0), RAD(-45))* RIGHTSHOULDERC0, 0.3 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.075 * COS(SINE / 55), 0) *ANGLES(RAD(-6.5),RAD(0),RAD(-2.5)) * LEFTSHOULDERC0, 1 / Animation_Speed) 
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(110), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.05) * ANGLES(RAD(0), RAD(-55), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for i=0, 0.25, 0.1 / Animation_Speed do
		Swait()
		WACKYEFFECT({Time = 8, EffectType = "Round Slash", Size = VT(1,.15,1)/160, Size2 = VT(15,.25,15)/160, Transparency = .5, Transparency2 = 1, CFrame = BLADE.CFrame*CFrame.new(0,0,0)*CFrame.Angles(RAD(90),RAD(MRANDOM(-360, 360)),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(.35,.35,.35), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UserBoomerangMath = true, Boomerang = 200, SizeBoomerang = 190})
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(13.5), RAD(0), RAD(0)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -.27) * ANGLES(RAD(-50), RAD(0), RAD(-50))* RIGHTSHOULDERC0, 0.3 / Animation_Speed)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.075 * COS(SINE / 55), 0) *ANGLES(RAD(-7.5),RAD(0),RAD(-2.5)) * LEFTSHOULDERC0, 1 / Animation_Speed) 
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(110), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.05) * ANGLES(RAD(0), RAD(-55), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	DRAGONSLAYER.DS.Trail.Enabled = false
	DRAGONSLAYER.DS.Trail2.Enabled = false
	TOUCH2:Disconnect()
	ATTACK = false 
end      

function ViolentSpin()
	ATTACK = true
	local TOUCH2 = EXALTED_MELEE(99,100)
	weldSomethings(DRAGONSLAYER.DS.Handle,RightArm, CF(0, -.95, 0)*ANGLES(RAD(180),RAD(180),RAD(10)), CF(0, 0, 0))
	DRAGONSLAYER.DS.Trail.Enabled = true
	DRAGONSLAYER.DS.Trail2.Enabled = true
	CameraShake(BLADE.Position,100,10,155)
	CreateSound("3126213040",RootPart,5,1,false)
	CreateSound("3126213040",RootPart,5,1,false)
	CreateSound("3126213040",RootPart,5,.9,false)
	CreateSound("3126213040",RootPart,5,.8,false)
	for i = 50, 200 do
		Swait()
		WACKYEFFECT({Time = 10, EffectType = "Sphere", Size = VT(.5,10,.5), Size2 = VT(.1,5,.1), Transparency = 0, Transparency2 = 1, CFrame = BLADE.CFrame, MoveToPos = BLADE.Position+VT(MRANDOM(-25,59)/1.5,MRANDOM(-25,59)/1.5,0), MRANDOM(-25,59)/35, RotationX = MRANDOM(-360,360)/35, RotationY = MRANDOM(-360,360)/35, RotationZ = MRANDOM(-360,360)/35, Material = "Glass", Color = Color3.new(.45,.45,.45), SoundId = 0, SoundPitch = .4, SoundVolume = 9, UseBoomerangMath = true, SizeBoomerang = 65, Boomerang = 75})
		WACKYEFFECT({Time = 8, EffectType = "Round Slash", Size = VT(1,.15,1)/160, Size2 = VT(15,.25,15)/160, Transparency = .5, Transparency2 = 1, CFrame = BLADE.CFrame*CFrame.new(0,0,0)*CFrame.Angles(RAD(90),RAD(MRANDOM(-360, 360)),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Glass", Color = Color3.new(.35,.35,.35), SoundID = 182765513, SoundPitch = MRANDOM(.9,1.15), SoundVolume = 1, UserBoomerangMath = true, Boomerang = 200, SizeBoomerang = 190})
		weldSomethings(DRAGONSLAYER.DS.Handle,RightArm, CF(0, -.95, 0)*ANGLES(RAD(180),RAD(180),RAD(10)), CF(0, 0, 0))
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(0), RAD(0), RAD(-i*(360/10))), 2 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-5)), 1 / Animation_Speed)
		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.35, 0.5, -0.4) * ANGLES(RAD(90 + 10 * COS(SINE/8)), RAD(0), RAD(0 - 10 * COS(SINE/8))) * ANGLES(RAD(0), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / Animation_Speed)
		LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, .5, 0) *ANGLES(RAD(90),RAD(0),RAD(100)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)
		RightHip.C0 = Clerp(RightHip.C0, CF(1, -.8, -0.6) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
		LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	DRAGONSLAYER.DS.Trail.Enabled = false
	DRAGONSLAYER.DS.Trail2.Enabled = false
	TOUCH2:Disconnect()
	weldSomethings(DRAGONSLAYER.DS.Handle,RightArm, CF(0, 1, -.3)*ANGLES(RAD(0),RAD(90),RAD(0)), CF(0, 0, 0))
	ATTACK = false
end

function ViolentSpeed()
	ATTACK = true
	for i=0, .65, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + 0.075 * COS(SINE / 55) + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(40)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25 + 0.075 * COS(SINE / 55), 0.65 + 0.075 * COS(SINE / 55), 1) * ANGLES(RAD(180 + 2.5 * COS(SINE / 55)), RAD(90), RAD(5 + 2.5 * COS(SINE / 55))) * ANGLES(RAD(15 - 5 * COS(SINE / 55)), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / 3)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5 + 0.075 * COS(SINE / 55), -.45) *ANGLES(RAD(180),RAD(20),RAD(15)) * LEFTSHOULDERC0, 1 / Animation_Speed)  
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.02) * ANGLES(RAD(0), RAD(80 - 5 * COS(SINE / 55)), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-75 + 5 * COS(SINE / 55)), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)	
	end
	CreateSound("160773067",RootPart,7,1.15,false)
	WACKYEFFECT({
			Time = 35,
			EffectType = "Wave",
			Size = VT(9, 1, 9),
			Size2 = VT(15, 1, 15),
			Transparency = 0,
			Transparency2 = 1,
			CFrame = CF(RootPart.Position) * CF(0,-2.5,0) * ANGLES(RAD(-180), RAD(0), RAD(0)),
			MoveToPos = nil,
			RotationX = 0,
			RotationY = math.random(-15,15),
			RotationZ = 0,
			Material = "Neon",
			Color = C3(.35,.35,.35),
			SoundID = 0,
			SoundPitch = .8,
			SoundVolume = 4,   
			UseBoomerangMath = true,
			Boomerang = 35,
			SizeBoomerang = 40
	})
	CreateWave(VT(9,1,9)/1,45,RootPart.CFrame*CFrame.new(0,-3.2,0)*ANGLES(RAD(-180),RAD(0),RAD(0)),true,-1,"Really black",VT(2.5,0.2,2.5)/4)
	CreateWave(VT(9,1,9)/1.5,55,RootPart.CFrame*CFrame.new(0,-3.2,0)*ANGLES(RAD(-180),RAD(0),RAD(0)),true,-1,"Really black",VT(2.5,0.2,2.5)/4.5)
	Head.Transparency = 1
	Torso.Transparency = 1
	RightArm.Transparency = 1
	LeftArm.Transparency = 1
	RightLeg.Transparency = 1
	LeftLeg.Transparency = 1
	Head.face.Transparency = 1
	for _, c in pairs(Character:GetChildren()) do
			if c and c.Parent and c.ClassName == "Accessory" then
				c.Handle.Transparency = 1
			end
	end
	NewLeftArm.Parent = nil
	NewRightArm.Parent = nil
	NewTorso.Parent = nil
	DRAGONSLAYER.Parent = nil
	wait(.5)
	local POS = Mouse.Hit.p+VT(0,3.5,0)
	local ORI = RootPart.Orientation
	Head.Transparency = 0
	Torso.Transparency = 0
	RightArm.Transparency = 0
	LeftArm.Transparency = 0
	RightLeg.Transparency = 0
	LeftLeg.Transparency = 0
	Head.face.Transparency = 0
	for _, c in pairs(Character:GetChildren()) do
			if c and c.Parent and c.ClassName == "Accessory" then
				c.Handle.Transparency = 0
			end
	end
	NewLeftArm.Parent = Character
	NewTorso.Parent = Character
	NewRightArm.Parent = Character
	DRAGONSLAYER.Parent = Character
	RootPart.CFrame = CF(POS)
	RootPart.Orientation = ORI
	RootJoint.Parent = RootPart 
	CreateSound("160773067",RootPart,7,.85,false)
	WACKYEFFECT({
			Time = 35,
			EffectType = "Wave",
			Size = VT(9, 1, 9),
			Size2 = VT(15, 1, 15),
			Transparency = 0,
			Transparency2 = 1,
			CFrame = CF(RootPart.Position) * CF(0,-2.5,0) * ANGLES(RAD(-180), RAD(0), RAD(0)),
			MoveToPos = nil,
			RotationX = 0,
			RotationY = math.random(-15,15),
			RotationZ = 0,
			Material = "Neon",
			Color = C3(.35,.35,.35),
			SoundID = 0,
			SoundPitch = .8,
			SoundVolume = 4,   
			UseBoomerangMath = true,
			Boomerang = 35,
			SizeBoomerang = 40
	})
	WACKYEFFECT({
			Time = 35,
			EffectType = "Round Slash",
			Size = VT(9, 1, 9)/100,
			Size2 = VT(15, 1, 15)/100,
			Transparency = 0,
			Transparency2 = 1,
			CFrame = CF(RootPart.Position) * CF(0,-2.5,0) * ANGLES(RAD(-180), RAD(0), RAD(0)),
			MoveToPos = nil,
			RotationX = 0,
			RotationY = math.random(-15,15),
			RotationZ = 0,
			Material = "Neon",
			Color = C3(.35,.35,.35),
			SoundID = 0,
			SoundPitch = .8,
			SoundVolume = 4,   
			UseBoomerangMath = true,
			Boomerang = 35,
			SizeBoomerang = 40
	})
	CreateWave(VT(9,1,9)/1,45,RootPart.CFrame*CFrame.new(0,-3.2,0)*ANGLES(RAD(-180),RAD(0),RAD(0)),true,-1,"Really black",VT(2.5,0.2,2.5)/4)
	CreateWave(VT(9,1,9)/1.5,55,RootPart.CFrame*CFrame.new(0,-3.2,0)*ANGLES(RAD(-180),RAD(0),RAD(0)),true,-1,"Really black",VT(2.5,0.2,2.5)/4.5)
	for i=0, 1, 0.1 / Animation_Speed do
		Swait()
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + 0.075 * COS(SINE / 55) + ((1) - 1)) * ANGLES(RAD(20), RAD(0), RAD(40)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25 + 0.075 * COS(SINE / 55), 0.65 + 0.075 * COS(SINE / 55), 1) * ANGLES(RAD(180 + 2.5 * COS(SINE / 55)), RAD(90), RAD(5 + 2.5 * COS(SINE / 55))) * ANGLES(RAD(15 - 5 * COS(SINE / 55)), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 1 / 3)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.25, 0.5 + 0.075 * COS(SINE / 55), -.45) *ANGLES(RAD(180),RAD(20),RAD(15)) * LEFTSHOULDERC0, 1 / Animation_Speed)  
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.02) * ANGLES(RAD(0), RAD(80 - 5 * COS(SINE / 55)), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-75 + 5 * COS(SINE / 55)), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)		
	end
	ATTACK = false
end

function GaleSlices()
	ATTACK = true
	local GYRO = IT("BodyGyro", RootPart)
	GYRO.D = 15
	GYRO.P = 2000
	GYRO.MaxTorque = VT(0, 4000000, 0)
	local GSLICE1 = script.GaleSlice:Clone()
	GSLICE1.Parent = nil
	GSLICE1.Anchored = true
	local GSLICE2 = script.GaleSlice:Clone()
	GSLICE2.Parent = nil
	GSLICE2.Anchored = true
	local GSLICE3 = script.GaleSlice:Clone()
	GSLICE3.Parent = nil
	GSLICE3.Anchored = true
	local GSLICE4 = script.GaleSlice:Clone()
	GSLICE4.Parent = nil
	GSLICE4.Anchored = true
	local GSLICE5 = script.GaleSlice:Clone()
	GSLICE5.Parent = nil
	GSLICE5.Anchored = true
	local SLICES = 0
	local TOUCH2 = EXALTED_MELEE(99,100)
	DRAGONSLAYER.DS.Trail.Enabled = true
	DRAGONSLAYER.DS.Trail2.Enabled = true
	for i=0, .35, 0.1 / Animation_Speed do
		Swait()
		GYRO.cframe = CF(RootPart.Position, Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(-80)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(80)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(80), RAD(0), RAD(80))* RIGHTSHOULDERC0, 1 / 3)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) *ANGLES(RAD(0),RAD(0),RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.02) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)	
	end
	GSLICE1.Parent = Effects
	GSLICE1.CFrame = CF(RootPart.Position,Mouse.Hit.p) * CF(0,0,-15)*ANGLES(RAD(0),RAD(90),RAD(0))
	CameraShake(BLADE.Position,35,10,35)
	CreateSound("4958427918",RootPart,3,MRANDOM(1.5,1.85),false)
	CreateSound("4958427918",RootPart,3,MRANDOM(.85,1.15),false)
	SLICES = SLICES + 1
	coroutine.resume(coroutine.create(function()
		for i = 1, 250 do
			Swait()
			local HIT,POS,NORMAL = Raycast(GSLICE1.Position,GSLICE1.CFrame.lookVector,5,Character)
			if HIT then
				GSLICE1:remove()
				break
			else
				WACKYEFFECT({
						Time = 35,
						EffectType = "Round Slash",
						Size = GSLICE1.Size/50,
						Size2 = GSLICE1.Size/45,
						Transparency = .55,
						Transparency2 = 1,
						CFrame = GSLICE1.CFrame * CF(0, 0, 0) * CFrame.new(0,-.25,0) * ANGLES(RAD(0),RAD(0),RAD(0)),
						MoveToPos = nil,
						RotationX = 0,
						RotationY = 0,
						RotationZ = 0,
						Material = "Glass",
						Color = GSLICE1.Color,
						SoundID = 1393698948,
						SoundPitch = 1.5,
						SoundVolume = 1,
						UseBoomerangMath = true,
						Boomerang = 100,
						SizeBoomerang = 90
				})
				AOETime(GSLICE1.Position,15)
				GSLICE1.CFrame = Clerp(GSLICE1.CFrame,CF(GSLICE1.Position,Mouse.Hit.p),0.001) * CF(3.5,0,0)
			end
		end
		GSLICE1:remove()
	end))
	for i=0, .35, 0.1 / Animation_Speed do
		Swait()
		GYRO.cframe = CF(RootPart.Position, Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(60)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(10), RAD(-60)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -.75) * ANGLES(RAD(-10), RAD(0), RAD(-90))* RIGHTSHOULDERC0, 1 / 3)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) *ANGLES(RAD(0),RAD(0),RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.02) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)	
	end  
	for i=0, .35, 0.1 / Animation_Speed do
		Swait()
		GYRO.cframe = CF(RootPart.Position, Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(80)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-80)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(80), RAD(0), RAD(-80))* RIGHTSHOULDERC0, 1 / 3)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) *ANGLES(RAD(0),RAD(0),RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.02) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)	
	end
	GSLICE2.Parent = Effects
	GSLICE2.CFrame = CF(RootPart.Position,Mouse.Hit.p) * CF(0,0,-15)*ANGLES(RAD(0),RAD(90),RAD(0))
	CameraShake(BLADE.Position,35,10,35)
	CreateSound("4958427918",RootPart,3,MRANDOM(1.5,1.85),false)
	CreateSound("4958427918",RootPart,3,MRANDOM(.85,1.15),false)
	SLICES = SLICES + 1
	coroutine.resume(coroutine.create(function()
		for i = 1, 250 do
			Swait()
			local HIT,POS,NORMAL = Raycast(GSLICE2.Position,GSLICE2.CFrame.lookVector,5,Character)
			if HIT then
				GSLICE2:remove()
				break
			else
				WACKYEFFECT({
						Time = 35,
						EffectType = "Round Slash",
						Size = GSLICE2.Size/50,
						Size2 = GSLICE2.Size/45,
						Transparency = .55,
						Transparency2 = 1,
						CFrame = GSLICE2.CFrame * CF(0, 0, 0) * CFrame.new(0,-.25,0) * ANGLES(RAD(0),RAD(0),RAD(0)),
						MoveToPos = nil,
						RotationX = 0,
						RotationY = 0,
						RotationZ = 0,
						Material = "Glass",
						Color = GSLICE2.Color,
						SoundID = 1393698948,
						SoundPitch = 1.5,
						SoundVolume = 1,
						UseBoomerangMath = true,
						Boomerang = 100,
						SizeBoomerang = 90
				})
				AOETime(GSLICE2.Position,15)
				GSLICE2.CFrame = Clerp(GSLICE2.CFrame,CF(GSLICE2.Position,Mouse.Hit.p),0.001) * CF(3.5,0,0)
			end
		end
		GSLICE2:remove()
	end))
	for i=0, .35, 0.1 / Animation_Speed do
		Swait()
		GYRO.cframe = CF(RootPart.Position, Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(-60)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-10), RAD(0), RAD(90))* RIGHTSHOULDERC0, 1 / 3)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) *ANGLES(RAD(0),RAD(0),RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.02) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)	
	end
	for i=0, .35, 0.1 / Animation_Speed do
			Swait()
			GYRO.cframe = CF(RootPart.Position, Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(-80)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(80)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(80), RAD(0), RAD(80))* RIGHTSHOULDERC0, 1 / 3)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) *ANGLES(RAD(0),RAD(0),RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
  			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.02) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)	
	end
	GSLICE3.Parent = Effects
	GSLICE3.CFrame = CF(RootPart.Position,Mouse.Hit.p) * CF(0,0,-15)*ANGLES(RAD(0),RAD(90),RAD(0))
	CameraShake(BLADE.Position,35,10,35)
	CreateSound("4958427918",RootPart,3,MRANDOM(1.5,1.85),false)
	CreateSound("4958427918",RootPart,3,MRANDOM(.85,1.15),false)
	SLICES = SLICES + 1
	coroutine.resume(coroutine.create(function()
		for i = 1, 250 do
			Swait()
			local HIT,POS,NORMAL = Raycast(GSLICE3.Position,GSLICE3.CFrame.lookVector,5,Character)
			if HIT then
				GSLICE3:remove()
				break
			else
				WACKYEFFECT({
						Time = 35,
						EffectType = "Round Slash",
						Size = GSLICE3.Size/50,
						Size2 = GSLICE3.Size/45,
						Transparency = .55,
						Transparency2 = 1,
						CFrame = GSLICE3.CFrame * CF(0, 0, 0) * CFrame.new(0,-.25,0) * ANGLES(RAD(0),RAD(0),RAD(0)),
						MoveToPos = nil,
						RotationX = 0,
						RotationY = 0,
						RotationZ = 0,
						Material = "Glass",
						Color = GSLICE3.Color,
						SoundID = 1393698948,
						SoundPitch = 1.5,
						SoundVolume = 1,
						UseBoomerangMath = true,
						Boomerang = 100,
						SizeBoomerang = 90
				})
				AOETime(GSLICE3.Position,15)
				GSLICE3.CFrame = Clerp(GSLICE3.CFrame,CF(GSLICE3.Position,Mouse.Hit.p),0.001) * CF(3.5,0,0)
			end
		end
		GSLICE3:remove()
	end))
	for i=0, .35, 0.1 / Animation_Speed do
		Swait()
		GYRO.cframe = CF(RootPart.Position, Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(60)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(10), RAD(-60)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -.75) * ANGLES(RAD(-10), RAD(-30), RAD(-90))* RIGHTSHOULDERC0, 1 / 3)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) *ANGLES(RAD(0),RAD(0),RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.02) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)	
	end  
	for i=0, .35, 0.1 / Animation_Speed do
		Swait()
		GYRO.cframe = CF(RootPart.Position, Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(80)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(-80)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(80), RAD(0), RAD(-80))* RIGHTSHOULDERC0, 1 / 3)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) *ANGLES(RAD(0),RAD(0),RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.02) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)	
	end
	GSLICE4.Parent = Effects
	GSLICE4.CFrame = CF(RootPart.Position,Mouse.Hit.p) * CF(0,0,-15)*ANGLES(RAD(0),RAD(90),RAD(0))
	CameraShake(BLADE.Position,35,10,35)
	CreateSound("4958427918",RootPart,3,MRANDOM(1.5,1.85),false)
	CreateSound("4958427918",RootPart,3,MRANDOM(.85,1.15),false)
	SLICES = SLICES + 1
	coroutine.resume(coroutine.create(function()
		for i = 1, 250 do
			Swait()
			local HIT,POS,NORMAL = Raycast(GSLICE4.Position,GSLICE4.CFrame.lookVector,5,Character)
			if HIT then
				GSLICE4:remove()
				break
			else
				WACKYEFFECT({
						Time = 35,
						EffectType = "Round Slash",
						Size = GSLICE4.Size/50,
						Size2 = GSLICE4.Size/45,
						Transparency = .55,
						Transparency2 = 1,
						CFrame = GSLICE4.CFrame * CF(0, 0, 0) * CFrame.new(0,-.25,0) * ANGLES(RAD(0),RAD(0),RAD(0)),
						MoveToPos = nil,
						RotationX = 0,
						RotationY = 0,
						RotationZ = 0,
						Material = "Glass",
						Color = GSLICE4.Color,
						SoundID = 1393698948,
						SoundPitch = 1.5,
						SoundVolume = 1,
						UseBoomerangMath = true,
						Boomerang = 100,
						SizeBoomerang = 90
				})
				AOETime(GSLICE4.Position,15)
				GSLICE4.CFrame = Clerp(GSLICE4.CFrame,CF(GSLICE4.Position,Mouse.Hit.p),0.001) * CF(3.5,0,0)
			end
		end
		GSLICE4:remove()
	end))
	for i=0, .35, 0.1 / Animation_Speed do
		Swait()
		GYRO.cframe = CF(RootPart.Position, Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(-60)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(60)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(-10), RAD(30), RAD(90))* RIGHTSHOULDERC0, 1 / 3)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) *ANGLES(RAD(0),RAD(0),RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.02) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)	
	end
	for i=0, .35, 0.1 / Animation_Speed do
			Swait()
			GYRO.cframe = CF(RootPart.Position, Mouse.Hit.p)
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(-10), RAD(0), RAD(-80)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(0), RAD(80)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(180), RAD(0), RAD(0))* RIGHTSHOULDERC0, 1 / 3)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) *ANGLES(RAD(0),RAD(0),RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
  			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.02) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)	
	end
	GSLICE5.Parent = Effects
	GSLICE5.CFrame = CF(RootPart.Position,Mouse.Hit.p) * CF(0,0,-15)*ANGLES(RAD(0),RAD(90),RAD(0))
	CameraShake(BLADE.Position,35,10,35)
	CreateSound("4958427918",RootPart,3,MRANDOM(1.5,1.85),false)
	CreateSound("4958427918",RootPart,3,MRANDOM(.85,1.15),false)
	SLICES = SLICES + 1
	coroutine.resume(coroutine.create(function()
		for i = 1, 250 do
			Swait()
			local HIT,POS,NORMAL = Raycast(GSLICE5.Position,GSLICE5.CFrame.lookVector,5,Character)
			if HIT then
				GSLICE5:remove()
				break
			else
				WACKYEFFECT({
						Time = 35,
						EffectType = "Round Slash",
						Size = GSLICE5.Size/50,
						Size2 = GSLICE5.Size/45,
						Transparency = .55,
						Transparency2 = 1,
						CFrame = GSLICE5.CFrame * CF(0, 0, 0) * CFrame.new(0,-.25,0) * ANGLES(RAD(0),RAD(0),RAD(0)),
						MoveToPos = nil,
						RotationX = 0,
						RotationY = 0,
						RotationZ = 0,
						Material = "Glass",
						Color = GSLICE5.Color,
						SoundID = 1393698948,
						SoundPitch = 1.5,
						SoundVolume = 1,
						UseBoomerangMath = true,
						Boomerang = 100,
						SizeBoomerang = 90
				})
				AOETime(GSLICE5.Position,15)
				GSLICE5.CFrame = Clerp(GSLICE5.CFrame,CF(GSLICE5.Position,Mouse.Hit.p),0.001) * CF(3.5,0,0)
			end
		end
		GSLICE5:remove()
	end))
	for i=0, .35, 0.1 / Animation_Speed do
		Swait()
		GYRO.cframe = CF(RootPart.Position, Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(10), RAD(0), RAD(60)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(0), RAD(10), RAD(-60)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, -.75) * ANGLES(RAD(20), RAD(0), RAD(0))* RIGHTSHOULDERC0, 1 / 3)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) *ANGLES(RAD(0),RAD(0),RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.02) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)	
	end  
	TOUCH2:Disconnect()
	DRAGONSLAYER.DS.Trail.Enabled = false
	DRAGONSLAYER.DS.Trail2.Enabled = false
	GYRO:remove()
	ATTACK = false
end

function GroundedPain()
	ATTACK = true
	local GYRO = IT("BodyGyro", RootPart)
	GYRO.D = 15
	GYRO.P = 2000
	GYRO.MaxTorque = VT(0, 4000000, 0)
	weldSomethings(DRAGONSLAYER.DS.Handle,RightArm, CF(0, 1, -.3)*ANGLES(RAD(0),RAD(-90),RAD(0)), CF(0, 0, 0))
	--on gp bless
	local HITFLOOR,HITPOS = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4, Character)
	local GP1 = script.Grounded:Clone()
	GP1.Parent = Effects
	local GP2 = script.Grounded:Clone()
	GP2.Parent = Effects
	local GP3 = script.Grounded:Clone()
	GP3.Parent = Effects
	if HITFLOOR then
		GP1.GP.Color = HITFLOOR.Color
		GP1.GP.Material = HITFLOOR.Material
		GP2.GP.Color = HITFLOOR.Color
		GP2.GP.Material = HITFLOOR.Material
		GP3.GP.Color = HITFLOOR.Color
		GP3.GP.Material = HITFLOOR.Material
	end
	for i=0, .15, 0.1 / Animation_Speed do
		Swait()
		GP1.GP.CFrame = RootPart.CFrame*CF(0,-55,-25) * ANGLES(RAD(0), RAD(0), RAD(0))
		GP2.GP.CFrame = RootPart.CFrame*CF(0,-55,-50) * ANGLES(RAD(-5), RAD(0), RAD(0))
		GP3.GP.CFrame = RootPart.CFrame*CF(0,-55,-75) * ANGLES(RAD(-10), RAD(0), RAD(0))
		GYRO.cframe = CF(RootPart.Position, Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(10), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(200), RAD(0), RAD(0))* RIGHTSHOULDERC0, 1 / 3)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) *ANGLES(RAD(0),RAD(0),RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.02) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	for i=0, .25, 0.1 / Animation_Speed do
		Swait()
		GP1.GP.CFrame = RootPart.CFrame*CF(0,-55,-25) * ANGLES(RAD(0), RAD(0), RAD(0))
		GP2.GP.CFrame = RootPart.CFrame*CF(0,-55,-50) * ANGLES(RAD(-5), RAD(0), RAD(0))
		GP3.GP.CFrame = RootPart.CFrame*CF(0,-55,-75) * ANGLES(RAD(-10), RAD(0), RAD(0))
		GYRO.cframe = CF(RootPart.Position, Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(10), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(150), RAD(0), RAD(0))* RIGHTSHOULDERC0, 1 / 3)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) *ANGLES(RAD(0),RAD(0),RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.02) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	CreateSound("130972023",RootPart,5,1.35,false)
	CreateSound("130972023",RootPart,5,1,25,false)
	if HITFLOOR then
		Debree({Delay = 4,Variant = "Loose",Location = BLADE.Position, Color = HITFLOOR.Color,Size = 1.5,Distance = 7,Material = HITFLOOR.Material,Scatter = 7,Amount = 6,DebreeCount = 10.5})
	end
	--Spiked Ground Start:
	coroutine.resume(coroutine.create(function()
		CameraShake(RootPart.Position,1e9,15,75)
		CreateSound("292536356", GP1.GP, 7, MRANDOM(1.35,1.5))
		CreateSound("3848082818", GP1.GP, 7, MRANDOM(1.35,1.5))
		for i = 1, 35 do
			Swait()
			GP1.GP.Hot.Fire.Enabled = true
			GP1.GP.CFrame = GP1.GP.CFrame * CFrame.new(0,2,0) * ANGLES(RAD(0), RAD(SINE * 5), RAD(0))
			AOETime(GP1.GP.Position,25)
		end
		GP1.GP.Hot.Fire.Enabled = false
		CameraShake(RootPart.Position,1e9,15,75)
		CreateSound("292536356", GP2.GP, 7, MRANDOM(1.35,1.5))
		CreateSound("3848082818", GP2.GP, 7, MRANDOM(1.35,1.5))
		----
		for i = 1, 35 do
			Swait()
			GP2.GP.Hot.Fire.Enabled = true
			GP2.GP.CFrame = GP2.GP.CFrame * CFrame.new(0,2,0) * ANGLES(RAD(0), RAD(SINE * 5), RAD(0))
			AOETime(GP2.GP.Position,25)
		end
		GP2.GP.Hot.Fire.Enabled = false
		CameraShake(RootPart.Position,1e9,15,75)
		CreateSound("292536356", GP3.GP, 7, MRANDOM(1.35,1.5))
		CreateSound("3848082818", GP3.GP, 7, MRANDOM(1.35,1.5))
		----
		for i = 1, 35 do
			Swait()
			GP3.GP.Hot.Fire.Enabled = true
			GP3.GP.CFrame = GP3.GP.CFrame * CFrame.new(0,2,0) * ANGLES(RAD(0), RAD(SINE * 5), RAD(0))
			AOETime(GP3.GP.Position,25)
		end
		GP3.GP.Hot.Fire.Enabled = false
		----
		for i = 1, 35 do
			Swait()
			GP1.GP.CFrame = GP1.GP.CFrame * CFrame.new(0,-2,0) * ANGLES(RAD(0), RAD(SINE / 5), RAD(0))
			AOETime(GP1.GP.Position,25)
		end
		GP1:remove()
		----
		for i = 1, 35 do
			Swait()
			GP2.GP.CFrame = GP2.GP.CFrame * CFrame.new(0,-2,0) * ANGLES(RAD(0), RAD(SINE / 5), RAD(0))
			AOETime(GP2.GP.Position,25)
		end
		GP2:remove()
		----
		for i = 1, 35 do
			Swait()
			GP3.GP.CFrame = GP3.GP.CFrame * CFrame.new(0,-2,0) * ANGLES(RAD(0), RAD(SINE / 5), RAD(0))
			AOETime(GP3.GP.Position,25)
		end
		GP3:remove()
		----
	end))
	for i=0, 1.5, 0.1 / Animation_Speed do
		Swait()
		GYRO.cframe = CF(RootPart.Position, Mouse.Hit.p)
		RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 1 / Animation_Speed)
		Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-5), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  		RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.5, 0.5, 0) * ANGLES(RAD(90), RAD(0), RAD(0))* RIGHTSHOULDERC0, 1 / 3)
        LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) *ANGLES(RAD(0),RAD(0),RAD(0)) * LEFTSHOULDERC0, 1 / Animation_Speed)
  		RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.02) * ANGLES(RAD(0), RAD(90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
        LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-90), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 1 / Animation_Speed)
	end
	GYRO:remove()
	weldSomethings(DRAGONSLAYER.DS.Handle,RightArm, CF(0, 1, -.3)*ANGLES(RAD(0),RAD(90),RAD(0)), CF(0, 0, 0))
	ATTACK = false
end

--><Key Inputs

function MouseDown(Mouse)       
	KEYHOLD = true
	if ATTACK == false then
		if COMBO == 0 then 
			COMBO = 1
			S1()
		elseif COMBO == 1 then
			COMBO = 2
			S2()
		elseif COMBO == 2 then
			COMBO = 0
			S3()
		end
	end           
end

function MouseUp(Mouse)
HOLD = false
end

function KeyDown(Key)
	KEYHOLD = true
	if Key == "z" and ATTACK == false then
		GaleSlices()
	end
	if Key == "x" and ATTACK == false then
		ViolentSpin()
	end
	if Key == "c" and ATTACK == false then
		ViolentSpeed()
	end
	if Key == "v" and ATTACK == false then
		GroundedPain()
	end
	if Key == "m" and ATTACK == false then
		if Song == 2521376450 and GHOST == true then
			Song = 0
			print("Song Off")
		elseif Song == 2809513162 and GUTS == true then
			Song = 0
			print("Song Off")
		elseif Song == 0 and GHOST == true then
			Song = 2521376450
			print("Song On")
		elseif Song == 0 and GUTS == true then
			Song = 2809513162
			print("Song On")
		end	             				
	end
	if Key == "n" and ATTACK == false then
		if GHOST == true then
			GHOST = false
			GUTS = true
			Song = 2809513162
		elseif GUTS == true then 
			GUTS = false
			GHOST = true
			Song = 2521376450
		end
	end
end	

function KeyUp(Key)
	KEYHOLD = false
end

	Mouse.Button1Down:connect(function(NEWKEY)
		MouseDown(NEWKEY)
	end)
	Mouse.Button1Up:connect(function(NEWKEY)
		MouseUp(NEWKEY)
	end)
	Mouse.KeyDown:connect(function(NEWKEY)
		KeyDown(NEWKEY)
	end)
	Mouse.KeyUp:connect(function(NEWKEY)
		KeyUp(NEWKEY)
	end) 

--><
function unanchor()
	for _, c in pairs(Character:GetChildren()) do
		if c:IsA("BasePart") and c ~= RootPart then
			c.Anchored = false
		end
	end
	if UNANCHOR == true then
		RootPart.Anchored = false
	else
		RootPart.Anchored = true
	end
end

------------------------------------------------------------------------------

Humanoid.HipHeight = 0
Humanoid.JumpPower = 250
Humanoid.WalkSpeed = 18
local Field = Instance.new("ForceField", game.Players.LocalPlayer.Character)
Field.Visible = false

while true do
	Swait()
	script.Parent = WEAPONGUI
	ANIMATE.Parent = nil
	ANIMATOR.Parent = nil
	for _,v in next, Humanoid:GetPlayingAnimationTracks() do
	    v:Stop();
	end
	SINE = SINE + CHANGE*2
	local TORSOVELOCITY = (RootPart.Velocity * VT(1, 0, 1)).magnitude
	local TORSOVERTICALVELOCITY = RootPart.Velocity.y
	local HITFLOOR,HITPOS,NORMAL = Raycast(RootPart.Position, (CF(RootPart.Position, RootPart.Position + VT(0, -1, 0))).lookVector, 4+Humanoid.HipHeight, Character)
	local TiltVelocity = CF(RootPart.CFrame:vectorToObjectSpace(RootPart.Velocity/1.6))
	local WALKSPEEDVALUE = 12 / (Humanoid.WalkSpeed / 16)
	if TORSOVERTICALVELOCITY > 1 and HITFLOOR == nil then
		ANIM = "Jump"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(-5-RAD(TiltVelocity.Z*15)), RAD(0), RAD(0+RAD(TiltVelocity.X*50))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(-25-RAD(TiltVelocity.Z*5)), RAD(0-RAD(TiltVelocity.X*5)), RAD(-30) / 15) * ANGLES(RAD(0), RAD(0), RAD(-30) / 15), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25 + 0.075 * COS(SINE / 55), 0.65 + 0.075 * COS(SINE / 55), 1) * ANGLES(RAD(180 + 2.5 * COS(SINE / 55)), RAD(90), RAD(5 + 2.5 * COS(SINE / 55))) * ANGLES(RAD(15 - 5 * COS(SINE / 55)), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.15 / 3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, .5, 0) * ANGLES(RAD(0), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -0.4, -0.6) * ANGLES(RAD(1+RAD(TiltVelocity.Z*20)), RAD(90), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0+RAD(TiltVelocity.X*50))), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, 0) * ANGLES(RAD(0+RAD(TiltVelocity.Z*20)), RAD(-85), RAD(0)) * ANGLES(RAD(-1 * SIN(SINE / 6)), RAD(0), RAD(0-RAD(TiltVelocity.X*50))), 1 / Animation_Speed)
		end
	elseif TORSOVERTICALVELOCITY < -1 and HITFLOOR == nil then
		ANIM = "Fall"
		if ATTACK == false then
			RootJoint.C0 = Clerp(RootJoint.C0, ROOTC0 * CF(0, 0, 0) * ANGLES(RAD(5-RAD(TiltVelocity.Z*15)), RAD(0), RAD(0+RAD(TiltVelocity.X*50))), 1 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + ((1) - 1)) * ANGLES(RAD(10-RAD(TiltVelocity.Z*5)), RAD(0-RAD(TiltVelocity.X*5)), RAD(-30) / 15) * ANGLES(RAD(0), RAD(0), RAD(-30) / 15), 1 / Animation_Speed)
			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25 + 0.075 * COS(SINE / 55), 0.65 + 0.075 * COS(SINE / 55), 1) * ANGLES(RAD(180 + 2.5 * COS(SINE / 55)), RAD(90), RAD(5 + 2.5 * COS(SINE / 55))) * ANGLES(RAD(15 - 5 * COS(SINE / 55)), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.15 / 3)
			LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, .5, 0) * ANGLES(RAD(0), RAD(0), RAD(-5)) * LEFTSHOULDERC0, 1 / Animation_Speed)
			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1, -0.02) * ANGLES(RAD(1+RAD(TiltVelocity.Z*20)), RAD(90 + 10 *COS(SINE/74)), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0+RAD(TiltVelocity.X*50))), 1 / Animation_Speed)
			LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1, -0.01) * ANGLES(RAD(0+RAD(TiltVelocity.Z*20)), RAD(-85 + 10 *COS(SINE/74)), RAD(0)) * ANGLES(RAD(-1), RAD(0), RAD(0-RAD(TiltVelocity.X*50))), 1 / Animation_Speed)
		end
	elseif TORSOVELOCITY < 1 and HITFLOOR ~= nil then
		local Alpha = .1
		ANIM = "Idle"
		if ATTACK == false then
			WACKYEFFECT({Time = 8, EffectType = "Round Slash", Size = VT(1,.15,1)/150, Size2 = VT(15,.25,15)/150, Transparency = .95, Transparency2 = 1, CFrame = RootPart.CFrame*CFrame.new(0,-2.5,0)*CFrame.Angles(RAD(-2),RAD(MRANDOM(-360, 360)),RAD(0)), MoveToPos = nil, RotationX = 0, RotationY = 0, RotationZ = 0, Material = "Neon", Color = Color3.new(.35,.35,.35), SoundID = nil, SoundPitch = nil, SoundVolume = nil, UserBoomerangMath = true, Boomerang = 200, SizeBoomerang = 190})
			RootJoint.C0 = Clerp(RootJoint.C0,ROOTC0 * CF(0, 0, 0 + 0.045 * COS(SINE / 32)) * ANGLES(RAD(0), RAD(0), RAD(0)) * ANGLES(RAD(2 - 0.4 * COS(SINE / 32)), RAD(0), RAD(0)), 0.15 / Animation_Speed)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + 0.075 * COS(SINE / 55) + ((1) - 1)) * ANGLES(RAD(6.5 + 1.5 * COS(SINE / 55)), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25 + 0.075 * COS(SINE / 55), 0.65 + 0.075 * COS(SINE / 55), 1) * ANGLES(RAD(180 + 2.5 * COS(SINE / 55)), RAD(90), RAD(5 + 2.5 * COS(SINE / 55))) * ANGLES(RAD(15 - 5 * COS(SINE / 55)), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.15 / 3)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5 + 0.075 * COS(SINE / 55), 0) *ANGLES(RAD(0),RAD(15 - 4.5 * COS(SINE / 55)),RAD(2.5)) * LEFTSHOULDERC0, 0.15 / Animation_Speed)  
  			RightHip.C0 = Clerp(RightHip.C0, CF(1, -1 + 0.01, -0.02) * ANGLES(RAD(0), RAD(80 - 5 * COS(SINE / 55)), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)
            LeftHip.C0 = Clerp(LeftHip.C0, CF(-1, -1 + 0.01, -0.01) * ANGLES(RAD(0), RAD(-75 + 5 * COS(SINE / 55)), RAD(0)) * ANGLES(RAD(-2), RAD(0), RAD(0)), 0.15 / Animation_Speed)	
		end
	elseif TORSOVELOCITY > 1 and HITFLOOR ~= nil then
		ANIM = "Walk"
		if ATTACK == false then
		local Alpha = .3
  			RootJoint.C0 = RootJoint.C0:lerp(CF(0,0+.13*SIN(SINE/WALKSPEEDVALUE*2),0 - 0.10 * COS(SINE/(WALKSPEEDVALUE/2)))*ANGLES(RAD(-89+3*SIN(SINE/(WALKSPEEDVALUE/2)))+RAD(TiltVelocity.z)*1,RAD(0),RAD(-180+10*COS(SINE/WALKSPEEDVALUE))),Alpha)
			Neck.C0 = Clerp(Neck.C0, NECKC0 * CF(0, 0, 0 + 0.075 * COS(SINE / 55) + ((1) - 1)) * ANGLES(RAD(2.5 + 1.5 * COS(SINE / 55)), RAD(0), RAD(0)) * ANGLES(RAD(0), RAD(0), RAD(0)), 1 / Animation_Speed)
  			RightShoulder.C0 = Clerp(RightShoulder.C0, CF(1.25 + 0.075 * COS(SINE / 55), 0.65 + 0.075 * COS(SINE / 55), 1) * ANGLES(RAD(180 + 2.5 * COS(SINE / 55)), RAD(90), RAD(5 + 2.5 * COS(SINE / 55))) * ANGLES(RAD(15 - 5 * COS(SINE / 55)), RAD(0), RAD(0)) * RIGHTSHOULDERC0, 0.15 / 3)
            LeftShoulder.C0 = Clerp(LeftShoulder.C0, CF(-1.5, 0.5, 0) * ANGLES(RAD(-30 * COS(SINE / WALKSPEEDVALUE)), RAD(0), RAD(-5 - 2 * COS(SINE/12))) * LEFTSHOULDERC0, 1 / Animation_Speed)
  			LeftHip.C0 = LeftHip.C0:lerp(CF(-1,-1+0.65*COS(SINE/WALKSPEEDVALUE)/2,0-0.5*COS(SINE/WALKSPEEDVALUE)/2)*ANGLES(RAD(-5+15*COS(SINE/WALKSPEEDVALUE))+RootPart.RotVelocity.Y/75+SIN(SINE/WALKSPEEDVALUE)/2.5*-RAD(TiltVelocity.z)*10,RAD(-90-25*COS(SINE/WALKSPEEDVALUE)*RAD(TiltVelocity.X)*5.5),RAD(0))*ANGLES(RAD(0-2*COS(SINE/WALKSPEEDVALUE)),RAD(0),RAD(0)),Alpha)
  			RightHip.C0 = RightHip.C0:lerp(CF(1,-1-0.65*COS(SINE/WALKSPEEDVALUE)/2,0+0.5*COS(SINE/WALKSPEEDVALUE)/2)*ANGLES(RAD(-5-15*COS(SINE/WALKSPEEDVALUE))-RootPart.RotVelocity.Y/-75+-SIN(SINE/WALKSPEEDVALUE)/2.5*-RAD(TiltVelocity.z)*10,RAD(90+25*COS(SINE/WALKSPEEDVALUE)*RAD(TiltVelocity.X)*5.5),RAD(0))* ANGLES(RAD(0+2*COS(SINE/WALKSPEEDVALUE)),RAD(0),RAD(0)),Alpha)
		end 
	end
	Humanoid.HipHeight = 0
	Humanoid.JumpPower = 250
	Humanoid.WalkSpeed = 20                          
	unanchor() 
	Humanoid:SetStateEnabled("Dead",false)
	Humanoid:SetStateEnabled(Enum.HumanoidStateType.Dead, false)
	Humanoid:SetStateEnabled("GettingUp",true)
	Humanoid:SetStateEnabled(Enum.HumanoidStateType.GettingUp, true)
	Humanoid:SetStateEnabled("Ragdoll",false)
	Humanoid:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
	Humanoid:SetStateEnabled("FallingDown",false)
	Humanoid:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
	Humanoid:SetStateEnabled("Seated",false)
	Humanoid:SetStateEnabled(Enum.HumanoidStateType.Seated, false)
	Humanoid:SetStateEnabled("PlatformStanding",false)
	Humanoid:SetStateEnabled(Enum.HumanoidStateType.PlatformStanding, false)
	Humanoid.MaxHealth = 1e9999999
	Humanoid.Health = 1e999999999 
	if game.ReplicatedFirst:FindFirstChildOfClass("Humanoid") == nil then
		Humanoid = IT("Humanoid",game.ReplicatedFirst)
        Humanoid.HipHeight = 0
	end	
	Musika.SoundId = "rbxassetid://" .. Song
	Musika.Looped = true
	Musika.Pitch = Pitch
	Musika.Volume = Volu
	Musika.Playing = true
	Musika.EmitterSize = 35
	if Musika.Parent ~= RootPart then
		print("Fixing music")
		Musika = IT("Sound", RootPart)
		Musika.SoundId = "rbxassetid://" .. Song
		Musika.Looped = true
		Musika.Pitch = Pitch
		Musika.Volume = Volu 
		Musika.Playing = true
		Musika.EmitterSize = 45
		Musika.TimePosition = TSTP
		FIXING = true
	elseif FIXING == false then
		TSTP = Musika.TimePosition
	else
		FIXING = false
	end	
end	
