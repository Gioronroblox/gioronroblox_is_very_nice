game.Players.LocalPlayer.Character["PrimeRaven"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["SeeMonkey"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["Pink Hair"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["Kate Hair"].Handle.Mesh:Destroy() --LavanderHair
game.Players.LocalPlayer.Character["LavanderHair"].Handle.Mesh:Destroy()
game.Players.LocalPlayer.Character["Robloxclassicred"].Handle.Mesh:Destroy()
--game.Players.LocalPlayer.Character["Surfboard"].Handle.Handle:Destroy()
game.Players.LocalPlayer.Character["VANS_Umbrella"].Handle.Mesh:Destroy()


local c = game.Players.LocalPlayer.Character
for i, v in pairs({"Right Arm", "Left Arm"}) do
    local arm = c[v]
    arm.Parent = nil
    arm.Transparency = 1
    arm.Parent = c
end

local c = game.Players.LocalPlayer.Character
for i, v in pairs({"Right Leg", "Left Leg"}) do
    local Leg = c[v]
    Leg.Parent = nil
    Leg.Transparency = 1
    Leg.Parent = c
end

local v3_net, v3_808 = Vector3.new(0, 25.1, 0), Vector3.new(8, 0, 8)
		local function getNetlessVelocity(realPartVelocity)
			local mag = realPartVelocity.Magnitude
			if mag > 1 then
				local unit = realPartVelocity.Unit
				if (unit.Y > 0.25) or (unit.Y < -0.75) then
					return unit * (25.1 / unit.Y)
				end
			end 
			return v3_net + realPartVelocity * v3_808
		end
		local simradius = "shp" --simulation radius (net bypass) method
--simulation radius (net bypass) method
--"shp" - sethiddenproperty
--"ssr" - setsimulationradius
--false - disable
local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
local newanimate = false --disables the animate script and enables after reanimation
local discharscripts = true --disables all localScripts parented to your character before reanimation
local R15toR6 = true --tries to convert your character to r6 if its r15
local hatcollide = true --makes hats cancollide (only method 0)
local humState16 = true --enables collisions for limbs before the humanoid dies (using hum:ChangeState)
local addtools = false --puts all tools from backpack to character and lets you hold them after reanimation
local hedafterneck = false --disable aligns for head and enable after neck is removed
local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
local method = 0 --reanimation method
--methods:
--0 - breakJoints (takes [loadtime] seconds to laod)
--1 - limbs
--2 - limbs + anti respawn
--3 - limbs + breakJoints after [loadtime] seconds
--4 - remove humanoid + breakJoints
--5 - remove humanoid + limbs
local alignmode = 3 --AlignPosition mode
--modes:
--1 - AlignPosition rigidity enabled true
--2 - 2 AlignPositions rigidity enabled both true and false
--3 - AlignPosition rigidity enabled false

healthHide = healthHide and ((method == 0) or (method == 2) or (method == 000)) and gp(c, "Head", "BasePart")

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = v3(0, 0, 0)
local inf = math.huge

local c = lp.Character

if not (c and c.Parent) then
	return
end

c.Destroying:Connect(function()
	c = nil
end)

local function gp(parent, name, className)
	if typeof(parent) == "Instance" then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end

local function align(Part0, Part1)
	Part0.CustomPhysicalProperties = PhysicalProperties.new(0.0001, 0.0001, 0.0001, 0.0001, 0.0001)

	local att0 = Instance.new("Attachment", Part0)
	att0.Orientation = v3_0
	att0.Position = v3_0
	att0.Name = "att0_" .. Part0.Name
	local att1 = Instance.new("Attachment", Part1)
	att1.Orientation = v3_0
	att1.Position = v3_0
	att1.Name = "att1_" .. Part1.Name

	if (alignmode == 1) or (alignmode == 2) then
		local ape = Instance.new("AlignPosition", att0)
		ape.ApplyAtCenterOfMass = false
		ape.MaxForce = inf
		ape.MaxVelocity = inf
		ape.ReactionForceEnabled = false
		ape.Responsiveness = 200
		ape.Attachment1 = att1
		ape.Attachment0 = att0
		ape.Name = "AlignPositionRtrue"
		ape.RigidityEnabled = true
	end

	if (alignmode == 2) or (alignmode == 3) then
		local apd = Instance.new("AlignPosition", att0)
		apd.ApplyAtCenterOfMass = false
		apd.MaxForce = inf
		apd.MaxVelocity = inf
		apd.ReactionForceEnabled = false
		apd.Responsiveness = 200
		apd.Attachment1 = att1
		apd.Attachment0 = att0
		apd.Name = "AlignPositionRfalse"
		apd.RigidityEnabled = false
	end

	local ao = Instance.new("AlignOrientation", att0)
	ao.MaxAngularVelocity = inf
	ao.MaxTorque = inf
	ao.PrimaryAxisOnly = false
	ao.ReactionTorqueEnabled = false
	ao.Responsiveness = 200
	ao.Attachment1 = att1
	ao.Attachment0 = att0
	ao.RigidityEnabled = false

	if type(getNetlessVelocity) == "function" then
	    local realVelocity = v3_0
        local steppedcon = stepped:Connect(function()
            Part0.Velocity = realVelocity
        end)
        local heartbeatcon = heartbeat:Connect(function()
            realVelocity = Part0.Velocity
            Part0.Velocity = getNetlessVelocity(realVelocity)
        end)
        Part0.Destroying:Connect(function()
            Part0 = nil
            steppedcon:Disconnect()
            heartbeatcon:Disconnect()
        end)
    end
end

local function respawnrequest()
	local ccfr = ws.CurrentCamera.CFrame
	local c = lp.Character
	lp.Character = nil
	lp.Character = c
	local con = nil
	con = ws.CurrentCamera.Changed:Connect(function(prop)
	    if (prop ~= "Parent") and (prop ~= "CFrame") then
	        return
	    end
	    ws.CurrentCamera.CFrame = ccfr
	    con:Disconnect()
    end)
end

local destroyhum = (method == 4) or (method == 5)
local breakjoints = (method == 0) or (method == 4)
local antirespawn = (method == 0) or (method == 2) or (method == 3)

hatcollide = hatcollide and (method == 0)

addtools = addtools and gp(lp, "Backpack", "Backpack")

local fenv = getfenv()
local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.set_simulation_rad or fenv.setsimulationrad

if shp and (simradius == "shp") then
	spawn(function()
		while c and heartbeat:Wait() do
			shp(lp, "SimulationRadius", inf)
		end
	end)
elseif ssr and (simradius == "ssr") then
	spawn(function()
		while c and heartbeat:Wait() do
			ssr(inf)
		end
	end)
end

antiragdoll = antiragdoll and function(v)
	if v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
		v.Parent = nil
	end
end

if antiragdoll then
	for i, v in pairs(c:GetDescendants()) do
		antiragdoll(v)
	end
	c.DescendantAdded:Connect(antiragdoll)
end

if antirespawn then
	respawnrequest()
end

if method == 0 then
	wait(loadtime)
	if not c then
		return
	end
end

if discharscripts then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("LocalScript") then
			v.Disabled = true
		end
	end
elseif newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate and (not animate.Disabled) then
		animate.Disabled = true
	else
		newanimate = false
	end
end

if addtools then
	for i, v in pairs(addtools:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = c
		end
	end
end

pcall(function()
	settings().Physics.AllowSleep = false
	settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
end)

local OLDscripts = {}

for i, v in pairs(c:GetDescendants()) do
	if v.ClassName == "Script" then
		table.insert(OLDscripts, v)
	end
end

local scriptNames = {}

for i, v in pairs(c:GetDescendants()) do
	if v:IsA("BasePart") then
		local newName = tostring(i)
		local exists = true
		while exists do
			exists = false
			for i, v in pairs(OLDscripts) do
				if v.Name == newName then
					exists = true
				end
			end
			if exists then
				newName = newName .. "_"    
			end
		end
		table.insert(scriptNames, newName)
		Instance.new("Script", v).Name = newName
	end
end

c.Archivable = true
local hum = c:FindFirstChildOfClass("Humanoid")
if hum then
	for i, v in pairs(hum:GetPlayingAnimationTracks()) do
		v:Stop()
	end
end
local cl = c:Clone()
if hum and humState16 then
    hum:ChangeState(Enum.HumanoidStateType.Physics)
    if destroyhum then
        wait(1.6)
    end
end
if hum and hum.Parent and destroyhum then
    hum:Destroy()
end

if not c then
    return
end

local head = gp(c, "Head", "BasePart")
local torso = gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")
if hatcollide and c:FindFirstChildOfClass("Accessory") then
    local anything = c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script")
    if not (torso and root and anything) then
        return
    end
    torso:Destroy()
    root:Destroy()
    if shp then
        for i,v in pairs(c:GetChildren()) do
            if v:IsA("Accessory") then
                shp(v, "BackendAccoutrementState", 0)
            end 
        end
    end
    anything:Destroy()
    if head then
       head:Destroy()
    end
end

for i, v in pairs(cl:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
		v.Anchored = false
	end
end

local model = Instance.new("Model", c)
model.Name = model.ClassName

model.Destroying:Connect(function()
	model = nil
end)

for i, v in pairs(c:GetChildren()) do
	if v ~= model then
		if addtools and v:IsA("Tool") then
			for i1, v1 in pairs(v:GetDescendants()) do
				if v1 and v1.Parent and v1:IsA("BasePart") then
					local bv = Instance.new("BodyVelocity", v1)
					bv.Velocity = v3_0
					bv.MaxForce = v3(1000, 1000, 1000)
					bv.P = 1250
					bv.Name = "bv_" .. v.Name
				end
			end
		end
		v.Parent = model
	end
end

if breakjoints then
	model:BreakJoints()
else
	if head and torso then
		for i, v in pairs(model:GetDescendants()) do
			if v:IsA("Weld") or v:IsA("Snap") or v:IsA("Glue") or v:IsA("Motor") or v:IsA("Motor6D") then
				local save = false
				if (v.Part0 == torso) and (v.Part1 == head) then
					save = true
				end
				if (v.Part0 == head) and (v.Part1 == torso) then
					save = true
				end
				if save then
					if hedafterneck then
						hedafterneck = v
					end
				else
					v:Destroy()
				end
			end
		end
	end
	if method == 3 then
		spawn(function()
			wait(loadtime)
			if model then
				model:BreakJoints()
			end
		end)
	end
end

cl.Parent = c
for i, v in pairs(cl:GetChildren()) do
	v.Parent = c
end
cl:Destroy()

local modelDes = {}
for i, v in pairs(model:GetDescendants()) do
	if v:IsA("BasePart") then
		i = tostring(i)
		v.Destroying:Connect(function()
			modelDes[i] = nil
		end)
		modelDes[i] = v
	end
end
local modelcolcon = nil
local function modelcolf()
	if model then
		for i, v in pairs(modelDes) do
			v.CanCollide = false
		end
	else
		modelcolcon:Disconnect()
	end
end
modelcolcon = stepped:Connect(modelcolf)
modelcolf()

for i, scr in pairs(model:GetDescendants()) do
	if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
		local Part0 = scr.Parent
		if Part0:IsA("BasePart") then
			for i1, scr1 in pairs(c:GetDescendants()) do
				if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
					local Part1 = scr1.Parent
					if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
						align(Part0, Part1)
						break
					end
				end
			end
		end
	end
end

if (typeof(hedafterneck) == "Instance") and head then
	local aligns = {}
	local con = nil
	con = hedafterneck.Changed:Connect(function(prop)
	    if (prop == "Parent") and not hedafterneck.Parent then
	        con:Disconnect()
    		for i, v in pairs(aligns) do
    			v.Enabled = true
    		end
		end
	end)
	for i, v in pairs(head:GetDescendants()) do
		if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
			i = tostring(i)
			aligns[i] = v
			v.Destroying:Connect(function()
			    aligns[i] = nil
			end)
			v.Enabled = false
		end
	end
end

for i, v in pairs(c:GetDescendants()) do
	if v and v.Parent then
		if v.ClassName == "Script" then
			if table.find(scriptNames, v.Name) then
				v:Destroy()
			end
		elseif not v:IsDescendantOf(model) then
			if v:IsA("Decal") then
				v.Transparency = 1
			elseif v:IsA("ForceField") then
				v.Visible = false
			elseif v:IsA("Sound") then
				v.Playing = false
			elseif v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") then
				v.Enabled = false
			end
		end
	end
end

if newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate then
		animate.Disabled = false
	end
end

if addtools then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = addtools
		end
	end
end

local hum0 = model:FindFirstChildOfClass("Humanoid")
if hum0 then
    hum0.Destroying:Connect(function()
        hum0 = nil
    end)
end

local hum1 = c:FindFirstChildOfClass("Humanoid")
if hum1 then
    hum1.Destroying:Connect(function()
        hum1 = nil
    end)
end

if hum1 then
	ws.CurrentCamera.CameraSubject = hum1
	local camSubCon = nil
	local function camSubFunc()
		camSubCon:Disconnect()
		if c and hum1 then
			ws.CurrentCamera.CameraSubject = hum1
		end
	end
	camSubCon = renderstepped:Connect(camSubFunc)
	if hum0 then
		hum0.Changed:Connect(function(prop)
			if hum1 and (prop == "Jump") then
				hum1.Jump = hum0.Jump
			end
		end)
	else
		respawnrequest()
	end
end

local rb = Instance.new("BindableEvent", c)
rb.Event:Connect(function()
	rb:Destroy()
	sg:SetCore("ResetButtonCallback", true)
	if destroyhum then
		c:BreakJoints()
		return
	end
	if hum0 and (hum0.Health > 0) then
		model:BreakJoints()
		hum0.Health = 0
	end
	if antirespawn then
	    respawnrequest()
	end
end)
sg:SetCore("ResetButtonCallback", rb)

spawn(function()
	while c do
		if hum0 and hum1 then
			hum1.Jump = hum0.Jump
		end
		wait()
	end
	sg:SetCore("ResetButtonCallback", true)
end)

R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
if R15toR6 then
    local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
	if part then
	    local cfr = part.CFrame
		local R6parts = { 
			head = {
				Name = "Head",
				Size = v3(2, 1, 1),
				R15 = {
					Head = 0
				}
			},
			torso = {
				Name = "Torso",
				Size = v3(2, 2, 1),
				R15 = {
					UpperTorso = 0.2,
					LowerTorso = -100
				}
			},
			root = {
				Name = "HumanoidRootPart",
				Size = v3(2, 2, 1),
				R15 = {
					HumanoidRootPart = 0
				}
			},
			leftArm = {
				Name = "Left Arm",
				Size = v3(1, 2, 1),
				R15 = {
					LeftHand = -0.73,
					LeftLowerArm = -0.2,
					LeftUpperArm = 0.4
				}
			},
			rightArm = {
				Name = "Right Arm",
				Size = v3(1, 2, 1),
				R15 = {
					RightHand = -0.73,
					RightLowerArm = -0.2,
					RightUpperArm = 0.4
				}
			},
			leftLeg = {
				Name = "Left Leg",
				Size = v3(1, 2, 1),
				R15 = {
					LeftFoot = -0.73,
					LeftLowerLeg = -0.15,
					LeftUpperLeg = 0.6
				}
			},
			rightLeg = {
				Name = "Right Leg",
				Size = v3(1, 2, 1),
				R15 = {
					RightFoot = -0.73,
					RightLowerLeg = -0.15,
					RightUpperLeg = 0.6
				}
			}
		}
		for i, v in pairs(c:GetChildren()) do
			if v:IsA("BasePart") then
				for i1, v1 in pairs(v:GetChildren()) do
					if v1:IsA("Motor6D") then
						v1.Part0 = nil
					end
				end
			end
		end
		part.Archivable = true
		for i, v in pairs(R6parts) do
			local part = part:Clone()
			part:ClearAllChildren()
			part.Name = v.Name
			part.Size = v.Size
			part.CFrame = cfr
			part.Anchored = false
			part.Transparency = 1
			part.CanCollide = false
			for i1, v1 in pairs(v.R15) do
				local R15part = gp(c, i1, "BasePart")
				local att = gp(R15part, "att1_" .. i1, "Attachment")
				if R15part then
					local weld = Instance.new("Weld", R15part)
					weld.Name = "Weld_" .. i1
					weld.Part0 = part
					weld.Part1 = R15part
					weld.C0 = cf(0, v1, 0)
					weld.C1 = cf(0, 0, 0)
					R15part.Massless = true
					R15part.Name = "R15_" .. i1
					R15part.Parent = part
					if att then
						att.Parent = part
						att.Position = v3(0, v1, 0)
					end
				end
			end
			part.Parent = c
			R6parts[i] = part
		end
		local R6joints = {
			neck = {
				Parent = Scarf,
				Name = "Neck",
				Part0 = Scarf, --R6parts.torso
				Part1 = Scarf, --R6parts.head
				C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rootJoint = {
				Parent = R6parts.root,
				Name = "RootJoint" ,
				Part0 = R6parts.root,
				Part1 = R6parts.torso,
				C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rightShoulder = {
				Parent = R6parts.torso,
				Name = "Right Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightArm,
				C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftShoulder = {
				Parent = R6parts.torso,
				Name = "Left Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.leftArm,
				C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			},
			rightHip = {
				Parent = R6parts.torso,
				Name = "Right Hip",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightLeg,
				C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftHip = {
				Parent = R6parts.torso,
				Name = "Left Hip" ,
				Part0 = R6parts.torso,
				Part1 = R6parts.leftLeg,
				C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			}
		}
		for i, v in pairs(R6joints) do
			local joint = Instance.new("Motor6D")
			for prop, val in pairs(v) do
				joint[prop] = val
			end
			R6joints[i] = joint
		end
		hum1.RigType = Enum.HumanoidRigType.R6
		hum1.HipHeight = 0
	end
end



--find rig joints

local function fakemotor()
    return {C0=cf(), C1=cf()}
end

local torso = gp(c, "Torso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")

local neck = gp(torso, "Neck", "Motor6D")
neck = neck or fakemotor()

local rootJoint = gp(root, "RootJoint", "Motor6D")
rootJoint = rootJoint or fakemotor()

local leftShoulder = gp(torso, "Left Shoulder", "Motor6D")
leftShoulder = leftShoulder or fakemotor()

local rightShoulder = gp(torso, "Right Shoulder", "Motor6D")
rightShoulder = rightShoulder or fakemotor()

local leftHip = gp(torso, "Left Hip", "Motor6D")
leftHip = leftHip or fakemotor()

local rightHip = gp(torso, "Right Hip", "Motor6D")
rightHip = rightHip or fakemotor()

--120 fps

local fps = 0
local event = Instance.new("BindableEvent", c)
event.Name = "120 fps"
local floor = math.floor
fps = 1 / fps
local tf = 0
local con = nil
con = game:GetService("RunService").RenderStepped:Connect(function(s)
	if not c then
		con:Disconnect()
		return
	end
    --tf += s
	if tf >= fps then
		for i=1, floor(tf / fps) do
			event:Fire(c)
		end
		tf = 0
	end
end)
local event = event.Event

local hedrot = v3(0, 5, 0)

local uis = game:GetService("UserInputService")
local function isPressed(key)
    return (not uis:GetFocusedTextBox()) and uis:IsKeyDown(Enum.KeyCode[key])
end

local biggesthandle = nil
for i, v in pairs(c:GetChildren()) do
    if v:IsA("Accessory") and v.Name == "VANS_Umbrella" then
        local handle = gp(v, "Handle", "BasePart")
        if biggesthandle then
            if biggesthandle.Size.Magnitude < handle.Size.Magnitude then
                biggesthandle = Handle
            end
       else
            biggesthandle = gp(v, "Handle", "BasePart")
        end
    end
end

if not biggesthandle then
    return
end

local handle1 = gp(gp(model, biggesthandle.Parent.Name, "Accessory"), "Handle", "BasePart")
if not handle1 then
    return
end

handle1.Destroying:Connect(function()
    handle1 = nil
end)
biggesthandle.Destroying:Connect(function()
    biggesthandle = nil
end)

biggesthandle:BreakJoints()
biggesthandle.Anchored = true

for i, v in pairs(handle1:GetDescendants()) do
    if v:IsA("AlignOrientation") then
        v.Enabled = false
   end
end

local mouse = lp:GetMouse()
local fling = false
mouse.Button1Down:Connect(function()
    fling = true
end)
mouse.Button1Up:Connect(function()
    fling = false
end)
local function doForSignal(signal, vel)
    spawn(function()
        while signal:Wait() and c and handle1 and biggesthandle do
            if fling and mouse.Target then
                biggesthandle.Position = mouse.Hit.Position
            end
            handle1.RotVelocity = vel
        end
    end)
end
doForSignal(stepped, v3(100, 100, 100))
doForSignal(renderstepped, v3(100, 100, 100))
doForSignal(heartbeat, v3(20000, 20000, 20000)) --https://web.roblox.com/catalog/63690008/Pal-Hair

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = Vector3.zero
local inf = math.huge

local cplayer = lp.Character

local v3 = Vector3.new

local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
        for i, v in pairs(parent:GetChildren()) do
            if (v.Name == name) and v:IsA(className) then
                return v
            end
        end
    end
    return nil
end

local hat2 = gp(cplayer, "PrimeRaven", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Torso"]
att2.Position = Vector3.new(0, -0, 0)
att2.Rotation = Vector3.new(90, 0, 0)

local hat2 = gp(cplayer, "SeeMonkey", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Torso"]
att2.Position = Vector3.new(0, -0, 0)
att2.Rotation = Vector3.new(90, 0, 0)

local hat2 = gp(cplayer, "Pink Hair", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Left Arm"]
att2.Position = Vector3.new(0, -0, 0)
att2.Rotation = Vector3.new(90, 0, 0)

local hat2 = gp(cplayer, "Kate Hair", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Arm"]
att2.Position = Vector3.new(-0, -0, 0)
att2.Rotation = Vector3.new(90, 0, 0) --LavanderHair

local hat2 = gp(cplayer, "LavanderHair", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Leg"]
att2.Position = Vector3.new(0, 0, 0) --Robloxclassicred
att2.Rotation = Vector3.new(90, 0, 0)

local hat2 = gp(cplayer, "Robloxclassicred", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Left Leg"]
att2.Position = Vector3.new(-0, 0, 0) 
att2.Rotation = Vector3.new(90, 0, 0)

_G.loop = true
local player = game.Players.LocalPlayer
local char = player.Character
local Align = function(Part0, Part1,Mesh)
    local Aligns = {
        AlignOrientation = Instance.new("AlignOrientation", Part0),
        AlignPosition = Instance.new("AlignPosition", Part0)
    }
    
    local Attachments = {
        Attach0 = Instance.new("Attachment", Part0),
        Attach1 = Instance.new("Attachment", Part1)
    }
    local m = Part0:FindFirstChildOfClass('SpecialMesh')--This will get the first "SpecialMesh" it finds if it does not find any, then it will return nil
    if Mesh and m then --If Mesh is set to true and it finds a mesh it will destroy it
        m:Destroy()
    end
    Part0:BreakJoints()
    Aligns.AlignOrientation.Attachment0 = Attachments.Attach0
    Aligns.AlignOrientation.Attachment1 = Attachments.Attach1
    Aligns.AlignOrientation.Responsiveness = math.huge
    Aligns.AlignOrientation.RigidityEnabled = true
    
    Aligns.AlignPosition.Attachment0 = Attachments.Attach0
    Aligns.AlignPosition.Attachment1 = Attachments.Attach1
    Aligns.AlignPosition.Responsiveness = math.huge
    Aligns.AlignPosition.RigidityEnabled = true
        Aligns.AlignPosition.MaxForce = 999999999
        spawn(function()
            while _G.loop do 
                local mag = (Part0.Position - (Part1.CFrame*Attachments.Attach0.CFrame:Inverse()).p).magnitude--magnitude can get the distance between two cframe or position
                if mag >= 5 then 
                Part0.CFrame = Part1.CFrame*Attachments.Attach0.CFrame:Inverse()
                end
                Part0.Velocity = Vector3.new(0,35,0)
                game['Run Service'].Heartbeat:wait()
                end
        end)
 return {Attachments.Attach0, Attachments, Aligns}
        
end 
local hat = Align(char['VANS_Umbrella'].Handle,char['HumanoidRootPart'],false)
local cf = char['HumanoidRootPart'].CFrame*CFrame.new(0,-20,-0)*CFrame.Angles(math.rad(0),math.rad(0),0)
hat[1].CFrame = cf:Inverse() * char['HumanoidRootPart'].CFrame
spawn(function()
    char.AncestryChanged:wait()--if you respawn, it will stop the  loop to avoid lag of using it over and over
    _G.loop = false 
end)
for i,v in pairs (char:GetChildren()) do
	if v:IsA("Accessory") then
		v.Handle.Massless = true
		v.Handle.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
	end
end

local folder = game:GetObjects("rbxassetid://13118393567")[1]  --lo podes simplificar poniendo "script en folder" 
folder.Parent = game:GetService("Players").LocalPlayer


--require(4781464455)() -- Converter

--// SHORTCUTS \\--
local S =setmetatable({},{__index=function(s,i)local serv = select(2,pcall(game.GetService,game,i))if(serv)then rawset(s,i,serv) return serv end end})
local RNG = (function()
	local R=Random.new()
	return function(min,max,intOrDivider)
		local min=min or 0
		local max=max or 1
		
		if(typeof(intOrDivider)=='number')then
			return R:NextInteger(min,max)/intOrDivider
		else
			if(intOrDivider)then
				return R:NextInteger(min,max)
			else
				return R:NextNumber(min,max)
			end
		end
	end
end)()

local M = {R=math.rad;RNG=RNG;RRNG=function(...)return math.rad(RNG(...))end;P=math.pi;C=math.clamp;S=math.sin;C=math.cos;T=math.tan;AS=math.asin;AC=math.acos;AT=math.atan;D=math.deg;H=math.huge;}
local CF = {N=CFrame.new;A=CFrame.Angles;fEA=CFrame.fromEulerAnglesXYZ;}
local C3 = {N=Color3.new;RGB=Color3.fromRGB;HSV=function(...)local data={...}if(typeof(data[1])=='Color3')then return Color3.toHSV(...)else return Color3.fromHSV(...)end;end;}
local V3 = {N=Vector3.new};
local IN = Instance.new;
local R3 = Region3.new

--// START OF THE SCRIPT \\--
local Title = 'T h e  B o y s';
local Info = "The boys are back in town!\n(To kill you)\nMouse 1 - Behead\n(Hold) Z - Cleave\n\nB - Kick\nK - Switch camera"

local Creator = game:service'Players':GetNameFromUserIdAsync(5719877)

warn(string.format([[
	%s
		%s
		
		Created by %s
]],Title,Info:gsub("\n","\n\t\t"),Creator))

-- Initialization --

local Plr = game:GetService("Players"):GetPlayerFromCharacter(folder.Parent);
local PlrGui = PlayerGui
local Char = game:GetService("Players").LocalPlayer.Character
local Ragdoll = folder:WaitForChild'Ragdoll'
Ragdoll.Parent=nil
local Hum = Char:FindFirstChildOfClass'Humanoid'
assert(Hum and Hum.RigType==Enum.HumanoidRigType.R6,"You need to have a Humanoid and be R6.")
local RArm = Char:WaitForChild'Right Arm'
local LArm = Char:WaitForChild'Left Arm'
local Torso = Char:WaitForChild'Torso'
local RLeg = Char:WaitForChild'Right Leg'
local LLeg = Char:WaitForChild'Left Leg'
local Head = Char:WaitForChild'Head'
local Root = Char:WaitForChild'HumanoidRootPart'
local Puddle = folder:WaitForChild'Puddle'
Puddle.Parent=nil
local Liquid = folder:WaitForChild'Drop'
Liquid.Parent=nil
local LiqSplash = folder:WaitForChild'Splash'
local NeutralAnims = true;
local Attack = false;
local Corpses = Instance.new("Folder")
Corpses.Name='Corpses'
Corpses.Parent=workspace.Terrain

local DmgLabel = folder:WaitForChild'DMGPart'
local CritStars =folder:WaitForChild'Crit'
--local Mouse = Plr:GetMouse()
local EffectFolder=Instance.new("Folder")
EffectFolder.Name='Effects'
EffectFolder.Parent=Char
local ProjectileFolder = Instance.new("Folder")
ProjectileFolder.Name='Projectiles'
ProjectileFolder.Parent=EffectFolder
local Cloud = folder:WaitForChild'Cloud'
Cloud.Parent=nil
local Blood = folder:WaitForChild'Blood'
Blood.Parent=nil

local FXFolder = folder:WaitForChild'Effects'
FXFolder.Parent=nil
local Joints = {}
local Sine = 0
local Change = 1
local CamCFrame=CFrame.new()
local Puddles = {}
--local CamFollowing=Head;
local Dead={}

folder:WaitForChild'FX'.Disabled=false
local ProjRemote = Instance.new("RemoteEvent")
ProjRemote.Name='Remote'
ProjRemote.Parent=folder:WaitForChild'FX'
local Projectiles = {}

--local Vector3Sequence,Vector3SequenceKeypoint = unpack(require(folder:WaitForChild'Vector3Sequence'))
--local CFrameSequence,CFrameSequenceKeypoint = unpack(require(folder:WaitForChild'CFrameSequence'))

-- Info UI --
local InfoUI = folder:WaitForChild'InfoUI'
InfoUI.Parent=PlrGui
local InfoFr = InfoUI:WaitForChild'InfoUI'

InfoFr:WaitForChild'Title'.Text = Title
InfoFr:WaitForChild'Info'.Text = Info
InfoFr:WaitForChild'Credit'.Text = "Created by " .. Creator

-- Instance Functions --
--require(7163376902) -- Makes instances work
local baseSound = IN("Sound")
function Sound(parent,id,pitch,volume,looped,effect,autoPlay)
	local Sound = baseSound:Clone()
	Sound.SoundId = "rbxassetid://".. tostring(id or 0)
	Sound.Pitch = pitch or 1
	Sound.Volume = volume or 1
	Sound.Looped = looped or false
	if(not looped and effect)then
		Sound.Stopped:connect(function()
			Sound.Volume = 0
			Sound:destroy()
		end)
	elseif(effect)then
		warn("Sound can't be looped and a sound effect!")
	end
	Sound.Parent =parent or workspace
	if(autoPlay)then
		Sound:Play()
	end
	return Sound
end
function Part(parent,color,material,size,cframe,anchored,cancollide)
	local part = IN("Part")
	part[typeof(color) == 'BrickColor' and 'BrickColor' or 'Color'] = color or C3.N(0,0,0)
	part.Material = material or Enum.Material.SmoothPlastic
	part.TopSurface,part.BottomSurface=10,10
	part.Size = size or V3.N(1,1,1)
	part.CFrame = cframe or CF.N(0,0,0)
	part.CanCollide = cancollide or false
	part.Anchored = anchored or false
	part.Parent = parent
	return part
end



function Weld(part0,part1,c0,c1)
	local weld = IN("Weld")
	weld.Part0 = part0
	weld.Part1 = part1
	weld.C0 = c0 or CF.N()
	weld.C1 = c1 or CF.N()
	weld.Parent = part0
	return weld
end

function Mesh(parent,meshtype,meshid,textid,scale,offset)
	--local part = IN("SpecialMesh")
	--part.MeshId = meshid or ""
	--part.TextureId = textid or ""
	--part.Scale = scale or V3.N(1,1,1)
	--part.Offset = offset or V3.N(0,0,0)
	--part.MeshType = meshtype or Enum.MeshType.Sphere
	--part.Parent = parent
	return part
end

function SoundPart(id,pitch,volume,looped,effect,autoPlay,cf)
	local soundPart = Part(EffectFolder,C3.N(1,1,1),Enum.Material.SmoothPlastic,V3.N(.05,.05,.05),cf,true,false)
	soundPart.Transparency=1
	local Sound = IN("Sound")
	Sound.SoundId = "rbxassetid://".. tostring(id or 0)
	Sound.Pitch = pitch or 1
	Sound.Volume = volume or 1
	Sound.Looped = looped or false
	if(autoPlay)then
		coroutine.wrap(function()
			repeat wait() until Sound.IsLoaded
			Sound.Playing = autoPlay or false
		end)()
	end
	if(not looped and effect)then
		Sound.Stopped:connect(function()
			Sound.Volume = 0
			soundPart:destroy()
		end)
	elseif(effect)then
		warn("Sound can't be looped and a sound effect!")
	end
	Sound.Parent = soundPart
	return Sound
end

function Joint(name,part0,part1,c0,c1,type)
	local joint = IN(type or "Motor6D")
	joint.Part0 = part0
	joint.Part1 = part1
	joint.C0 = c0 or CF.N()
	joint.C1 = c1 or CF.N()
	joint.Parent=part0
	joint.Name=name or part0.." to "..part1.." "..joint.ClassName
	return joint
end

function NewInstance(instance,parent,properties)if(properties.Parent)then properties.Parent=parent end;local new = IN(instance)if(properties)then for prop,val in next, properties do pcall(function() new[prop]=val end)end;end;new.Parent=parent;return new;end

-- Customization --
local DamageColor = Color3.new(1,0,0)
local WalkSpeed = 16
local MusicData = {ID=9045971220;Pitch=1;Volume=1;}
local Soundgroup = folder:WaitForChild'SoundGroup'
local MaxPuddles = 500;

-- Joints and Manipulation --

function IsAllowedAccessory(handle)
	local Attachments={"BodyBackAttachment","BodyFrontAttachment","LeftCollarAttachment","RightCollarAttachment","WaistFrontAttachment","WaistCenterAttachment","WaistBackAttachment"}
	for i = 1,#Attachments do
		if(handle:FindFirstChild(Attachments[i]))then
			return true
		end
	end
	return false
end

local Accessories = {}
for _,v in next, Char:GetDescendants()do
	if(v:IsA'BasePart' and v.Parent:IsA'Accessory' and not IsAllowedAccessory(v))then
		table.insert(Accessories,{v,v.Transparency})
		--v.Transparency=1
	end
end

local Axe = folder:WaitForChild'Axe'
Axe.Parent=Char
Axe.PrimaryPart.Anchored=false
local Hitbox = Axe:WaitForChild'Blade'


--local hitbox2 = Axe:WaitForChild''Blade''


Hitbox.Transparency = 5

game:GetService("Players").LocalPlayer.Character["MeshPartAccessory"].Handle.att1_Handle.Parent = Hitbox
Hitbox.att1_Handle.Rotation = Vector3.new(-80,0,40)
Hitbox.att1_Handle.Position = Vector3.new(1.25,0,-0.75)

--Handle.Transparency  = 1

local Morph = folder:WaitForChild'Morph'
---Morph.Transparency = 1
Head.Transparency=1
--Head:ClearAllChildren()

local HueShift = {
	[344016870]={H=.73,S=1,V=1};--.73;
--	[19342912]={H=.57,S=1,V=.5};
	[407695969]={H=.9,S=.7,V=1};
--	[45322272]={H=0,S=1,V=.4};
--	[407695969]={H=.07,S=.7,V=.8};
}

--[[if(HueShift[Plr.CharacterAppearanceId])then
	--local m = HueShift[Plr.CharacterAppearanceId]
	for _,v in next, Morph.Head:GetDescendants()do
		if(v:IsA'BasePart')then
			if(v.Name~='Hood' and v.Name~='Cone')then
				local H,S,V=C3.HSV(v.Color)
				v.Color=C3.HSV(math.clamp(m.H,0,1),math.clamp(S*m.S,0,1),math.clamp(V*m.V,0,1))
			end
		elseif(v:IsA'ParticleEmitter')then
			if(v.Name~='Smoke')then
				local newSequence={}
				for i = 1,#v.Color.Keypoints do
					local H,S,V=C3.HSV(v.Color.Keypoints[i].Value)
					table.insert(newSequence,ColorSequenceKeypoint.new(v.Color.Keypoints[i].Time,C3.HSV(math.clamp(m.H,0,1),math.clamp(S*m.S,0,1),math.clamp(V*m.V,0,1))))
				end
				v.Color=ColorSequence.new(newSequence)
				
			end
		end
	end
end]]

for _,v in next, Char:children() do
	if(Morph:FindFirstChild(v.Name))then
		local part = Morph[v.Name]
		part.Parent=Char
		part:SetPrimaryPartCFrame(v.CFrame)
		for _,c in next, part:GetDescendants() do
			if(c:IsA'BasePart' and c~=part.PrimaryPart)then
				c.Massless=true
				c.Anchored=false
				local j = Weld(v,c,CFrame.new(),c.CFrame:inverse()*v.CFrame)
				c.CanCollide=false
			end
		end
		part.PrimaryPart:destroy()
	end
end

function GetJoint(joint)
	for i,v in next, Joints do
		if(i==joint or v.J==joint)then
			return v,i;
		end
	end	
	return nil;
end

function getLength(table)local len=0;for i,v in next,table do len=len+1 end;return len;end
function getFirstEntry(table)for i,v in next,table do return i,v end;return nil;end

function Animate(joint,props,alpha,style,dir)
	local joint = typeof(joint)=='string' and Joints[joint].J or typeof(joint)=='table' and joint.J or typeof(joint)=='Instance' and joint or error("lol animate needs a string, table or instance")
	local propName='C0'
	if(typeof(props)=='table' and getLength(props)==1 and select(2,getFirstEntry(props)).lerp)then
		propName,props=getFirstEntry(props)
	end
	
	if(style=='Lerp' and props.lerp)then
		joint[propName] = joint[propName]:lerp(props,alpha)
	else
		if(typeof(props)=='CFrame')then
			props={C0=props}
		end
		local info = TweenInfo.new(alpha or 1,(style~='Lerp' and style) or Enum.EasingStyle.Linear,dir or Enum.EasingDirection.Out,0,false,0)
		local tween = S.TweenService:Create(joint,info,props)
		tween:Play();
		return tween;
	end
end

Joints['RJ'] = Joint("RootJoint",Root,Torso,CF.N(),CF.N())
Joints['NK'] = Joint("neck",Torso,Head,CF.N(0,1.5,0),CF.N())
Joints['LS'] = Joint("Left Shoulder",Torso,LArm,CF.N(-1.5,.5,0),CF.N(0,.5,0))
Joints['RS'] = Joint("Right Shoulder",Torso,RArm,CF.N(1.5,.5,0),CF.N(0,.5,0))
Joints['LH'] = Joint("Left Hip",Torso,LLeg,CF.N(-.5,-2,0),CF.N(0,0,0))
Joints['RH'] = Joint("Right Hip",Torso,RLeg,CF.N(.5,-2,0),CF.N(0,0,0))
Joints['HW'] = Joint("Handle",RArm,Axe.PrimaryPart,CF.N(0,-1,0)*CF.A(M.R(-90),M.R(180),M.R(-90)))

--Handle.Transparency = 1

for i,v in next, Joints do Joints[i]={J=v,D={C0=v.C0,C1=v.C1}} end

--[[for _,v in next, Char:GetDescendants() do
	if(v:IsA'JointInstance' and not GetJoint(v) and (v.Name:find("Hip") or v.Name:find("Shoulder") or v.Name=='Neck' or v.Name:find("Root")))then
		--v:destroy()
	end
end]]


-- Artificial Heartbeat --
local AHB = Instance.new("BindableEvent")
do
	local Timeframe = 0;
	local LastFrame= 0;
	
	local FPS = 60
	AHB:Fire()
	
	game:GetService("RunService").Heartbeat:connect(function(s, p)
		Timeframe = Timeframe + s
		if(Timeframe >= 1/FPS)then
			for i = 1, math.floor(Timeframe/(1/FPS)) do
				AHB:Fire()
			end
			LastFrame = tick()
			Timeframe = Timeframe - (1/FPS) * math.floor(Timeframe / (1/FPS))
		end
	end)
end

function fwait(Frames)
	for i = 1,((typeof(Frames)~='number' or Frames<=0) and 1 or Frames)do
		AHB.Event:wait()
	end
end

-- Stop Animations --
for _,v in next, Hum:GetPlayingAnimationTracks() do
	v:Stop();
end

pcall(game.Destroy,Char:FindFirstChild'Animate')
pcall(game.Destroy,Hum:FindFirstChild'Animator')
-- Effect Functions --

function CamshakePlayer(p,settings)
	local sh = folder:WaitForChild'CamShake':Clone()	
	local optionFolder = sh:WaitForChild'Options'
	for _,v in next, optionFolder:children() do
		if(settings[v.Name])then
			v.Value=settings[v.Name]
		end
	end
	local originVal;
	if(typeof(settings.Origin)=='Vector3')then
		originVal=IN("Vector3Value")
	elseif(typeof(settings.Origin)=='CFrame')then
		originVal=IN("CFrameValue")
	elseif(typeof(settings.Origin)=='Instance')then
		originVal=IN("ObjectValue")
	end
	if(originVal)then
		originVal.Name = 'Origin'
		originVal.Value = settings.Origin
		originVal.Parent=optionFolder
	end
	local parent = p.Character or p:FindFirstChildOfClass'Backpack' or p:FindFirstChildOfClass'PlayerGui'
	if(parent)then
		local nig = sh:Clone();
		nig.Parent=parent
		nig.Disabled=false
		S.Debris:AddItem(nig,(settings.Duration or 2)+1)
	end
end

function Camshake(settings)
	for _,p in next, game:service'Players':players() do
		CamshakePlayer(p,settings)
	end
end

function Tween(object,properties,time,style,dir,repeats,reverse,delay)
	local info = TweenInfo.new(time or 1,style or Enum.EasingStyle.Linear,dir or Enum.EasingDirection.Out,repeats or 0,reverse or false,delay or 0)
	local tween = S.TweenService:Create(object,info,properties)
	tween:Play()
	return tween;
end

local function numLerp(Start,Finish,Alpha)
    return Start + (Finish- Start) * Alpha
end

function IsValidEnum(val,enum,def)
	local enum = Enum[tostring(enum)]
	local succ,err=pcall(function() return enum[val.Name] end)
	if(not err)then
		return val
	else
		return def
	end
end

function IsValid(val,type,def)
	if(typeof(type)=='string')then
		return (typeof(val)==type and val or def)
	elseif(typeof(type)=='table')then
		for i,v in next, type do
			if(typeof(val)==v)then
				return val
			end
		end
	end
	return def
end

function LiquidPuddle(hit,pos,normal,color,mat,size,lerpSize)
	local size = size or M.RNG(.5,1.5)
	if(not Puddles[hit])then
		local C3C=typeof(color)=='BrickColor' and color.Color or color
		local splat = Puddle:Clone();
		local weldConstraint=IN("WeldConstraint")
		if(not hit.Anchored)then
			weldConstraint.Parent=splat
			weldConstraint.Part0=hit
			weldConstraint.Part1=splat
			splat.Anchored=false
		end
		splat.Size = lerpSize and V3.N(0,.025,0) or V3.N(size,.025,size)
		splat.CFrame=CF.N(pos,pos+normal)*CF.A(M.R(90),0,0)
		splat.Color=C3C
		splat.Material=mat or Enum.Material.Glass
		splat.Parent=workspace
		local DespawnData={splat,{Size=V3.N(.05,.025,.05);Transparency=1},.75,Enum.EasingStyle.Linear,Enum.EasingDirection.Out,0,false,3}
		Puddles[splat]={DecayStart=tick(),Size=size,DespawnTweenD=DespawnData}
		if(lerpSize)then
			Tween(splat,{CFrame=splat.CFrame*CF.A(0,M.RRNG(0,360),0)},.4)
			Tween(splat,{Size=V3.N(size,.025,size)},.4).Completed:connect(function(state)
				if(state==Enum.PlaybackState.Completed)then
					Puddles[splat].DespawnTween=Tween(unpack(DespawnData))
					Puddles[splat].DespawnTween.Completed:connect(function(state)if(state==Enum.PlaybackState.Completed)then Puddles[splat].Changed:disconnect() Puddles[splat]=nil; splat:destroy() end end)
					Puddles[splat].Changed = splat.Changed:connect(function()
						if(splat and Puddles[splat])then
							Puddles[splat].Size=splat.Size.x
						end
					end)
				end
			end)
		end
		return false
	elseif(Puddles[hit].Size<12)then
		local newSize = math.min(Puddles[hit].Size+size or M.RNG(.025,.15),5)
		Puddles[hit].Size=newSize
		if(Puddles[hit].Changed)then Puddles[hit].Changed:disconnect()end
		Tween(hit,{Size=V3.N(newSize,.025,newSize),Transparency=0},.3).Completed:connect(function(state)
			if(state==Enum.PlaybackState.Completed)then
				Puddles[hit].DespawnTween=Tween(unpack(Puddles[hit].DespawnTweenD))
				Puddles[hit].Changed = hit.Changed:connect(function()
					if(hit and Puddles[hit])then
						Puddles[hit].Size=hit.Size.x
					end
				end)
				Puddles[hit].DespawnTween.Completed:connect(function(state)if(state==Enum.PlaybackState.Completed)then Puddles[hit].Changed:disconnect() Puddles[hit]=nil; hit:destroy() end end)
			end
		end)
		
		return true
	end
end

function LiquidDrop(data)
	data.Color=data.Color or C3.RGB(100,0,0)
	local ColorC3 = typeof(data.Color)=='BrickColor' and data.Color.Color or data.Color
	data.IgnoreHumanoids=true;
	data.IgnoreInvisibility=true;
	data.IgnoreUncollidables=true;
	data.IgnoreUnanchored=true;
	data.IgnoreExceptions={}
	for part,puddleData in next, Puddles do table.insert(data.IgnoreExceptions,part)end
	
	data.Collision=data.Collision or function(self,_,pos,norm,ignoreList)
		if(pos and norm)then
			self.Part.Transparency=1
			local Raying=false;
			local hit,pos,norm = CastRay(pos+V3.N(0,.1,0),pos,2,ignoreList)
			--pcall(function()self.Part.Prt:destroy()end)
			self.Part.CFrame=CF.N(pos,pos+norm)
			S.Debris:AddItem(self.Part,5)
			local hitPuddle = LiquidPuddle(hit,pos,norm,ColorC3,data.Part.Material,.3,true)
			if(hitPuddle)then
				local att = Instance.new("Attachment",hit)
				att.WorldCFrame=CF.N(pos,pos+norm)
				local asd = LiqSplash:Clone()
				asd.Color=ColorSequence.new(data.Color)
				asd.Parent=att
				asd:Emit(25)
				delay(.1,function()
					S.Debris:AddItem(att,2)
				end)
				Sound(hit,685857471,M.RNG(.85,1.25),1,false,true,true)
			end
		else
			self.Part:destroy()
		end
	end
	data.Part = Liquid:Clone()
	data.Part.Color = ColorC3
	data.Part.Material =data.Material or Enum.Material.Glass
	data.Part.Trail.Color=ColorSequence.new(ColorC3)
	--data.Part.Prt.Color=ColorSequence.new(ColorC3)
	data.Color=ColorC3
	
	Projectile(data)
end

function TableToValues(Tbl)
	local Vals={}
	local Types={boolean='BoolValue';Color3='Color3Value';CFrame='CFrameValue';Vector3='Vector3Value';Ray='RayValue';string='StringValue';number='NumberValue';Instance='ObjectValue'}
	for i,v in next,Tbl do
		local Type = typeof(v)
		if(Types[Type])then
			local Val = Instance.new(Types[Type])
			Val.Name=tostring(i)
			Val.Value=v
			Vals[i]=Val;
		elseif(typeof(v)=='table')then
			local Values=TableToValues(v)
			Vals[i]=Instance.new("Folder")
			Vals[i].Name=i;
			for _,v in next, Values do
				v.Parent=Vals[i]
			end
		end
	end
	return Vals
end

function Projectile(data)
	data.IgnoreUncollidables = data.IgnoreUncollidables or true
	data.IgnoreInvisibility = data.IgnoreInvisibility or true
	data.IgnoreHumanoids = data.IgnoreHumanoids or true
	data.IgnoreUnanchored = data.IgnoreUnanchored or false
	data.Velocity = data.Direction*data.Speed
	
	local part = data.Part
	part.CFrame=data.Origin
	if(data.BeamProjectile)then
		local Beam = part:FindFirstChildOfClass'Beam'
		if(Beam)then
			local A0,A1=Beam.Attachment0,Beam.Attachment1
			if(A0 and A1)then
				local A0P = Part(nil,C3.N(1,1,1),Enum.Material.SmoothPlastic,V3.N(),A0.WorldCFrame,false,false)
				A0P.Name='A0P'
				A0P.Parent=part
				A0.Parent=A0P
	
				local A1P = Part(nil,C3.N(1,1,1),Enum.Material.SmoothPlastic,V3.N(),A1.WorldCFrame,false,false)
				A1P.Name='A1P'
				A1P.Parent=part
				A1.Parent=A1P
				NewInstance("BodyVelocity",A1P,{Velocity=V3.N()})
				NewInstance("BodyVelocity",A0P,{Velocity=V3.N()})
				
				A0P.Transparency=1
				A1P.Transparency=1
				
			end
		end
	end
	--NewInstance("BodyVelocity",part,{Velocity=V3.N()})
	part.Anchored=false
	part.CanCollide=false
	data.ID = game:service'HttpService':GenerateGUID(0)
	for _,v in next, data.Part:GetDescendants()do if(v:IsA'BasePart')then v:SetNetworkOwner(Plr.real) end end
	data.Ignorelist=data.Ignore or {Char}
	Projectiles[data.ID]=data;
	data.Type='Projectile'
	local Values = IN("Folder")
	Values.Name='Values'
	Values.Parent=part
	for _,v in next, TableToValues(data)do
		v.Parent=Values
	end
	part.Parent=ProjectileFolder
	part.Velocity = data.Velocity
	part:SetNetworkOwner(Plr.real)
	ProjRemote:FireClient(Plr.real,data)
end

--[[ProjRemote.OnServerEvent:connect(function(p,id,...)]] --OnServer(function(p,id,...)
	if(p~=Plr)then return p:Kick("lol") end
	if(id=='CamUpdate')then
		CamCFrame=...
	else
		local data = Projectiles[id]
		if(data)then
			if(({...})[1] and data.Collision)then
				data:Collision(...)
			else
				data.Part:destroy()
			end
			Projectiles[id]=nil;
		end
	end
--end)

local FXInformation = {}
function EffectFunc(data)
	if(typeof(data)=='Instance' and data:IsA'ModuleScript')then	data=require(data)end
	assert(typeof(data)=='table',"Expected 'table' calling EffectFunc")
	data.Parent=EffectFolder
	if(data.BeamEffect)then
		return Slash(data)
	end
	
	local Lifetime = data.Lifetime or 1;
	local Color = data.Color or Color3.new(1,1,1)
	local EndColor = data.EndColor
	local Size = data.Size or Vector3.new(1,1,1)
	local EndSize = data.EndSize
	local Transparency = data.Transparency or 0
	local EndTransparency = data.EndTransparency or 1
	local Material = data.Material or Enum.Material.Neon;
	local Part = typeof(data.RefPart)=='Instance' and data.RefPart or typeof(data.RefPart)=='string' and FXFolder:FindFirstChild(data.RefPart);
	local CF = data.CFrame or CFrame.new(0,10,0)
	local EndCF = data.EndCFrame or data.EndPos
	local Mesh = data.MeshData or data.Mesh or {MeshType=Enum.MeshType.Brick}
	local Rotation = data.Rotation or {0,0,0}
	local UpdateCF = data.UpdateCFrame;
	local Update = data.Update;
	
	local CSQ,SSQ,TSQ,CFQ;
	if(typeof(Color)=='BrickColor')then Color = Color.Color end
	if(typeof(EndColor)=='BrickColor')then EndColor = EndColor.Color end
	if(typeof(Color)=='ColorSequence')then
		CSQ = Color
	elseif(typeof(Color)=='Color3' and typeof(EndColor)=='Color3')then
		CSQ = ColorSequence.new(Color,EndColor)
	elseif(typeof(Color)=='Color3')then
		CSQ = ColorSequence.new(Color)
	else
		CSQ = ColorSequence.new(Color3.new(1,1,1))
	end
	
	
	if(typeof(Size)=='table' and Size.Keypoints and typeof(Size.Keypoints[1].Value)=='Vector3')then
		SSQ = Size
	elseif(typeof(Size)=='Vector3' and typeof(EndSize)=='Vector3')then
		SSQ = Vector3Sequence.new(Size,EndSize)
	elseif(typeof(Size)=='Vector3')then
		SSQ = Vector3Sequence.new(Size)
	else
		SSQ = Vector3Sequence.new(Vector3.new(1,1,1))
	end
	
	if(typeof(CF)=='table' and CF.Keypoints and typeof(CF.Keypoints[1].Value)=='CFrame')then
		CFQ = CF
	elseif(typeof(CF)=='CFrame' and typeof(EndCF)=='CFrame')then
		CFQ = CFrameSequence.new(CF,EndCF)
	elseif(typeof(CF)=='CFrame')then
		CFQ = CFrameSequence.new(CF)
	else
		CFQ = CFrameSequence.new(CFrame.new(0,10,0))
	end
		
	if(typeof(Transparency)=='NumberSequence')then
		TSQ = Transparency
	elseif(typeof(Transparency)=='number' and typeof(EndTransparency)=='number')then
		TSQ = NumberSequence.new(Transparency,EndTransparency)
	elseif(typeof(Transparency)=='number')then
		TSQ = NumberSequence.new(Transparency)
	else
		TSQ = NumberSequence.new(0,1)
	end
	
	
	--local part,mesh;
	if(not Part or not Part:IsA'BasePart')then
		--part = Instance.new("Part")
		--mesh = Instance.new("SpecialMesh",part)
	else
	--	part=Part:Clone();
	--	mesh=part:FindFirstChildOfClass'DataModelMesh'
	end
	--part.Color = CSQ.Keypoints[1].Value
	--part.Transparency = TSQ.Keypoints[1].Value
	--part.Size = (not mesh and SSQ.Keypoints[1].Value or Vector3.new(1,1,1))
	--part.Anchored = true
	--part.CanCollide = false
	--part.CFrame = CFQ.Keypoints[1].Value
	--part.Material = Material
	--part.Locked = true
	--part.Parent = EffectFolder
	if(mesh)then
		--mesh.Scale = SSQ.Keypoints[1].Value
		--mesh.MeshType = Mesh.MeshType or Mesh.Type or Enum.MeshType.Brick
		--mesh.MeshId = Mesh.MeshId or Mesh.Id or ""
		--mesh.TextureId = Mesh.TextureId or Mesh.Texture or ""
	end
	game:service'Debris':AddItem(part,Lifetime*1.5)
	table.insert(FXInformation,{
		Part=part;
		Mesh=mesh;
		Lifetime=Lifetime;
		Create=tick();
		ColorSeq=CSQ;
		SizeSeq=SSQ;
		TranSeq=TSQ;
		CFSeq=CFQ;
		ColorPoint=CSQ.Keypoints[1];
		SizePoint=SSQ.Keypoints[1];
		TranPoint=TSQ.Keypoints[1];
		CFPoint=CFQ.Keypoints[1];
		Rotation=Rotation;
		CurrRot=CFrame.new();
		UpdateCF=(typeof(UpdateCF)=='function' and UpdateCF or typeof(UpdateCF)=='Instance' and UpdateCF:IsA'ModuleScript' and require(UpdateCF) or nil);
		OnUpdate=(typeof(Update)=='function' and Update or typeof(Update)=='Instance' and Update:IsA'ModuleScript' and require(Update) or nil)
	})
end

function GetKeyframe(sequence,currentTime,lifeTime)
	local scale = currentTime/lifeTime
	for i = 1,#sequence.Keypoints do
		local keyframe = sequence.Keypoints[i]
		local nframe = sequence.Keypoints[i+1]
		if(not nframe or keyframe.Time>=scale and keyframe.Time<nframe.Time)then
			return keyframe
		end
	end
	return sequence.Keypoints[1];
end;

coroutine.wrap(function()
	while true do
		fwait()
		local queue={}
		for i,dat in next, FXInformation do
			local part,mesh,lifetime,created,csq,ssq,tsq,cfq,rot,ucf,upd = 
																	dat.Part,
																	dat.Mesh,
																	dat.Lifetime,
																	dat.Create,
																	dat.ColorSeq,
																	dat.SizeSeq,
																	dat.TranSeq,
																	dat.CFSeq,
																	dat.Rotation,
																	dat.UpdateCF,
																	dat.OnUpdate;
			local current = tick();
			local elapsed = tick()-created
			local currentcpoint = GetKeyframe(csq,elapsed,lifetime)
			local currentspoint = GetKeyframe(ssq,elapsed,lifetime)
			local currenttpoint = GetKeyframe(tsq,elapsed,lifetime)
			local currentcfpoint = GetKeyframe(cfq,elapsed,lifetime)
			
			local currentcolor = currentcpoint.Value
			local currenttrans = currenttpoint.Value
			local currentsize = currentspoint.Value
			local currentcf = currentcfpoint.Value
			
			if(currentcpoint~=dat.ColorPoint)then
				Tween(part,{Color=currentcolor},(currentcpoint.Time-dat.ColorPoint.Time)*lifetime)
				dat.ColorPoint=currentcpoint
			end
			if(currenttpoint~=dat.TranPoint)then
				Tween(part,{Transparency=currenttrans},(currenttpoint.Time-dat.TranPoint.Time)*lifetime)
				dat.TranPoint=currenttpoint
			end
			if(currentspoint~=dat.SizePoint)then
				if(mesh)then
					Tween(mesh,{Scale=currentsize},(currentspoint.Time-dat.SizePoint.Time)*lifetime)
				else
					Tween(part,{Size=currentsize},(currentspoint.Time-dat.SizePoint.Time)*lifetime)
				end
				
				dat.SizePoint=currentspoint
			end
			local newRot={0,0,0}
			if(rot=='random')then
				dat.CurrRot = CFrame.Angles(math.rad(Random.new():NextInteger(0,360)),math.rad(Random.new():NextInteger(0,360)),math.rad(Random.new():NextInteger(0,360)))
			elseif(typeof(rot)=='table')then
				dat.CurrRot = dat.CurrRot*CFrame.Angles(math.rad(rot[1]),math.rad(rot[2]),math.rad(rot[3]))
			end
			if(ucf and typeof(ucf)=='function')then
				part.CFrame=ucf(dat)
			elseif(#cfq.Keypoints==2)then
				part.CFrame=cfq.Keypoints[1].Value:lerp(cfq.Keypoints[2].Value,elapsed/lifetime)*dat.CurrRot
			else
				if(currentcfpoint~=dat.CFPoint)then
					Tween(part,{CFrame=currentcf},(currentcfpoint.Time-dat.CFPoint.Time)*lifetime)
					dat.CFPoint=currentcfpoint
				end
			end
			if(typeof(upd)=='function')then upd(dat) end
			if(not part or not part.Parent)then
				table.insert(queue,tostring(i))
			end
			if(elapsed>=lifetime)then
				part:destroy()
			end
		end
		for _,v in next, queue do FXInformation[tonumber(v)]=nil; end
	end
end)()

function Slash(data) -- Credit to Kyu for the basic idea behind it
	local Parent = IsValid(data.Parent,'Instance',workspace)
	local Color = IsValid(data.Color,{'Color3','BrickColor'},Color3.new(1,1,1))
	local Width = IsValid(data.Width,'number',2);
	local EndWidth = IsValid(data.EndWidth,'number',0);
	local Length = IsValid(data.Length,'number',1);
	local EndLength = IsValid(data.EndLength,'number',Length*2);
	local Curve = IsValid(data.Curve,"number",2);
	local EndCurve = IsValid(data.EndCurve,"number",Curve*2);
	local SCFrame = IsValid(data.CFrame,'CFrame',CFrame.new(0,10,0))
	local Lifetime = IsValid(data.Lifetime,'number',.25)
	local Offset = IsValid(data.Offset,'CFrame',CFrame.new())
	local Style = IsValidEnum(IsValid(data.EasingStyle,'EnumItem',Enum.EasingStyle.Quad),Enum.EasingStyle,Enum.EasingStyle.Quad)
	local Direction = IsValidEnum(IsValid(data.EasingDirection,'EnumItem',Enum.EasingDirection.Out),Enum.EasingDirection,Enum.EasingDirection.Out)
	local Delay = IsValid(data.Delay,'number',0)
	local BeamProperties = IsValid(data.BeamProps,'table',{})
	local FadeAway = IsValid(data.Fades,'boolean',false)
	local FadeStyle = IsValidEnum(IsValid(data.FadeStyle,'EnumItem',Enum.EasingStyle.Linear),Enum.EasingStyle,Enum.EasingStyle.Linear)
	local FadeDir = IsValidEnum(IsValid(data.FadeDirection,'EnumItem',Enum.EasingDirection.Out),Enum.EasingDirection,Enum.EasingDirection.Out)
	local CSQ;
	local TSQ;
	if(typeof(Color)=='ColorSequence')then
		CSQ = Color
	elseif(typeof(Color)=='Color3')then
		CSQ = ColorSequence.new(Color)
	elseif(typeof(Color)=='BrickColor')then
		CSQ = ColorSequence.new(Color.Color)
	else
		CSQ = ColorSequence.new(Color3.new(1,1,1))
	end
	
	local P = Part(Parent,Color,Enum.Material.SmoothPlastic,Vector3.new(0,0,0),SCFrame,true,false)
	P.Transparency = 1
	local A0 = Instance.new("Attachment")
	local A1 = Instance.new("Attachment")
	A0.Position = Vector3.new(0,0,Length)
	A1.Position = Vector3.new(0,0,-Length)
	A0.Parent=P
	A1.Parent=P
	local Beam = Instance.new("Beam")
	Beam.Attachment0=A0
	Beam.Attachment1=A1
	Beam.FaceCamera=true
	Beam.LightInfluence=BeamProperties.LightInfluence or 0
	Beam.LightEmission=BeamProperties.LightEmission or 1
	for i,v in next, BeamProperties do
		pcall(function() Beam[i]=v end)
	end
	Beam.Color = CSQ
	Beam.CurveSize0 = Curve
	Beam.CurveSize1 = -Curve
	Beam.Width0=Width
	Beam.Width1=Width
	Beam.Parent=P
	local ti = {Lifetime,Style,Direction,0,false,Delay}
	Tween(P,{CFrame = SCFrame*Offset},unpack(ti))
	Tween(Beam,{Width0=EndWidth,Width1=EndWidth,CurveSize0=EndCurve,CurveSize1=-EndCurve},unpack(ti))
	Tween(A0,{Position=Vector3.new(0,0,EndLength)},unpack(ti))
	Tween(A1,{Position=Vector3.new(0,0,-EndLength)},unpack(ti)).Completed:connect(function() P:destroy() end)
	if(FadeAway)then
		local part = Instance.new("Part")
		part.Transparency = Beam.Transparency.Keypoints[1].Value or 0
		Tween(part,{Transparency=1},Lifetime,FadeStyle,FadeDir,0,false,Delay)
		repeat fwait()
			Beam.Transparency=NumberSequence.new(part.Transparency)
		until not P.Parent
	end
end

function ShowDamage(CFr,Text,Color)
	local DmgPrt = DmgLabel:Clone();
	DmgPrt.Parent= EffectFolder
	DmgPrt.CFrame=CFr
	local Label = DmgPrt:WaitForChild'BBG':WaitForChild'Text'
	Label.TextColor3=typeof(Color)=='BrickColor' and Color.Color or typeof(Color)=='Color3' and Color or Color3.new(1,0,0)
	Label.Text = tostring(Text)
	local Rot = M.RNG(0,75,true)
	Tween(Label,{TextTransparency=0,TextStrokeTransparency=0.5},.15,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0,false,0)
	Tween(Label,{Rotation=Rot},.5,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0,false,0).Completed:connect(function()
		Tween(Label,{Rotation=-Rot},.5,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut,0,false,0).Completed:wait()
		Tween(Label,{Rotation=0},.35,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0,false,0)
	end)
	
	Tween(DmgPrt,{CFrame=CFr+V3.N(0,2,0)},.5,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0,true,0)
	delay(1.75,function()
		Tween(Label,{Rotation=M.RNG(-90,90,true),TextTransparency=1,TextStrokeTransparency=1},2,Enum.EasingStyle.Quad,Enum.EasingDirection.Out,0,false,0).Completed:wait()
		DmgPrt:destroy()
	end)
end

-- Utility Functions --
function CastRay(startPos,endPos,range,ignoreList)
	local ray = Ray.new(startPos,(endPos-startPos).unit*range)
	local part,pos,norm = workspace:FindPartOnRayWithIgnoreList(ray,ignoreList or {Char},false,true)
	return part,pos,norm,(pos and (startPos-pos).magnitude)
end

function GetTorso(char)
	return char:FindFirstChild'Torso' or char:FindFirstChild'UpperTorso' or char:FindFirstChild'LowerTorso' or char:FindFirstChild'HumanoidRootPart'
end

function getRegion(point,range,ignore)
    return workspace:FindPartsInRegion3WithIgnoreList(R3(point-V3.N(1,1,1)*range/2,point+V3.N(1,1,1)*range/2),ignore,100)
end

-- Damage Functions --
function DealDamage(data)
	local Who = data.Who;
	local MinDam = data.MinimumDamage or 15;
	local MaxDam = data.MaximumDamage or 30;
	local MaxHP = data.MaxHP or 1e5; 
	local DamageIsPercentage = data.PercentageDamage or true
	
	local DB = data.Debounce or .2;
	
	local CritData = data.Crit or {}
	local CritChance = CritData.Chance or 0;
	local CritMultiplier = CritData.Multiplier or 1;
	
	
	local OnHitFunc = data.OnHit
	local DeathFunction = data.OnDeath
	
	assert(Who,"Specify someone to damage!")	
	
	local Humanoid = Who:FindFirstChildOfClass'Humanoid'
	local Critical = M.RNG(1,100,true) <= CritChance
	local DoneDamage = M.RNG(MinDam,MaxDam,true) * (Critical and CritMultiplier or 1)
	
	local canHit = true
	if(Humanoid)then
		if(canHit)then
			local HitTorso = GetTorso(Who)
			local player = S.Players:GetPlayerFromCharacter(Who)
			
			if(not player or player.UserId ~= 344016870 and player.UserId ~= 407695969)then
				if(Humanoid.MaxHealth >= MaxHP and Humanoid.Health > 0)then
					print'Got kill'
					Humanoid.Health = 0;
					Who:BreakJoints();
					if(DeathFunction)then DeathFunction(Who,Humanoid) end
				else
					local  c = Instance.new("ObjectValue",Hum)
					c.Name = "creator"
					c.Value = Plr
					S.Debris:AddItem(c,0.35)
					local DoneDamage = DoneDamage*(DamageIsPercentage and Humanoid.MaxHealth/100 or 1)
					if(Critical and HitTorso)then
						local Att = IN("Attachment",HitTorso)
						local Stars = CritStars:Clone()
						Stars.Parent=Att
						Stars:Emit(25)
						S.Debris:AddItem(Att,1)
					end
					if(Who:FindFirstChild'Head' and Humanoid.Health > 0)then
						--ShowDamage(Who.Head.CFrame*CF.N(M.RNG(-2,2),2,M.RNG(-2,2)),-DoneDamage,Critical and C3.N(1,1,0) or DamageColor)
					end
					if(Humanoid.Health > 0 and Humanoid.Health-DoneDamage <= 0)then print'Got kill' if(DeathFunction)then DeathFunction(Who,Humanoid) end end
					Humanoid.Health = Humanoid.Health - DoneDamage
					if(OnHitFunc)then
						OnHitFunc(Who,HitTorso)
					end
				end
			end
		end
	end		
end

function AoE(where,range,func)
	local hit = {}
	for _,v in next, getRegion(where,range,{Char}) do
		local hum = (v.Parent and v.Parent:FindFirstChildOfClass'Humanoid')
		if(hum and not hit[hum])then
			hit[hum] = true
			func(v.Parent,hum)
		end
	end
	return hit
end

function AoEDamage(where,range,data)
	AoE(where,range,function(c,h)
		data.Who=c
		DealDamage(data)
	end)
end

function Kill(who,knockout,snapneck,slitneck,beheaded)
	local rag = Ragdoll:Clone()
	rag.Parent = who
	rag.SlitNeck.Value = slitneck or false
	rag.Knockout.Value = knockout or false
	rag.SnapNeck.Value = snapneck or false
	rag.Behead.Value = beheaded or false
	rag.Disabled = false
	--BloodLevel=BloodLevel+M.RNG(6,12,true)
	local Torso = GetTorso(who)
	if(not knockout)then
		Dead[Torso]={Char=who,Times=0,Beheaded=beheaded,Last=tick(),Delay=0}
		who.Parent=Corpses
	end
end

function Knockback(velocity,decay)
	return function(w,t)
		local BV = IN("BodyVelocity")
		BV.P=20000
		BV.MaxForce=V3.N(M.H,M.H,M.H)
		BV.Velocity=velocity or V3.N(0,25,0)+(Root.CFrame.lookVector*25)
		BV.Parent=t
		S.Debris:AddItem(BV,decay or .5)
	end
end

function Kick()
	Attack=true
	NeutralAnims=false
	WalkSpeed=0
 	Animate("HW",CF.N(0,-1,0)*CF.A(M.R(90),M.R(0),M.R(90)),.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
  	Animate("LS",CF.N(-1.5,0.48,-0.23)*CF.A(M.R(36.2),M.R(0),M.R(0)),.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
  	Animate("LH",CF.N(-0.62,-2,-0.46)*CF.A(M.R(14.7),M.R(0),M.R(-3.9)),.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
  	Animate("RJ",CF.N(0,0.07,-0.06)*CF.A(M.R(-14.7),M.R(0),M.R(0)),.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
  	Animate("NK",CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
  	Animate("RH",CF.N(0.5,-1.27,-0.33)*CF.A(M.R(-26),M.R(0),M.R(0)),.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
  	Animate("RS",CF.N(1.5,0.48,-0.23)*CF.A(M.R(36.2),M.R(0),M.R(0)),.3,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut).Completed:wait()
	local instCount=#workspace:GetDescendants()
	coroutine.wrap(function()
		while Attack do
			AoE(RLeg.CFrame.p,3,function(char,hum)
				if(hum.Health>0)then
					Kill(char,true,false,false,false)
					local tor = GetTorso(char)
					if(tor)then
						Sound(tor,429400881,1,2,false,true,true)
						local bl = Blood:Clone()
						bl.Parent=IN("Attachment",tor)
						bl:Emit(5)
						tor.Velocity=Root.CFrame.lookVector*25
					end
				end
			end)
			fwait(instCount>3000 and 3 or 0)
		end
	end)()
	
	Animate("HW",CF.N(0,-1,0)*CF.A(M.R(90),M.R(0),M.R(90)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
	Animate("LS",CF.N(-1.5,0.49,-0.09)*CF.A(M.R(-66.8),M.R(0),M.R(0)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
	Animate("LH",CF.N(-0.62,-1.8,0.68)*CF.A(M.R(-26.3),M.R(0),M.R(-3.9)),.075,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
	Animate("RJ",CF.N(0,-0.07,0.19)*CF.A(M.R(26.3),M.R(0),M.R(0)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
	Animate("NK",CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
	Animate("RH",CF.N(0.5,-1.51,-0.98)*CF.A(M.R(59.1),M.R(0),M.R(0)),.075,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
	Animate("RS",CF.N(1.5,0.49,-0.09)*CF.A(M.R(-66.8),M.R(0),M.R(0)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut).Completed:wait()

	WalkSpeed=16
	NeutralAnims=true
	Attack=false	
end

function Behead()
	Attack=true
	NeutralAnims=false
	WalkSpeed=4
	local swoosh = Sound(Root,2174939388,1.2,2,false,true,false)
	
	Animate("HW",CF.N(0,-1,0)*CF.A(M.R(90),M.R(0),M.R(90)),.4,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
  	Animate("LS",CF.N(-0.09,0.38,-1.06)*CF.A(M.R(102.8),M.R(0),M.R(73)),.4,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
  	Animate("LH",CF.N(-0.81,-1.99,-0.13)*CF.A(M.R(0),M.R(20),M.R(-3)),.4,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
  	Animate("RJ",CF.N(0,0.01,0)*CF.A(M.R(0),M.R(-41.9),M.R(0)),.4,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
  	Animate("NK",CF.N(0,1.5,0)*CF.A(M.R(0),M.R(41.9),M.R(0)),.4,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
  	Animate("RH",CF.N(0.57,-2.02,0.02)*CF.A(M.R(0),M.R(0),M.R(4.9)),.4,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
  	Animate("RS",CF.N(1.06,-0.08,0.12)*CF.A(M.R(-179.3),M.R(-49.5),M.R(70.6)),.4,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
	fwait(18)
	swoosh:Play()
	fwait(4)
	-- swing
	
	local instCount=#workspace:GetDescendants()
	coroutine.wrap(function()
		while Attack do
			AoE(Hitbox.CFrame.p,2,function(char,hum)
				if(hum.Health>0)then
					Kill(char,false,false,false,true)
					local tor = GetTorso(char)
					if(tor)then
						Sound(tor,429400881,1,2,false,true,true)
						local bl = Blood:Clone()
						local cl = Cloud:Clone()
						cl.Parent=IN("Attachment",tor)
						bl.Parent=cl.Parent
						cl.Color=ColorSequence.new(C3.RGB(100,0,0))
						cl:Emit(25)
						bl:Emit(100)
						tor.Velocity=-Root.CFrame.rightVector*75
					end
				end
			end)
			fwait(instCount>3000 and 3 or 0)
		end
	end)()
	Animate("HW",CF.N(0,-1,0)*CF.A(M.R(90),M.R(0),M.R(90)),.075)
	Animate("LS",CF.N(-0.68,0.33,-1.03)*CF.A(M.R(100.9),M.R(-4.7),M.R(56.8)),.075,Enum.EasingStyle.Sine)
	Animate("LH",CF.N(-0.81,-1.99,-0.13)*CF.A(M.R(0),M.R(20),M.R(-3)),.1,Enum.EasingStyle.Sine)
	Animate("RJ",CF.N(0.06,0.01,-0.07)*CF.A(M.R(0),M.R(36.7),M.R(0)),.075,Enum.EasingStyle.Sine)
	Animate("NK",CF.N(-0.09,1.5,0.02)*CF.A(M.R(0),M.R(-36.7),M.R(0)),.1,Enum.EasingStyle.Sine)
	Animate("RH",CF.N(0.57,-2.02,0.02)*CF.A(M.R(0),M.R(0),M.R(4.9)),.1,Enum.EasingStyle.Sine)
	Animate("RS",CF.N(0.68,0.21,-0.12)*CF.A(M.R(-169.3),M.R(-65.1),M.R(97.9)),.075,Enum.EasingStyle.Sine)
	fwait(1)

	
	Animate("HW",CF.N(0,-1,0)*CF.A(M.R(90),M.R(0),M.R(90)),.15,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut)
	Animate("LS",CF.N(-1.04,0.33,-0.15)*CF.A(M.R(87.8),M.R(-11.6),M.R(-20.9)),.15,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut)
	Animate("LH",CF.N(-0.81,-1.99,-0.13)*CF.A(M.R(0),M.R(20),M.R(-3)),.2,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut)
	Animate("RJ",CF.N(0.06,0.01,-0.07)*CF.A(M.R(0),M.R(64.2),M.R(0)),.2,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut)
	Animate("NK",CF.N(-0.09,1.5,0.02)*CF.A(M.R(0),M.R(-64.2),M.R(0)),.2,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut)
	Animate("RH",CF.N(0.57,-2.02,0.02)*CF.A(M.R(0),M.R(0),M.R(4.9)),.2,Enum.EasingStyle.Sine,Enum.EasingDirection.InOut)
	Animate("RS",CF.N(0.15,0.21,-1.27)*CF.A(M.R(-5.6),M.R(-37.3),M.R(-95.2)),.15,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
	fwait(8)
	Animate("HW",CF.N(0.01,-1.17,-0.2)*CF.A(M.R(-33.5),M.R(-2),M.R(93.2)),.1,Enum.EasingStyle.Sine).Completed:wait()

	WalkSpeed=16
	Attack=false
	NeutralAnims=true
	
end

function Cleave(key)
	NeutralAnims=false
	WalkSpeed=16
	local swingNum=0;
	while game:service'UserInputService':IsKeyDown(key)do
		Attack=true
		local currSwing=swingNum+1
		swingNum=currSwing
		local swoosh = Sound(Root,2174939388,1.5,2,false,true,false)
		--swing start--
		Animate("HW",CF.N(0.04,-0.97,0)*CF.A(M.R(90),M.R(45),M.R(90)),.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
		Animate("LS",CF.N(-0.85,0.88,0.38)*CF.A(M.R(-152),M.R(0),M.R(45)),.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
		Animate("LH",CF.N(-0.5,-1.69,0.32)*CF.A(M.R(-24.7),M.R(0),M.R(0)),.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
		Animate("RJ",CF.N(0,-0.31,0)*CF.A(M.R(24.7),M.R(0),M.R(0)),.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
		Animate("NK",CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
		Animate("RH",CF.N(0.5,-2.01,-0.28)*CF.A(M.R(14),M.R(0),M.R(0)),.15,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
		delay(.1,function()
			swoosh:Play()
		end)
		Animate("RS",CF.N(1.15,0.99,0.43)*CF.A(M.R(-152),M.R(0),M.R(-45)),.2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut).Completed:wait()
		local instCount=#workspace:GetDescendants()
		coroutine.wrap(function()
			while swingNum==currSwing and Attack do
				AoE(Hitbox.CFrame.p,2,function(char,hum)
					if(hum.Health>0)then
						Kill(char,false,false,false,false)
						local tor = GetTorso(char)
						if(tor)then
							Sound(tor,429400881,1,2,false,true,true)
							local bl = Blood:Clone()
							local cl = Cloud:Clone()
							cl.Parent=IN("Attachment",tor)
							bl.Parent=cl.Parent
							cl.Color=ColorSequence.new(C3.RGB(100,0,0))
							cl:Emit(25)
							bl:Emit(100)
							tor.Velocity=Root.CFrame.lookVector*75-V3.N(0,25,0)
						end
					end
				end)
				fwait(instCount>3000 and 3 or 0)
			end
		end)()
		--swing end--
		Animate("HW",CF.N(0.24,-1.17,-0.33)*CF.A(M.R(33.9),M.R(29.2),M.R(125.9)),.15,Enum.EasingStyle.Back,Enum.EasingDirection.Out)
		Animate("LS",CF.N(-0.85,0.6,-0.42)*CF.A(M.R(39.8),M.R(0),M.R(45)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
		Animate("LH",CF.N(-0.5,-2,0)*CF.A(M.R(19.6),M.R(2.1),M.R(-7.4)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
		Animate("RJ",CF.N(0,-0.15,-0.37)*CF.A(M.R(-19.6),M.R(0),M.R(0)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
		Animate("NK",CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
		Animate("RH",CF.N(0.5,-2,0)*CF.A(M.R(-20),M.R(-0.7),M.R(3.4)),.075,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
		Animate("RS",CF.N(1.15,0.5,-0.5)*CF.A(M.R(39.8),M.R(0),M.R(-45)),.1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut)
		fwait(7)
		Attack=false
	end
	NeutralAnims=true
	WalkSpeed=16
end

-- Attacks, Animations and other keybinds --

game:service'UserInputService'.InputBegan:connect(function(io,gpe)
	if(gpe or Attack)then return end
	if(io.KeyCode==Enum.KeyCode.Z)then
		Cleave(io.KeyCode)
	elseif(io.KeyCode==Enum.KeyCode.K)then
		CamFollowing=not CamFollowing and Head or nil;
		--Type="CamFollowPart",Part=CamFollowing;})
	elseif(io.UserInputType==Enum.UserInputType.MouseButton1)then
		Behead()
	elseif(io.KeyCode==Enum.KeyCode.B)then
		Kick()
	end
end)


-- End Loop --


while true do
	Sine=Sine+Change
	if(not Music or not Music.Parent)then
		local tp = (Music and Music.TimePosition)
		Music = Sound(Torso,MusicData.ID,MusicData.Pitch,MusicData.Volume,true,false,true)
		Music.Name = 'Music'
		Music.TimePosition = tp
	end
	
	local Walking = Hum.MoveDirection.magnitude>0
	local Hit,Pos = CastRay(Root.Position,Root.Position-V3.N(0,1,0),4)
	local State = (Hum.Sit and "Sit" or not Hit and Root.Velocity.Y<-1 and 'Fall' or not Hit and Root.Velocity.Y>1 and 'Jump' or Walking and "Walk" or "Idle")
	
	Music.SoundId = "rbxassetid://"..MusicData.ID
	Music.Parent = Torso
	Music.Pitch = MusicData.Pitch
	Music.Volume = MusicData.Volume
	Music.MaxDistance=150
	Music:ClearAllChildren()
	Music.SoundGroup=Soundgroup
	
	if(not EffectFolder or EffectFolder.Parent~=Char)then
		pcall(game.destroy,EffectFolder)
		EffectFolder=Instance.new("Folder")
		EffectFolder.Name='Effects'
		EffectFolder.Parent=Char
	end
	
	if(not Corpses or Corpses.Parent~=workspace.Terrain)then
		pcall(game.destroy,Corpses)
		Corpses = Instance.new("Folder")
		Corpses.Name='Corpses'
		Corpses.Parent=workspace.Terrain
	end
	local Direction = Root.CFrame:ToObjectSpace(CamCFrame).lookVector.unit
	Animate("NK",{C1=CF.N(0,-.5-.2*M.C(Sine/48),0)*CF.A(M.R(0-5*M.S(Sine/48)),0,0)*CF.A(0,M.AS(Direction.X),0)*CF.A(-M.AS(Direction.Y),0,0)},.2,'Lerp')
	
	local FwdDir = (Walking and Hum.MoveDirection*Root.CFrame.lookVector or V3.N())
	local RigDir = (Walking and Hum.MoveDirection*Root.CFrame.rightVector or V3.N())
	local Vec = {
		X=(RigDir.X+RigDir.Z)*(Hum.WalkSpeed/16),
		Z=(FwdDir.X+FwdDir.Z)*(Hum.WalkSpeed/16)
	};
	local Divide = 1
	if(Vec.Z<0)then
		Divide=math.clamp(-(1.25*Vec.Z),1,2)
	end
	Vec.Z = Vec.Z/Divide
	Vec.X = Vec.X/Divide
	Hum.WalkSpeed = WalkSpeed/Divide
	
	local WsFactor = 6/(WalkSpeed/16)
	
	if(NeutralAnims)then	
		if(State == 'Idle')then
			local Alpha = .2
			Animate("HW",CF.N(-0.43,-1.1,-0.04)*CF.A(M.R(77.8),M.R(3.3),M.R(11+6*M.C(Sine/24))),Alpha,"Lerp")
			Animate("LS",CF.N(-1.5,0.23,-0.04)*CF.A(M.R(73.3-20*M.S(Sine/24)+12*M.C(Sine/24)),M.R(-20.1),M.R(0)),Alpha,"Lerp")
			Animate("LH",CF.A(M.R(-2-2*M.S(Sine/24)),0,0)*CF.N(-0.53,-1.9-.1*M.C(Sine/24),0.01)*CF.A(M.R(0),M.R(0),M.R(-2.2)),Alpha,"Lerp")
			Animate("RJ",CF.N(0,-.1+.1*M.C(Sine/24),0)*CF.A(M.R(2+2*M.S(Sine/24)),M.R(0),M.R(0)),Alpha,"Lerp")
			Animate("NK",CF.N(0,1.5,0)*CF.A(M.R(0),M.R(0),M.R(0)),Alpha,"Lerp")
			Animate("RH",CF.A(M.R(-2-2*M.S(Sine/24)),0,0)*CF.N(0.65,-1.9-.1*M.C(Sine/24),0.02)*CF.A(M.R(0),M.R(0),M.R(6.2)),Alpha,"Lerp")
			Animate("RS",CF.N(1.19,0.09,0.01)*CF.A(M.R(78.3),M.R(-4.7+8*M.S(Sine/24)),M.R(-12.8)),Alpha,"Lerp")
		elseif(State == 'Walk')then
			local Alpha = .3*(Hum.WalkSpeed/16)
			Animate('RJ',CF.N(0,-.2+.1*M.C(Sine/(WsFactor/2)),-.1*Vec.Z)*CF.A(M.R(-10-3*M.S(Sine/(WsFactor/2)))*Vec.Z,M.R(0+5*M.S(Sine/WsFactor)),M.R(-10)*Vec.X),Alpha,'Lerp')
			Animate('NK',Joints.NK.D.C0*CF.A(M.R(0+6*M.S(Sine/(WsFactor/2)))*Vec.Z,M.R(0+6*M.C(Sine/WsFactor))*Vec.Z,0),Alpha,'Lerp')
			Animate('LS',Joints.LS.D.C0*CF.N(0,0,0+.25*M.S(Sine/WsFactor)*Vec.Z)*CF.A(M.R(0-35*M.S(Sine/WsFactor))*Vec.Z,M.R(0+10*M.S(Sine/WsFactor))*Vec.Z,M.R(-5-10*M.S(Sine/WsFactor))*Vec.Z),Alpha,'Lerp')
			Animate('RS',Joints.RS.D.C0*CF.N(0,0,.2-.1*M.S(Sine/WsFactor)*Vec.Z)*CF.A(M.R(-25+15*M.S(Sine/WsFactor))*Vec.Z,M.R(-25),M.R(0)),Alpha,'Lerp')
			Animate('LH',CF.N(-.5+.8*M.S(Sine/WsFactor)*Vec.X,-1.8+.3*M.C(Sine/WsFactor),-.1-.8*M.S(Sine/WsFactor)*Vec.Z)*CF.A((M.R(0+55*M.S(Sine/WsFactor))+M.R(0-15*M.C(Sine/WsFactor)))*Vec.Z,M.R(2),M.R(-2))*CF.A(0,0,(M.R(0+55*M.S(Sine/WsFactor))+M.R(0-15*M.C(Sine/WsFactor)))*Vec.X),Alpha,'Lerp')
			Animate('RH',CF.N(.5-.8*M.S(Sine/WsFactor)*Vec.X,-1.8-.3*M.C(Sine/WsFactor),-.1+.8*M.S(Sine/WsFactor)*Vec.Z)*CF.A((M.R(0-55*M.S(Sine/WsFactor))+M.R(0+15*M.C(Sine/WsFactor)))*Vec.Z,M.R(-2),M.R(2))*CF.A(0,0,(M.R(0-55*M.S(Sine/WsFactor))+M.R(0+15*M.C(Sine/WsFactor)))*Vec.X),Alpha,'Lerp')	
			
			Animate('HW',Joints.HW.D.C0,Alpha,'Lerp')
		elseif(State == 'Jump')then
			local idk = math.min(math.max(Root.Velocity.Y/75,-M.R(45)),M.R(45))
			Animate('LS',Joints.LS.D.C0*CF.A(M.R(-5),0,M.R(-90)),.2,'Lerp')
			Animate('RS',Joints.RS.D.C0*CF.A(M.R(-5),0,M.R(90)),.2,'Lerp')
			Animate('RJ',Joints.RJ.D.C0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),.2,'Lerp')
			Animate('NK',Joints.NK.D.C0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),.2,'Lerp')
			Animate('LH',Joints.LH.D.C0*CF.A(0,0,M.R(-5)),.2,'Lerp')
			Animate('RH',Joints.RH.D.C0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),.2,'Lerp')
			Animate('HW',Joints.HW.D.C0,.2,'Lerp')
		elseif(State == 'Fall')then
			local idk = math.min(math.max(Root.Velocity.Y/75,-M.R(45)),M.R(45))
			Animate('LS',Joints.LS.D.C0*CF.A(M.R(-5),0,M.R(-90)+idk),.2,'Lerp')
			Animate('RS',Joints.RS.D.C0*CF.A(M.R(-5),0,M.R(90)-idk),.2,'Lerp')
			Animate('RJ',Joints.RJ.D.C0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),.2,'Lerp')
			Animate('NK',Joints.NK.D.C0*CF.A(math.min(math.max(Root.Velocity.Y/100,-M.R(45)),M.R(45)),0,0),.2,'Lerp')
			Animate('LH',Joints.LH.D.C0*CF.A(0,0,M.R(-5)),.2,'Lerp')
			Animate('RH',Joints.RH.D.C0*CF.N(0,1,-1)*CF.A(M.R(-5),0,M.R(5)),.2,'Lerp')
			Animate('HW',Joints.HW.D.C0,.2,'Lerp')
		end
	end	
	for tors,data in next, Dead do
		if(not data.Char or not data.Char:IsDescendantOf(workspace) or data.Times>150)then
			Dead[tors]=nil
		else
			data.Times=data.Times+1
			--local head = data.Char:FindFirstChild'Head'
			if(head and data.Beheaded)then
				--local h,p,n = CastRay(head.Position,head.Position-V3.N(0,1,0),4,{Char,Corpses,data.Char})
				if(h)then
					LiquidPuddle(h,p,n,C3.RGB(100,0,0),Enum.Material.Glass,.2,true)
				end
			end
			local h,p,n = CastRay(tors.Position,tors.Position-V3.N(0,1,0),4,{Char,Corpses,data.Char})
			if(h)then
				LiquidPuddle(h,p,n,C3.RGB(100,0,0),Enum.Material.Glass,.2,true)
			end
		end
	end
	fwait()
end

--\\ FIN //--
